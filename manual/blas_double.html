<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
BLAS Support for double type</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="blas_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="blas.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="blas.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">BLAS Support for double type</td> 
</tr></tbody></table><hr>
<h1>
BLAS Support for double type</h1>
<ul>Blas (double type)
<li><a href="#l1">Level 1</a>
<li><a href="#l2">Level 2</a>
<li><a href="#l3">Level 3</a>
</ul>
<hr>

<h2>Module Blas</h2>
<h3>Constants</h3>
<ul>The following conventions are used:<br>
<li> Blas::Trans, Blas::NoTrans, Blas::ConjTrans
are equal to true, false and nil respectively
<li>Blas::Upper, Blas::Lower
are equal to true,  false  respectively
<li>Blas::Unit, Blas::NonUnit
are equal to true,  false  respectively
<li>Blas::Left, Blas::Right
are equal to true,  false  respectively
</ul>
<p>


<h3>Level 1</h3>

<a name="ddot"></a>
<a name="dot"></a>
<tt>GSL::Blas#ddot</tt><br>
<tt>x.dot(y) -> result</tt><br>
<tt>x * y  -> result</tt>&nbsp; (alias)<br>
GSL::Vector x, y; double result<br>
<p>
<a name="dnrm2"></a>
<a name="norm"></a>
<tt>GSL::Vector#dnrm2</tt><br>
<tt>GSL::Vector#norm</tt>&nbsp; (alias)<br>
<tt>x.dnrm2() -> result </tt><br>
GSL::Vector x; double result<br>
This method computes the Euclidean norm ||x||_2 = \sqrt {\sum x_i^2} of the 
vector x.
<p>
<a name="dasum"></a>
<tt>GSL::Blas#dasum</tt><br>
<tt>x.dasum() -> result</tt><br>
GSL::Vector x; double result<br>
This method computes the absolute sum \sum |x_i| of the elements 
of the vector x.
<p>
<a name="idamax"></a>
<tt>GSL::Blas#idamax</tt><br>
<tt>x.idamax() -> anIndex</tt><br>
<p>
<a name="dswap"></a>
<tt>GSL::Blas#dswap</tt><br>
<tt>Blas::dswap(x, y) </tt><br>
GSL::Vector x, y 
This function exchanges the elements of the vectors x and y.
<p>
<tt>GSL::Blas#dcopy</tt><br>
<tt>y.dcopy(x)</tt><br>
GSL::Vector x, y;<br>
This function copies the elements of the vector x into the vector y.<br>
See also GSL::Vector#clone<br>
<p>
<a name="daxpy"></a>
<tt>GSL::Vector#daxpy</tt><br>
<tt>y.xdaxpy(alpha, x) -> y'</tt><br>
GSL::Vector x, y, y'; double alpha<br>
This method computes the sum y' = \alpha x + y for the vectors x and y.
<p>
<a name="daxpy!"></a>
<tt>GSL::Blas#daxpy!</tt><br>
<tt>y.xdaxpy(alpha, x) -> y</tt><br>
Mutating version.<br>
This function computes the sum y = \alpha x + y for the vectors x and y.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL";  include GSL; include Math
require 'gsl_util'

puts "ddot"
v1 = Vector.new([1,0])
v2 = Vector.new([0,1])
assert v1*v1 == 1 &amp;&amp; v1*v2 == 0 

puts "dnrm2"
assert v1*v1 == v1.norm

v3 = Vector.new([7,1,9,2])
v4 = Vector.new([7,1,6.3, -10, 9,2])

puts "dasum"
assert v4.dasum == 35.3

puts "idamax"
assert v3.idamax == 2 &amp;&amp; v4.idamax == 3

puts "dswap"
v3d = v3.clone;
v5 = Vector.new([1,2,2,2])
v5d = v5.clone;
Blas::dswap(v3d, v5d)
assert v5d == v3

puts "dcopy"
v3.dcopy(v5)
assert v3 == v5

puts "daxpy and daxpy!"
v3d = v3.clone;
p v3d.daxpy!(v5, 2.5)
assert v3d == v3 + v5 * 2.5
v6 = v3.daxpy(v5, 2.5)
assert v6 == v3 + v5 * 2.5
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<tt>GSL::Blas#dscal</tt><br>
MISSING<br>
See GSL::Vector#scale and GSL::Vector#scale!<br>
<p>
<a name="drotg"></a>
<tt>GSL::Blas::drotg</tt><br>
<tt>Blas::drotg(a, b) -> anArray</tt><br>
anArray = [c, s, r]<br>
double a, b, c, s, r<br>
This function computes a Givens rotation (c,s) which zeroes the vector (a,b),
<pre>
    [  c  s ] [ a ] = [ r ]
    [ -s  c ] [ b ]   [ 0 ]
c = a/r; s = b/r; r = sqrt(a^2 + b^2)
</pre>
<p>
<a name="drot"></a>
<tt>GSL::Vector#drot</tt><br>
<tt>x.drot(y, c, s) -> anArray</tt><br>
anArray = [x', y']<br>
GSL::Vector x, y, x', y'; double c, s<br>
This method returns a Givens rotation (x', y') = (c x + s y, -s x + c y) 
of the vectors x, y.
<p>
<a name="drotmg"></a>
<tt>GSL::Blas#drotmg</tt><br>
<tt>BLAS::drotmg(d1, d2, x1, x2) -> H</tt><br>
working ?<br>
double d1, d2, x1, x2; GSL::Matrix H<br>
This function computes a modified Given's transformation, that is a
Given's transformation of the vector<br>
This function constructs a modified Givens transformation. 
The input quantities d1, d2, x1, and x2 define a 2-vector in partitioned form:
<pre>
---  ---     ---           ---    ---    ---
|  a1  |     |  sqrt(d1)  0   |   |   x1   |
|      |  =  |                |   |        |
|  a2  |     |   0   sqrt(d2) |   |   x2   |
---  ---     ---           ---    ---    ---

The subroutines determine the modified Givens rotation matrix H that 
transforms X2 and, thus, a2 to 0.
</pre>
(from http://www.unet.univie.ac.at/aix/libs/basetrf2/SROTMG.htm)

<p>
<a name="drotm"></a>
<tt>GSL::Blas#drotm</tt><br>
<tt>matr1.drotm() -> </tt><br>
SKIPPED<br>
Function: int gsl_blas_drotm (gsl_vector * x, gsl_vector * y, const double P[])
These functions apply a modified Given's transformation.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL";  include GSL
include Math
require 'gsl_util'

a = 1.0; b = 2.0
c, s, r = Blas::drotg(a,b)
m = Matrix.new([c, s], [-s, c])
v = Vector.new([1,2])
assert m * v == Vector.new([r,0]) &amp;&amp; r == Vector.new([a,b]).norm

va = Vector.new([1,1,1,1])
vb = Vector.new([2,2,2,2])
v1, v2 = va.drot(vb, c, s)
assert v1 == Vector.new([r,r,r,r]) &amp;&amp; v2 == Vector.new([0,0,0,0])

puts "drotmg ?"
d1 = 12; d2 = 3
b1 = 5 ; b2 = 7
m1 = Blas::drotmg(d1, d2, b1, b2)
v3 = Vector.new([b1,b2])
v3_g = m1 * v3
assert v3_g.norm == v3_g.get(0)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l2"></a>
<h3>Level 2</h3>
<a name="dgemv"></a>
<tt>GSL::Vector#dgemv</tt><br>
<tt>y.dgemv(TransA, alpha, A, x, beta) -> y'</tt><br>
Bool TransA; GSL::Matrix A; GSL::Vector x, y'; double alpha, beta<br>

This method computes the matrix-vector product and sum<br>
y' = \alpha op(A) x + \beta y,<br> 
where op(A) = A, A^T, A^H for TransA = false, true, nil respectively<br>
(shorthand for op(A) = A, A^T, A^H = CblasNoTrans, CblasTrans, CblasConjTrans)
<p>
<a name="dgemv!"></a>
<tt>GSL::Vector#dgemv!</tt><br>
<tt>y.dgemv(TransA, alpha, A, x, beta) -> y'</tt><br>
Corresponding mutating method; y = \alpha op(A) x + \beta y
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL";  include GSL
require 'gsl_util'

m1 = Matrix.new([2,1], [1,3])
v1 = Vector.new([1,0])
v2 = Vector.new([0,1])
v3 = v2.dgemv(false, 2, m1, v1, 3)
assert v3 == m1 * v1 * 2 + v2 * 3
assert v3 == m1.mult_vect(v1).scale(2) + v2.scale(3)

v3 = v2.dgemv(true, 2, m1, v1, 3)
assert v3 == m1.transpose * v1 * 2 + v2 * 3

v2d = v2.clone
v2d.dgemv!(false, 2, m1, v1, 3)
assert v2d == m1 * v1 * 2 + v2 * 3

v2d = v2.clone
v2d.dgemv!(true, 2, m1, v1, 3)
assert v2d == m1.transpose * v1 * 2 + v2 * 3
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="dtrmv"></a>
<tt>GSL::Vector#dtrmv</tt><br>
<tt>x.dtrmv(Uplo, TransA, DiagUnit, A) -> x'</tt><br>
GSL::Vector x, x'; GSL::Matrix A<br>
This method computes the matrix-vector product<br> 
x =\alpha op(A) x for the triangular matrix A, where<br>
op(A) = A, A^T for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.
When Uplo is true then the upper triangle of A is used, and when Uplo is 
false then the lower triangle of A is used. If DiagUnit is false then 
the diagonal of the matrix is used, but if DiagUnit is true then the 
diagonal elements of the matrix A are taken as unity.

<a name="dtrmv!"></a>
<tt>GSL::Vector#dtrmv!</tt><br>
<tt>x.dtrmv!(Uplo, TransA, DiagUnit, A) -> x</tt><br>
Mutating version.<br>
This method computes the matrix-vector product<br>
x =\alpha op(A) x for the triangular matrix A, where<br>
op(A) = A, A^T for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.
When Uplo is true then the upper triangle of A is used, and when Uplo is
false then the lower triangle of A is used. If DiagUnit is false then
the diagonal of the matrix is used, but if DiagUnit is true then the
diagonal elements of the matrix A are taken as unity.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

m3 = Matrix.new([1,2,3], [2,1,1], [1,2,2])
b3 = Vector.new([3,2,4])
m3U = Matrix.new([1,2,3], [0,1,1], [0,0,2])
assert m3U.transpose * b3 == b3.dtrmv(true, true, false, m3)
assert m3U * b3 == b3.dtrmv(true, false, false, m3)
m3UD = Matrix.new([1,2,3], [0,1,1], [0,0,1])

assert m3UD.transpose * b3 == b3.dtrmv(true, true, true, m3)

m3D =  Matrix.new([1,0,0], [2,1,0], [1,2,2])
assert m3D.transpose * b3 == b3.dtrmv(false, true, false, m3)
assert m3D * b3 == b3.dtrmv(false, false, false, m3)

m3DD = Matrix.new([1,0,0], [2,1,0], [1,2,1])
assert m3DD.transpose * b3 == b3.dtrmv(false, true, true, m3)

b3_dup = b3.clone;	b3_dup.dtrmv!(true, true, false, m3);	assert m3U.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrmv!(true, false, false, m3);	assert m3U * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrmv!(true, true, true, m3);	assert m3UD.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrmv!(false, true, false, m3);	assert m3D.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrmv!(false, false, false, m3);	assert m3D * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrmv!(false, true, true, m3);	assert m3DD.transpose * b3 == b3_dup
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="dtrsv"></a>
<tt>GSL::Vector#dtrsv</tt><br>
<tt>x.dtrsv(Uplo, TransA, DiagUnit, A) -> x'</tt><br>
GSL::Vector x, x'; GSL::Matrix A<br>

This method computes x' = inv(op(A)) x ,<br>
where op(A) = A, A^T  for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.
When Uplo is true then the upper triangle of A is used, 
and when Uplo is false then the lower triangle of A is used. 
If DiagUnit is false then the diagonal of
the matrix is used, but if DiagUnit is true then the diagonal elements
of the matrix A are taken as unity.
<p>
<a name="dtrsv!"></a>
<tt>GSL::Vector#dtrsv!</tt><br>
<tt>x.dtrsv!(Uplo, TransA, DiagUnit, A) -> x</tt><br>
GSL::Vector x; GSL::Matrix A<br>
Mutating version<br>
This method computes x = inv(op(A)) x ,<br>
where op(A) = A, A^T  for TransA = true of false.
When Uplo is true then the upper triangle of A is used,
and when Uplo is false then the lower triangle of A is used.
If DiagUnit is false then the diagonal of
the matrix is used, but if DiagUnit is true then the diagonal elements
of the matrix A are taken as unity.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

m3 = Matrix.new([1,2,3], [2,1,1], [1,2,2])
b3 = Vector.new([3,2,4])
m3U = Matrix.new([1,2,3], [0,1,1], [0,0,2])
m3U_inv = Matrix.new([1,-2,-0.5],[0,1,-0.5],[0,0,0.5])
assert m3U_inv.transpose * b3 == b3.dtrsv(true, true, false, m3)
assert m3U_inv * b3 == b3.dtrsv(true, false, false, m3)
m3UD = Matrix.new([1,2,3], [0,1,1], [0,0,1])
m3UD_inv =  Matrix.new([1, -2, -1], [0, 1, -1], [0, 0, 1])
assert m3UD_inv.transpose * b3 == b3.dtrsv(true, true, true, m3)

m3D =  Matrix.new([1,0,0], [2,1,0], [1,2,2])
m3D_inv = Matrix.new([1,0,0],[-2,1,0],[1.5,-1,0.5])
assert m3D_inv.transpose * b3 == b3.dtrsv(false, true, false, m3)
assert m3D_inv * b3 == b3.dtrsv(false, false, false, m3)

m3DD = Matrix.new([1,0,0], [2,1,0], [1,2,1])
m3DD_inv = Matrix.new([1,0,0],[-2,1,0],[3,-2,1])
assert m3DD_inv.transpose * b3 == b3.dtrsv(false, true, true, m3)

b3_dup = b3.clone;	b3_dup.dtrsv!(true, true, false, m3);	assert m3U_inv.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrsv!(true, false, false, m3);	assert m3U_inv * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrsv!(true, true, true, m3);	assert m3UD_inv.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrsv!(false, true, false, m3);	assert m3D_inv.transpose * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrsv!(false, false, false, m3);	assert m3D_inv * b3 == b3_dup
b3_dup = b3.clone;	b3_dup.dtrsv!(false, true, true, m3);	assert m3DD_inv.transpose * b3 == b3_dup
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="dsymv"></a>
<tt>GSL::Blas#dsymv</tt><br>
<tt>y.dsymv(Uplo, alpha, A, x, beta) -> y'</tt><br>
This method computes the matrix-vector product and sum<br>
y' = \alpha A x + \beta y 
for the symmetric matrix A. 
Since the matrix A is symmetric only
its upper half or lower half need to be stored. When Uplo is true
then the upper triangle and diagonal of A are used, and when Uplo is
false then the lower triangle and diagonal of A are used.
<p>
<a name="dsymv!"></a>
<tt>GSL::Blas#dsymv!</tt><br>
<tt>y.dsymv!(Uplo, alpha, A, x, beta) -> y</tt><br>
Corresponding mutating method.<br>
This method computes the matrix-vector product and sum<br>
y = \alpha A x + \beta y
for the symmetric matrix A.
Since the matrix A is symmetric only
its upper half or lower half need to be stored. When Uplo is true
then the upper triangle and diagonal of A are used, and when Uplo is
false then the lower triangle and diagonal of A are used.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

m = Matrix.new([1,2,3], 
               [2,1,1], 
	       [3,1,2])
 	       
m_U = Matrix.new([1,2,3], 
                 [0,1,1], 
          	 [0,0,2])

	       
m_L = Matrix.new([1,0,0], 
                 [2,1,0], 
	         [3,1,2])
		 
v1 = Vector.new([3,2,4])
v2 = Vector.new([5,7,6])
w1 = m * v1 * 2 + v2 * 3
assert v2.dsymv(true, 2, m_U, v1, 3) == w1 &amp;&amp; v2.dsymv(true, 2, m, v1, 3) == w1
assert v2.dsymv(false, 2, m_L, v1, 3) == w1 &amp;&amp; v2.dsymv(false, 2, m, v1, 3) == w1

v2_dup = v2.clone; v2_dup.dsymv!(true, 2, m_U, v1, 3); assert v2_dup == w1
v2_dup = v2.clone; v2_dup.dsymv!(false, 2, m_L, v1, 3); assert v2_dup == w1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>

<a name="dger"></a>
<tt>GSL::Blas#dger</tt><br>
<tt>A.dger(alpha, x, y) -> A'</tt><br>
GSL::Matrix A, A'; GSL::Vector x, y<br>
These functions compute the rank-1 update A' = \alpha x y^T + A of the matrix A.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

m = Matrix.new([1,2,3], [2,1,1], [1,2,2])
alpha = 2
x = Vector.new([3,2,4])
y = Vector.new([1,2,3])
assert m.dger(alpha, x, y) == m  + x.outer(y) * alpha

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="dsyr"></a>
<tt>GSL::Matrix#dsyr</tt><br>
<tt>A.dsyr(Uplo, alpha, x) -> A'</tt><br>
GSL::Matrix A, A'; bool Uplo; double alpha; GSL::Vector x<br>
This method computes the symmetric
rank-1 update A = \alpha x x^T + A of the symmetric matrix A. Since
the matrix A is symmetric only its upper half or lower half need to be
stored. When Uplo is  true then the upper triangle and diagonal
of A are used, and when Uplo is false then the lower triangle and
diagonal of A are used.
<p>
<p>
<a name="dsyr!"></a>
<tt>GSL::Matrix#dsyr!</tt><br>
<tt>A.dsyr!(Uplo, alpha, x) -> A'</tt><br>
Corresponding mutating method.
<p>
<a name="dsyr2"></a>
<tt>GSL::Blas#dsyr2</tt><br>
<tt>A.dsyr2(Uplo, alpha, x) -> A'</tt><br>
GSL::Matrix A, A'; bool Uplo; double alpha; GSL::Vector x<br>
This method computes the symmetric rank-2 update<br>
A = \alpha x y^T + \alpha y x^T +
A of the symmetric matrix A. Since the matrix A is symmetric only its
upper half or lower half need to be stored. When Uplo is true
then the upper triangle and diagonal of A are used, and when Uplo is
false then the lower triangle and diagonal of A are used.
<p>
<a name="dsyr2"></a>
<tt>GSL::Blas#dsyr2</tt><br>
<tt>A.dsyr2(Uplo, alpha, x) -> A</tt><br>
Corresponding mutating method.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

m = Matrix.new([1,2,3], 
               [2,1,1], 
	       [3,1,2])
 	       
m_U = Matrix.new([1,2,3], 
                 [0,1,1], 
          	 [0,0,2])

	       
m_L = Matrix.new([1,0,0], 
                 [2,1,0], 
	         [3,1,2])

alpha = 2		 
v1 = Vector.new([3,2,4])
m1 = v1.outer(v1) * alpha + m
assert m_U.dsyr(true, alpha, v1) == m1.upper(true) 
assert m.dsyr(true, alpha, v1) == m1.upper(true) + m.lower(false)
m_L.dsyr(false, alpha, v1) == m1.lower(true)
m.dsyr(false, alpha, v1) == m1.lower(true) + m1.upper(false)

m_Udup = m_U.clone; assert m_Udup.dsyr!(true, alpha, v1) == m1.upper(true)
m_Ldup = m_L.clone; assert m_Ldup.dsyr!(false, alpha, v1) == m1.lower(true)

v2 = Vector.new([1,2,3])
m1 = v1.outer(v2) * alpha + v2.outer(v1) * alpha + m
assert m_U.dsyr2(true, alpha, v1, v2) == m1.upper(true)


m_Udup = m_U.clone; assert m_Udup.dsyr2!(true, alpha, v1, v2) == m1.upper(true)
m_Ldup = m_L.clone; assert m_Ldup.dsyr2!(false, alpha, v1, v2) == m1.lower(true)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l3"></a>
<h3>Level 3</h3>
<a name="dgemm"></a>
<tt>GSL::Matrix#dgemm</tt><br>
<tt>C.dgemm(TransA, TransB, alpha, A, B, beta) -> C'</tt><br>
This method computes the matrix-matrix product and sum<br>
C' = \alpha op(A) op(B) + \beta C<br>
where op(A) = A, A^T for TransA = false, true respectively; 
similarly for the parameter TransB.
<p>
<a name="dgemm!"></a>
<tt>GSL::Matrix#dgemm!</tt><br>
<tt>C.dgemm!(TransA, TransB, alpha, A, B, beta) -> C</tt><br>
Corresponding mutating method.<br>
This method computes the matrix-matrix product and sum<br>
C = \alpha op(A) op(B) + \beta C<br>
where op(A) = A, A^T for TransA = false, true respectively; 
similarly for the parameter TransB.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL";  include GSL
require 'gsl_util'

m1 = Matrix.new([2,1], [1,3])
m2 = Matrix.new([0,2], [1,-1])

m3 = Matrix.new([1,0],[1,0])
m4 = m3.dgemm(false, false, 2, m1, m2, 3)
assert m4 == m1 * m2 * 2 + m3 * 3
assert m4 == m1.mult(m2).scale(2) + m3.scale(3)

m4 = m3.dgemm(false, true,2, m1, m2, 3)
assert m4 == m1 * m2.transpose * 2 + m3 * 3

m4 = m3.dgemm(true, false, 2, m1, m2, 3)
assert m4 == m1.transpose * m2 * 2 + m3 * 3

m4 = m3.dgemm(true, true, 2, m1, m2, 3)
assert m4 == m1.transpose * m2.transpose * 2 + m3 * 3

m3d = Matrix.new([1,0],[1,0])
m3d.dgemm!(false, false, 2, m1, m2, 3)
assert m3d == m1 * m2 * 2 + m3 * 3

m3d = Matrix.new([1,0],[1,0])
m3d.dgemm!(false, true,2, m1, m2, 3)
assert m3d == m1 * m2.transpose * 2 + m3 * 3

m3d = Matrix.new([1,0],[1,0])
m3d.dgemm!(true, false, 2, m1, m2, 3)
assert m3d == m1.transpose * m2 * 2 + m3 * 3

m3d = Matrix.new([1,0],[1,0])
m3d.dgemm!(true, true, 2, m1, m2, 3)
assert m3d == m1.transpose * m2.transpose * 2 + m3 * 3
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="dsymm"></a>
<tt>GSL::Blas#dsymm</tt><br>
<tt>C.dsymm(SideLeft, Uplo, alpha, A, B, beta) -> C'</tt><br>
This method computes the matrix-matrix product and sum<br>
C = \alpha A B + \beta C when SideLeft = true<br>
C = \alpha B A + \beta C when SideLeft = false 
where the matrix A is symmetric.<br>
When Uplo = true the upper triangle and diagonal of A are used;
when Uplo is false the lower triangle and diagonal of A are used.
<p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

a = Matrix.new([1,2,3], 
               [2,1,1], 
	       [3,1,2])
 	       
a_U = Matrix.new([1,2,3], 
                 [0,1,1], 
          	 [0,0,2])

	       
a_L = Matrix.new([1,0,0], 
                 [2,1,0], 
	         [3,1,2])

b = Matrix.new([4,2,1],[1,3,2],[5,4,3])
c = Matrix.new([7,8,9],[9,8,7],[6,7,8])
alpha = 2
beta = 3 
c1 =  a * b * alpha + c * beta
c2 =  b * a * alpha + c * beta

assert c.dsymm(true, true, alpha, a_U, b, beta) == c1
assert c.dsymm(true, true, alpha, a, b, beta) == c1
assert c.dsymm(false, true, alpha, a_U, b, beta) == c2
assert c.dsymm(true, false, alpha, a_L, b, beta) == c1
assert c.dsymm(false, false, alpha, a_L, b, beta) == c2
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="dtrmm"></a>
<tt>GSL::Blas#dtrmm</tt><br>
<tt>B.dtrmm(SideLeft, Uplo, TransA, DiagUnit, A) -> B'</tt><br>
This method computes the matrix-matrix product<br> 
B = \alpha op(A) B for SideLeft true and<br> 
B = \alpha B op(A) for SideLeft false. 
The matrix A is triangular and op(A) = A, A^T,for TransA = false, true
respectively.
 When Uplo is true then the upper triangle of A is used, and when Uplo is 
 false then the lower triangle of A is used. 
 If DiagUnit is false then the diagonal of A is used, but if Diag is true 
 then the diagonal elements of the matrix A are taken as unity and are 
 not referenced.
<p>
<a name="dtrmm!"></a>
<tt>GSL::Blas#dtrmm!</tt><br>
<tt>B.dtrmm!(SideLeft, Uplo, TransA, DiagUnit, A) -> B</tt><br>
Corresponding mutating method.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

a = Matrix.new([1,2,3], [2,1,1], [1,2,2])
b = Matrix.new([3,2,4],[4,5,6],[5,6,7])
aU = Matrix.new([1,2,3], [0,1,1], [0,0,2])
aUD = Matrix.new([1,2,3], [0,1,1], [0,0,1])
aD =  Matrix.new([1,0,0], [2,1,0], [1,2,2])
aDD = Matrix.new([1,0,0], [2,1,0], [1,2,1])
alpha = 2

assert aU.t * b * alpha == b.dtrmm(true, true, true, false, alpha, a)
assert aU * b  * alpha == b.dtrmm(true, true, false, false, alpha, a)

assert aUD.t * b  * alpha == b.dtrmm(true, true, true, true, alpha, a)

assert aD.t * b  * alpha == b.dtrmm(true, false, true, false, alpha, a)
assert aD * b  * alpha == b.dtrmm(true, false, false, false, alpha, a)

assert aDD.t * b  * alpha == b.dtrmm(true, false, true, true, alpha, a)

assert b * aU.t * alpha == b.dtrmm(false, true, true, false, alpha, a)


assert b * aU * alpha == b.dtrmm(false, true, false, false, alpha, a)

assert b * aUD.t * alpha == b.dtrmm(false, true, true, true, alpha, a)

assert b * aD.t * alpha == b.dtrmm(false, false, true, false, alpha, a)
assert b * aD * alpha == b.dtrmm(false, false, false, false, alpha, a)

assert b * aDD.t * alpha == b.dtrmm(false, false, true, true, alpha, a)


b_dup = b.clone;	b_dup.dtrmm!(true, true, true, false, alpha, a);	assert aU.t * b * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(true, true, false, false, alpha, a);	assert aU * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(true, true, true, true, alpha, a);		assert aUD.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(true, false, true, false, alpha, a);	assert aD.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(true, false, false, false, alpha, a);	assert aD * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(true, false, true, true, alpha, a);	assert aDD.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, true, true, false, alpha, a);	assert b * aU.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, true, false, false, alpha, a);	assert b * aU * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, true, true, true, alpha, a);	assert b * aUD.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, false, true, false, alpha, a);	assert b * aD.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, false, false, false, alpha, a);	assert b * aD * alpha == b_dup
b_dup = b.clone;  b_dup.dtrmm!(false, false, true, true, alpha, a);	assert b * aDD.t * alpha == b_dup
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="dtrsm"></a>
<tt>GSL::Blas#dtrsm</tt><br>
<tt>B.dtrsm(SideLeft, Uplo, TransA, DiagUnit, A) -> B'</tt><br>
This method computes the matrix-matrix product<br> 
B = \alpha op(inv(A)) B for SideLeft true and<br> 
B = \alpha B op(inv(A)) for SideLeft false. 
The matrix A is triangular and op(A) = A, A^T,for TransA = false, true
respectively.
 When Uplo is true then the upper triangle of A is used, and when Uplo is 
 false then the lower triangle of A is used. 
 If DiagUnit is false then the diagonal of A is used, but if Diag is true 
 then the diagonal elements of the matrix A are taken as unity and are 
 not referenced.
<p>
<a name="dtrsm!"></a>
<tt>GSL::Blas#dtrsm!</tt><br>
<tt>B.dtrsm!(SideLeft, Uplo, TransA, DiagUnit, A) -> B</tt><br>
Corresponding mutating method.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

a = Matrix.new([1,2,3], [2,1,1], [1,2,2])
b = Matrix.new([3,2,4],[4,5,6],[5,6,7])
aU = Matrix.new([1,2,3], [0,1,1], [0,0,2])
aUD = Matrix.new([1,2,3], [0,1,1], [0,0,1])
aD =  Matrix.new([1,0,0], [2,1,0], [1,2,2])
aDD = Matrix.new([1,0,0], [2,1,0], [1,2,1])
alpha = 2

assert aU.inv.t * b * alpha == b.dtrsm(true, true, true, false, alpha, a)
assert aU.inv * b  * alpha == b.dtrsm(true, true, false, false, alpha, a)

assert aUD.inv.t * b  * alpha == b.dtrsm(true, true, true, true, alpha, a)

assert aD.inv.t * b  * alpha == b.dtrsm(true, false, true, false, alpha, a)
assert aD.inv * b  * alpha == b.dtrsm(true, false, false, false, alpha, a)

assert aDD.inv.t * b  * alpha == b.dtrsm(true, false, true, true, alpha, a)

assert b * aU.inv.t * alpha == b.dtrsm(false, true, true, false, alpha, a)


assert b * aU.inv * alpha == b.dtrsm(false, true, false, false, alpha, a)

assert b * aUD.inv.t * alpha == b.dtrsm(false, true, true, true, alpha, a)

assert b * aD.inv.t * alpha == b.dtrsm(false, false, true, false, alpha, a)
assert b * aD.inv * alpha == b.dtrsm(false, false, false, false, alpha, a)

assert b * aDD.inv.t * alpha == b.dtrsm(false, false, true, true, alpha, a)


b_dup = b.clone;	b_dup.dtrsm!(true, true, true, false, alpha, a);	assert aU.inv.t * b * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(true, true, false, false, alpha, a);	assert aU.inv * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(true, true, true, true, alpha, a);		assert aUD.inv.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(true, false, true, false, alpha, a);	assert aD.inv.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(true, false, false, false, alpha, a);	assert aD.inv * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(true, false, true, true, alpha, a);	assert aDD.inv.t * b  * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, true, true, false, alpha, a);	assert b * aU.inv.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, true, false, false, alpha, a);	assert b * aU.inv * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, true, true, true, alpha, a);	assert b * aUD.inv.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, false, true, false, alpha, a);	assert b * aD.inv.t * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, false, false, false, alpha, a);	assert b * aD.inv * alpha == b_dup
b_dup = b.clone;  b_dup.dtrsm!(false, false, true, true, alpha, a);	assert b * aDD.inv.t * alpha == b_dup
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="dsyr2k"></a>
<tt>GSL::Blas#dsyr2k</tt><br>
<tt>C.dsyr2k(Uplo, Trans, alpha, A, B, beta) -> C'</tt><br>
This method computes<br>
C' = alpha A^T B + alpha B^T A + beta C when Trans = true and<br>
C' = alpha A B^T + alpha B A^T + beta C when Trans = false<br>
where C is a symmetric matrix.
 When Uplo is true (false) then the upper (lower) triangle of A is used.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
require 'gsl_linalg'

a = Matrix.new([7,8,9],[9,8,7],[6,7,8])
b = Matrix.new([4,2,1],[1,3,2],[5,4,3])

c = Matrix.new([1,2,3], 
               [2,1,1], 
	       [3,1,2])
 	       
c_U = Matrix.new([1,2,3], 
                 [0,1,1], 
          	 [0,0,2])

	       
c_L = Matrix.new([1,0,0], 
                 [2,1,0], 
	         [3,1,2])

alpha = 2
beta = 3 
c1 =  a * b.t * alpha + b * a.t * alpha + c * beta
c2 =  a.t * b * alpha + b.t * a * alpha + c * beta


assert c_U.dsyr2k(true, true, alpha, a, b, beta) =~ c2.upper(true)

assert c_L.dsyr2k(false, true, alpha, a, b, beta) == c2.lower(true)

assert c_U.dsyr2k(true, false, alpha, a, b, beta) == c1.upper(true)
assert c_L.dsyr2k(false, false, alpha, a, b, beta) == c1.lower(true)

c_UD = c_U.clone;	c_UD.dsyr2k!(true, true, alpha, a, b, beta);	assert c_UD =~ c2.upper(true)
c_LD = c_L.clone;	c_LD.dsyr2k!(false, true, alpha, a, b, beta);	assert c_LD == c2.lower(true)
c_UD = c_U.clone;	c_UD.dsyr2k!(true, false, alpha, a, b, beta);	assert c_UD == c1.upper(true)
c_LD = c_L.clone;	c_LD.dsyr2k!(false, false, alpha, a, b, beta);	assert c_LD == c1.lower(true)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="blas_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="blas.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="blas.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">BLAS Support for double type</td> 
</tr></tbody></table><hr>
</body>
</html>
