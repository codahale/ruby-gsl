<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Chebyshev Approximations</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="sum.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="diff.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Chebyshev Approximations</td> 
</tr></tbody></table><hr><h1>
Chebyshev Approximations</h1>
<hr>

This chapter describes routines for computing Chebyshev approximations to
univariate functions. A Chebyshev approximation is a truncation of the
series f(x) = \sum c_n T_n(x), where the Chebyshev polynomials T_n(x)
= \cos(n \arccos x) provide an orthogonal basis of polynomials on the
interval [-1,1] with the weight function 1 / \sqrt{1-x^2}. The first
few Chebyshev polynomials are,<br> 
T_0(x) = 1, T_1(x) = x, T_2(x) = 2 x^2 - 1.
<br>
The functions described in this chapter are declared in the header file
`gsl_chebyshev.h'.  

<h3>The gsl_cheb_series struct</h3>

A Chebyshev series is stored using the following structure,
<pre>
typedef struct { 
  double * c;   /* coefficients  c[0] .. c[order] */
  int order;    /* order of expansion             */ 
  double a;     /* lower interval point           */ 
  double b;     /* upper interval point*/ 
} gsl_cheb_struct
</pre>

The approximation is made over the range [a,b] using order+1 terms,
including the coefficient c[0].

<h3>Chebyshev class</h3>
The Chebyshev class is a wrapper for the gsl_cheb_struct .

<p>
<a name="new"></a>
<tt>Cheb::new(order, f, a, b) -> c1</tt><br>
c1 is a Cheb object describing a
Chebyshev series of order n for the function f over the range (a,b) 
<p>
<a name="initialize"></a>
<tt>Cheb::initialize(order, f, a, b) -> anInteger</tt><br>
It computes the Chebyshev approximation cs for the function f over the 
range (a,b) to the previously specified order. The computation of the 
Chebyshev approximation is an O(n^2) process, and requires n function 
evaluations.

<h3>Chebyshev Series Evaluation</h3>

<a name="eval"></a>
<tt>GSL::Chebyshev::eval</tt><br>
<tt>cs.eval(x) -> aDouble</tt><br>

This function evaluates the Chebyshev series cs at a given point x.

<p>
<a name="eval_err"></a>
<tt>GSL::Chebyshev::eval_err</tt><br>
<tt>cs.eval_err(x) -> res1</tt><br>
This method computes the
Chebyshev series cs at a given point x, estimating both the series result
and its absolute error abserr, contained in the object res1 of type Result.
The error estimate is made from the first neglected term in the series. 

<p>
<a name="eval_n"></a>
<tt>GSL::Chebyshev::eval_n</tt><br>
<tt>cs.eval_n(order, x) -> aDouble</tt><br>

This method evaluates the Chebyshev series cs at a
given point n, to (at most) the given order <tt>order</tt>.

<p>
<a name="eval_n_err"></a>
<tt>GSL::Chebyshev::eval_n_err</tt><br>
<tt>cs.eval_n_err(order, x) -> res1</tt><br>

This method evaluates a Chebyshev series cs at a given point x, estimating
both the series result and its absolute error abserr, to (at most) the
given order order; <tt>result = res1.val</tt> and 
<tt>abserr = res1.err</tt> .
The error estimate is made from the first neglected term in the series.

<p>
<a name="eval_mode_e"></a>
<tt>GSL::Chebyshev::eval_mode_e</tt><br>
<tt>cs.eval_mode_e(x, mode) -> res1</tt><br>
SKIPPED<br>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
f = Function.new { |x| (x &lt; 0.25) ? 0.25 : 0.75 }

cs = Chebyshev.new(40, f, 0.0, 1.0)

x = 0.1
puts "eval"
p cs.eval(x)

puts "eval_err"
r = cs.eval_err(x)
assert r.val == cs.eval(x)
p r.err

puts "eval_n"
p cs.eval_n(10, x)

puts "eval_n_err"
r = cs.eval_n_err(10, x)
assert r.val == cs.eval_n(10, x)
p r.err
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Derivatives and Integrals</h3>

The following functions allow a Chebyshev series to be differentiated or
integrated, producing a new Chebyshev series. Note that the error estimate
produced by evaluating the derivative series will be underestimated due
to the contribution of higher order terms being neglected.
<p>
<a name="calc_deriv"></a>
<tt>GSL::Chebyshev::calc_deriv</tt><br>
<tt>cs.calc_deriv(deriv) -> status</tt><br>

This method computes the derivative of the series
cs, storing the derivative coefficients in the previously allocated
deriv. The two series cs and deriv must have been allocated with the
same order.
<p>
<a name="calc_integ"></a>
<tt>GSL::Chebyshev::calc_integ</tt><br>
<tt>cs.calc_integ(integ) -> status</tt><br>

This method computes the integral of the series
cs, storing the integral coefficients in the previously allocated
integ. The two series cs and integ must have been allocated with the
same order. The lower limit of the integration is taken to be the left
hand end of the range a.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
f = Function.new { |x| x * x }

cs = Chebyshev.new(40, f, 0.0, 1.0)

x = 0.6
puts "calc_deriv"
d1 = Chebyshev.new(40, f, 0.0, 1.0)
cs.calc_deriv(d1)
assert d1.eval(x) =~ [2*x, 1.0e-13]

puts "calc_integ"
i1 = Chebyshev.new(40, f, 0.0, 1.0)
cs.calc_integ(i1)
assert i1.eval(x) =~ x*x*x/3
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Example</h3>
The following example program computes Chebyshev approximations to a step
function. This is an extremely difficult approximation to make, due to
the discontinuity, and was chosen as an example where approximation error
is visible. For smooth functions the Chebyshev approximation converges
extremely rapidly and errors would not be visible.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL
# Test Chebyshev approximations
# visualize output with graph(1) from GNU plotutils:
# ruby cheb.rb &gt; cheb.dat
# awk '{print $1,$2}' cheb.dat &gt; 1.dat
# awk '{print $1,$3}' cheb.dat &gt; 2.dat
# awk '{print $1,$4}' cheb.dat &gt; 3.dat
# graph -Tps 1.dat -m 2 2.dat -m 3 3.dat &gt; plot.ps

f = Function.new { |x| (x &lt; 0.25) ? 0.25 : 0.75 }

i = 0.0
n = 10000.0

cs = Chebyshev.new 40, f, 0.0, 1.0

while (i &lt; n)
  i += 1.0
  x = i / n
  r10 = cs.eval_n 10, x
  r40 = cs.eval x

  y = f[x]

  printf "%g %g %g %g\n", x, y, r10, r40
end
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>The output from the program gives the original function, 10-th order 
approximation and 40-th order approximation, all sampled at intervals 
of 0.001 in x.

<h3>References and Further Reading</h3>
The following paper describes the use of Chebyshev series,
<ul><li>
R. Broucke, "Ten Subroutines for the Manipulation of Chebyshev Series 
[C1] (Algorithm 446)". Communications of the ACM 16(4), 254-256 (1973)
</ul>

    

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="sum.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="diff.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Chebyshev Approximations</td> 
</tr></tbody></table><hr></body>
</html>
