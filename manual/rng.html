<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Random Number Generation</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="qrng.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="integration.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Random Number Generation</td> 
</tr></tbody></table><hr><h1>
Random Number Generation</h1>
<hr>
The library provides a large collection of random number generators
which can be accessed through a uniform interface. Environment variables
allow you to select different generators and seeds at runtime, so that
you can easily switch between generators without needing to recompile
your program. Each instance of a generator keeps track of its own state,
allowing the generators to be used in multi-threaded programs. Additional
functions are available for transforming uniform random numbers into
samples from continuous or discrete probability distributions such as
the Gaussian, log-normal or Poisson distributions.

These functions are declared in the header file `gsl_rng.h'.  
<h2> General comments on random numbers</h2>

In 1988, Park and Miller wrote a paper entitled "Random number generators:
good ones are hard to find." [Commun. ACM, 31, 1192--1201]. Fortunately,
some excellent random number generators are available, though poor ones
are still in common use. You may be happy with the system-supplied
random number generator on your computer, but you should be aware
that as computers get faster, requirements on random number generators
increase. Nowadays, a simulation that calls a random number generator
millions of times can often finish before you can make it down the hall
to the coffee machine and back.
<p>
A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997). The chapter is available in postscript from L'Ecuyer's
ftp site (see references). Knuth's volume on Seminumerical Algorithms
(originally published in 1968) devotes 170 pages to random number
generators, and has recently been updated in its 3rd edition (1997). It
is brilliant, a classic. If you don't own it, you should stop reading
right now, run to the nearest bookstore, and buy it.
<p>
A good random number generator will satisfy both theoretical and
statistical properties. Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency not to
"fall mainly on the planes." Statistical tests are performed with
numerical simulations. Generally, a random number generator is used
to estimate some quantity for which the theory of probability provides
an exact answer. Comparison to this exact answer provides a measure of
"randomness". 

<h3> The Random Number Generator Interface</h3>
It is important to remember that a random number generator is not a
"real" function like sine or cosine. Unlike real functions, successive
calls to a random number generator yield different return values. Of
course that is just what you want for a random number generator, but
to achieve this effect, the generator must keep track of some kind of
"state" variable. Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in. To use the random number generators,
you do not need to know the details of what comprises the state, and
besides that varies from algorithm to algorithm.
<p>
The random number generator library uses two special structs,
gsl_rng_type which holds static information about each type of generator
and gsl_rng which describes an instance of a generator created from a
given gsl_rng_type.
<pre>
typedef struct
{
const char *name;
unsigned long int max;
unsigned long int min;
size_t size;
void (*set) (void *state, unsigned long int seed);
unsigned long int (*get) (void *state);
double (*get_double) (void *state);
}
gsl_rng_type;

typedef struct
{
const gsl_rng_type * type;
void *state;
}
gsl_rng;
</pre>


The functions described in this section are declared in the header file
`gsl_rng.h'.  

<h2>Class RNG</h2>
It is a wrapper of the struct gsl_rng; It is defined under the module
GSL::Random .

<h3>Class methods</h3>

<h4>Random number generator initialization</h4>

<a name="new"></a>
<tt>GSL::Random::RNG::new</tt><br>
<tt>RNG.new</tt><br>
<p>

<a name="new2"></a>
<tt>GSL::Random::RNG::new2</tt><br>
<tt>RNG.new2(type1) -> rng1</tt><br>
type1 is the class constant for the random number generator.<br>
For instance, in this example <tt>type1</tt> is <tt>RNG::CMRG</tt>, for the
Combined Multiple Recursive Generator by L'Ecuyer. <br>
See below for a list of the generators.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL::Random

r = RNG.new2(RNG::CMRG)
assert r.name == "cmrg" &amp;&amp; r.min == 0 &amp;&amp; r.max == 2147483646 &amp;&amp; r.size == 24
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Instance methods</h3>
<p>
<a name="set"></a>
<tt>GSL::Random::RNG#set</tt><br>
<tt>r.set(seed) -> r</tt><br>
GSL::Random::RNG r; integer seed<br>
This method initializes (or `seeds') the random number generator. If the
generator is seeded with the same value of s on two different runs,
the same stream of random numbers will be generated by successive calls
to the routines below. If different values of s are supplied, then the
generated streams of random numbers should be completely different. If the
seed s is zero then the standard seed from the original implementation
is used instead. For example, the original Fortran source code for the
ranlux generator used a seed of 314159265, and so choosing s equal to
zero reproduces this when using gsl_rng_ranlux.

<h4>Sampling from a random number generator</h4>

The following functions return uniformly distributed random numbers,
either as integers or double precision floating point numbers. To obtain
non-uniform distributions see section Random Number Distributions.
<p>
<a name="get"></a>
<tt>GSL::Random::RNG#get</tt><br>
<tt>r.get -> n</tt><br>
This method
returns a random integer n from the generator r. The minimum and maximum
values depend on the algorithm used, but all integers in the range
[min,max] are equally likely. The values of min and max can determined
using the auxiliary functions GSL::Random::RNG#max and GSL::Random::RNG#min.
<p>
<a name="uniform"></a>
<tt>GSL::Random::RNG#uniform</tt><br>
<tt>r.uniform -> adouble</tt><br>
This method returns a
double precision floating point number uniformly distributed in the range
[0,1). The range includes 0.0 but excludes 1.0. The value is typically
obtained by dividing the result of r.get by r.max + 1.0 
in double precision. Some generators compute this ratio internally so
that they can provide floating point numbers with more than 32 bits of
randomness (the maximum number of bits that can be portably represented
in a single unsigned long int).
<p>
<a name="uniform_pos"></a>
<tt>GSL::Random::RNG#uniform_pos</tt><br>
<tt>r.uniform_pos -> adouble</tt><br>
This method
returns a positive double precision floating point number uniformly
distributed in the range (0,1), excluding both 0.0 and 1.0. The number is
obtained by sampling the generator with the algorithm of gsl_rng_uniform
until a non-zero value is obtained. You can use this function if you
need to avoid a singularity at 0.0.
<p>
<a name="uniform_int"></a>
<tt>GSL::Random::RNG#uniform_int</tt><br>
<tt>r.uniform_inti(n) -> anInteger</tt><br>
This method returns a random integer from 0 to n-1 inclusive. All
integers in the range [0,n-1] are equally likely, regardless of
the generator used. An offset correction is applied so that zero is
always returned with the correct probability, for any minimum value
of the underlying generator.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL::Random

r = RNG.new2(RNG::RANLUX)
max = r.max + 1
rn0, rn1 = r.get, r.get

r.set(0)
assert r.get == rn0
a1 = r.uniform
assert a1 == rn1.to_f/max
assert r.uniform_pos == 1011656.to_f/max
assert r.uniform_int(10) == 7
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
If n is larger than the range of the generator then the function
calls the error handler with an error code of GSL_EINVAL and
returns zero.

<h3>Auxiliary random number generator functions</h3>

The following functions provide information about an existing
generator. You should use them in preference to hard-coding the generator
parameters into your own code.
<p>
<a name="name"></a>
<tt>GSL::Random::RNG#name</tt><br>
<tt>r.name -> s</tt><br>
String s<br>
This method returns the name of the generator.<br>
<p>
<a name="max"></a>
<tt>GSL::Random::RNG#max</tt><br>
<tt>r.max -> anInteger</tt><br>
This method returns the largest value that GSL::Random::RNG#get can return.
<p>
<a name="min"></a>
<tt>GSL::Random::RNG#min</tt><br>
<tt>r.min -> anInteger</tt><br>
This method returns the smallest value that GSL::Random::RNG#get can return.
Usually this
value is zero. There are some generators with algorithms that cannot
return zero, and for these generators the minimum value is 1.
<p>
<a name="size"></a>
<tt>GSL::Random::RNG#size</tt><br>
<tt>r.size</tt> -> anInteger<br>
This method returns the size of the generator.
<p>
<a name="state"></a>
<tt>GSL::Random::RNG#state</tt><br>
MISSING<br>
Random: void * gsl_rng_state (const gsl_rng * r) <br>
This function returns a pointer to
the state of generator r. You can use this information to
access the state directly. 
<p>
<a name="type"></a>
<tt>GSL::Random::RNG#type</tt><br>
MISSING<br>
Random: const gsl_rng_type ** gsl_rng_types_setup (void) <br>
This function
returns a pointer to an array of all the available generator types,
terminated by a null pointer. The function should be called once at the
start of the program, if needed. 

<h3>Saving and restoring random number generator state</h3>

The above methods ignore the random number `state' which changes from
call to call. It is often useful to be able to save and restore the
state. To permit these practices, a few somewhat more advanced functions
are supplied. These include:
<p>
<a name="memcpy"></a>
<tt>GSL::Random::RNG#memcpy</tt><br>
<tt>src.memcpy -> dest</tt><br>
GSL::Random::RNG src, dest<br>
This method copies the random number generator src into the pre-existing
generator dest, making dest into an exact copy of src. The two generators
must be of the same type.
<p>
<a name="clone"></a>
<tt>GSL::Random::RNG#clone</tt><br>
<tt>r1.clone -> r2</tt><br>
GSL::Random::RNG r1, r2<br>
This method returns an exact copy of the generator r.
<p>
<a name="print_state"></a>
<tt>GSL::Random::RNG#print_state</tt><br>
<tt>r.print_state</tt><br>
This method prints
a hex-dump of the state of the generator r to stdout. At the moment its
only use is for debugging.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL::Random

r1 = RNG.new2(RNG::RANLUX)
r2 = RNG.new2(RNG::RANLUX)
assert r1.get == 9056646
r3 = r1.clone
assert r1.get == r3.get
RNG::memcpy(r2,r1)
assert r1.get == r2.get
r1.print_state
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h2>Random number generator algorithms</h2>

The functions described above make no reference to the actual algorithm
used. This is deliberate so that you can switch algorithms without having
to change any of your application source code. The library provides
a large number of generators of different types, including simulation
quality generators, generators provided for compatibility with other
libraries and historical generators from the past.
<p>
The following generators are recommended for use in simulation. They have
extremely long periods, low correlation and pass most statistical tests.
<p>
<a name="MT19937"></a>
<tt>RNG::MT19937</tt><br>

The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a
variant of the twisted generalized feedback shift-register algorithm,
and is known as the "Mersenne Twister" generator. It has a Mersenne
prime period of 2^19937 - 1 (about 10^6000) and is equi-distributed
in 623 dimensions. It has passed the DIEHARD statistical tests. It
uses 624 words of state per generator and is comparable in speed to
the other generators. The original generator used a default seed of
4357 and choosing s equal to zero in gsl_rng_set reproduces this.
For more information see,

* Makoto Matsumoto and Takuji Nishimura, "Mersenne
Twister: A 623-dimensionally equidistributed uniform
pseudorandom number generator". ACM Transactions
on Modeling and Computer Simulation, Vol. 8, No. 1
(Jan. 1998), Pages 3-30
<p>
<a name="MT19937_1998"></a>
<tt>RNG::MT19937_1998</tt><br>
<a name="MT19937_1999"></a>
<tt>RNG::MT19937_1999</tt><br>

The generator gsl_rng_19937 uses the second revision of the seeding
procedure published by the two authors above in 2002. The original seeding
procedures could cause spurious artifacts for some seed values. They are
still available through the alternate generators gsl_rng_mt19937_1999
and gsl_rng_mt19937_1998.
<p>
<a name="RANLXS0"></a>
<tt>RNG::RANLXS0</tt><br>
<a name="RANLXS1"></a>
<tt>RNG::RANLXS1</tt><br>
<a name="RANLXS2"></a>
<tt>RNG::RANLXS2</tt><br>

The generator ranlxs0 is a second-generation version of the RANLUX
algorithm of Luscher, which produces "luxury random numbers". This
generator provides single precision output (24 bits) at three luxury
levels ranlxs0, ranlxs1 and ranlxs2. It uses double-precision floating
point arithmetic internally and can be significantly faster than the
integer version of ranlux, particularly on 64-bit architectures. The
period of the generator is about 10^171. The algorithm has mathematically
proven properties and can provide truly decorrelated numbers at a
known level of randomness. The higher luxury levels provide additional
decorrelation between samples as an additional safety margin.
<p>
<a name="RANLXD1"></a>
<tt>RNG::RANLXD1</tt><br>
<a name="RANLXD2"></a>
<tt>RNG::RANLXD2</tt><br>

These generators produce double precision output (48 bits) from the RANLXS
generator. The library provides two luxury levels ranlxd1 and ranlxd2.
<p>
<a name="RANLUX"></a>
<tt>RNG::RANLUX</tt><br>
<a name="RANLUX389"></a>
<tt>RNG::RANLUX389</tt><br>

The ranlux generator is an implementation of the original algorithm
developed by Luscher. It uses a lagged-fibonacci-with-skipping
algorithm to produce "luxury random numbers". It is a 24-bit generator,
originally designed for single-precision IEEE floating point numbers. This
implementation is based on integer arithmetic, while the second-generation
versions RANLXS and RANLXD described above provide floating-point
implementations which will be faster on many platforms. The period of
the generator is about 10^171. The algorithm has mathematically proven
properties and it can provide truly decorrelated numbers at a known
level of randomness. The default level of decorrelation recommended by
L@"uscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives
the highest level of randomness, with all 24 bits decorrelated. Both
types of generator use 24 words of state per generator.
<p>
For more information see,
<ul>
<li>
M. Luscher, "A portable high-quality random number generator for
lattice field theory calculations", Computer Physics Communications,
79 (1994) 100-110.  
<li>
F. James, "RANLUX: A Fortran implementation of
the high-quality pseudo-random number generator of Luscher", Computer
Physics Communications, 79 (1994) 111-114
</ul>

<p>
<a name="CMRG"></a>
<tt>RNG::CMRG</tt><br>

This is a combined multiple recursive generator by L'Ecuyer. Its sequence is,
<r>
z_n = (x_n - y_n) mod m_1
<br>
where the two underlying generators x_n and y_n are,
<br>
x_n = (a_1 x_{n-1} + a_2 x_{n-2} + a_3 x_{n-3}) mod m_1 y_n = (b_1 y_{n-1}
+ b_2 y_{n-2} + b_3 y_{n-3}) mod m_2
<br>
with coefficients a_1 = 0, a_2 = 63308, a_3 = -183326, b_1 = 86098,
b_2 = 0, b_3 = -539608, 
<br>
and moduli m_1 = 2^31 - 1 = 2147483647 and m_2 = 2145483479.
<br>
The period of this generator is 2^205 (about 10^61). It uses 6 words of
state per generator. For more information see,
<ul>
<li>
P. L'Ecuyer, "Combined Multiple Recursive Random Number Generators,"
Operations Research, 44, 5 (1996), 816--822.
</ul>

<p>
<a name="MRG"></a>
<tt>RNG::MRG</tt><br>

This is a fifth-order multiple recursive generator
by L'Ecuyer, Blouin and Coutre. Its sequence is,
<br>
x_n = (a_1 x_{n-1} + a_5 x_{n-5}) mod m
<br>
with a_1 = 107374182, a_2 = a_3 = a_4 = 0, a_5 = 104480 and m = 2^31 - 1.
<br>
The period of this generator is about 10^46. It uses 5 words of state
per generator. More information can be found in the following paper,
<ul>
<li>
P. L'Ecuyer, F. Blouin, and R. Coutre, "A search for good multiple
recursive random number generators", ACM Transactions on Modeling and
Computer Simulation 3, 87-98 (1993).
</ul>

<p>
<a name="TAUS"></a>
<tt>RNG::TAUS</tt><br>

This is a maximally
equidistributed combined Tausworthe generator by L'Ecuyer. The sequence is,
<br>

x_n = (s1_n ^^ s2_n ^^ s3_n)

where,
<br>
s1_{n+1} = (((s1_n&4294967294)<<12)^^(((s1_n<<13)^^s1_n)>>19)) s2_{n+1}
= (((s2_n&4294967288)<< 4)^^(((s2_n<< 2)^^s2_n)>>25)) s3_{n+1} =
(((s3_n&4294967280)<<17)^^(((s3_n<< 3)^^s3_n)>>11))
<br>
computed modulo 2^32. In the formulas above ^^ denotes
"exclusive-or". Note that the algorithm relies on the properties of
32-bit unsigned integers and has been implemented using a bitmask of
0xFFFFFFFF to make it work on 64 bit machines.
<br>
The period of this generator is 2^88 (about 10^26). It uses 3 words of
state per generator. 


For more information see,
<ul>
<li> P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe Generators",
Mathematics of Computation, 65, 213 (1996), 203--213.
</ul>
<p>
<a name="TAUS2"></a>
<tt>RNG::TAUS2</tt><br>

The generator gsl_rng_taus2 uses the same algorithm as gsl_rng_taus but
with an improved seeding procedure described in the paper,
<ul><li>
* P. L'Ecuyer, "Tables of Maximally Equidistributed Combined LFSR
Generators", Mathematics of Computation, 68, 225 (1999), 261--269
</ul>
The generator gsl_rng_taus2 should now be used in preference to
gsl_rng_taus.

<p>
<a name="TAUS113"></a>
<tt>RNG::TAUS113</tt><br>

<p>
<a name="GFSR4"></a>
<tt>RNG::GFSR4</tt><br>

The gfsr4 generator is like a lagged-fibonacci
generator, and produces each number as an xor'd sum of four previous
values.
<br>

r_n = r_{n-A} ^^ r_{n-B} ^^ r_{n-C} ^^ r_{n-D}
<br>
Ziff (ref below) notes that "it is now widely known" that two-tap
registers (such as R250, which is described below) have serious flaws,
the most obvious one being the three-point correlation that comes from
the definition of the generator. Nice mathematical properties can be
derived for GFSR's, and numerics bears out the claim that 4-tap GFSR's
with appropriately chosen offsets are as random as can be measured,
using the author's test.
<br>
This implementation uses the values suggested the example on p392 of
Ziff's article: A=471, B=1586, C=6988, D=9689.
If the offsets are appropriately chosen (such the one ones in this
implementation), then the sequence is said to be maximal. I'm not sure
what that means, but I would guess that means all states are part of
the same cycle, which would mean that the period for this generator is
astronomical; it is (2^K)^D \approx 10^{93334} where K=32 is the number
of bits in the word, and D is the longest lag. This would also mean that
any one random number could easily be zero; ie 0 <= r < 2^32.
<br>
Ziff doesn't say so, but it seems to me that the bits are completely
independent here, so one could use this as an efficient bit generator;
each number supplying 32 random bits. The quality of the generated bits
depends on the underlying seeding procedure, which may need to be improved
in some circumstances.
<br>
For more information see,
<ul><li>
Robert M. Ziff, "Four-tap shift-register-sequence random-number
generators", Computers in Physics, 12(4), Jul/Aug 1998, pp 385-392.
</ul>

<h3>Unix random number generators</h3>

The standard Unix random number generators rand, random and rand48 are
provided as part of GSL. Although these generators are widely available
individually often they aren't all available on the same platform. This
makes it difficult to write portable code using them and so we have
included the complete set of Unix generators in GSL for convenience. Note
that these generators don't produce high-quality randomness and aren't
suitable for work requiring accurate statistics. However, if you won't
be measuring statistical quantities and just want to introduce some
variation into your program then these generators are quite acceptable.
<p>
<a name="RAND"></a>
<tt>RNG::RAND</tt><br>
This is the BSD rand() generator. Its sequence is
<br>
x_{n+1} = (a x_n + c) mod m
<br>
with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the
initial value, x_1. The period of this generator is 2^31, and it uses
1 word of storage per generator.
<p>
<a name="RANDOM_BSD"></a>
<tt>RNG::RANDOM_BSD</tt><br>
<a name="RANDOM8_LIBC5"></a>
<tt>RNG::RANDOM8_LIBC5</tt><br>
<a name="RANDOM_GLIBC2"></a>
<tt>RNG::RANDOM_GLIBC2</tt><br>

These generators implement the random() family of
functions, a set of linear feedback shift register generators originally
used in BSD Unix. There are several versions of random() in use today:
the original BSD version (e.g. on SunOS4), a libc5 version (found on
older GNU/Linux systems) and a glibc2 version. Each version uses a
different seeding procedure, and thus produces different sequences.
<br>
The original BSD routines accepted a variable length buffer for
the generator state, with longer buffers providing higher-quality
randomness. The random() function implemented algorithms for buffer
lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with the
largest length that would fit into the user-supplied buffer was used. To
support these algorithms additional generators are available with the
following names,
<p>
<a name="RANDOM8_BSD"></a>
<tt>RNG::RANDOM8_BSD</tt><br>
<a name="RANDOM32_BSD"></a>
<tt>RNG::RANDOM32_BSD</tt><br>
<a name="RANDOM64_BSD"></a>
<tt>RNG::RANDOM64_BSD</tt><br>
<a name="RANDOM128_BSD"></a>
<tt>RNG::RANDOM128_BSD</tt><br>
<a name="RANDOM256_BSD"></a>
<tt>RNG::RANDOM256_BSD</tt><br>
where the numeric suffix indicates the buffer length. The original BSD
random function used a 128-byte default buffer and so gsl_rng_random_bsd
has been made equivalent to gsl_rng_random128_bsd. Corresponding versions
of the libc5 and glibc2 generators are also available, with the names
gsl_rng_random8_libc5, gsl_rng_random8_glibc2, etc.
<p>
<a name="RAND48"></a>
<tt>RNG::RAND48</tt><br>

Generator: gsl_rng_rand48 This is the Unix rand48 generator. Its
sequence is
<br>
x_{n+1} = (a x_n + c) mod m
<br>
defined on 48-bit unsigned integers with a = 25214903917, c = 11 and m
= 2^48. The seed specifies the upper 32 bits of the initial value, x_1,
with the lower 16 bits set to 0x330E. The function gsl_rng_get returns the
upper 32 bits from each term of the sequence. This does not have a direct
parallel in the original rand48 functions, but forcing the result to type
long int reproduces the output of mrand48. The function gsl_rng_uniform
uses the full 48 bits of internal state to return the double precision
number x_n/m, which is equivalent to the function drand48. Note that
some versions of the GNU C Library contained a bug in mrand48 function
which caused it to produce different results (only the lower 16-bits of
the return value were set).

<h3>Numerical Recipes generators</h3>

The following generators are provided for compatibility with Numerical
Recipes. Note that the original Numerical Recipes functions used
single precision while we use double precision. This will lead
to minor discrepancies, but only at the level of single-precision
rounding error. If necessary you can force the returned values to single
precision by storing them in a volatile float, which prevents the value
being held in a register with double or extended precision. Apart from
this difference the underlying algorithms for the integer part of the
generators are the same.
<p>
<a name="RAN0"></a>
<tt>RNG::RAN0</tt><br>

Numerical recipes ran0 implements Park and
Miller's MINSTD algorithm with a modified seeding procedure.
<p>
<a name="RAN1"></a>
<tt>RNG::RAN1</tt><br>

Numerical recipes ran1 implements Park and
Miller's MINSTD algorithm with a 32-element Bayes-Durham shuffle box.
<p>
<a name="RAN2"></a>
<tt>RNG::RAN2</tt><br>

Numerical recipes ran2 implements a L'Ecuyer
combined recursive generator with a 32-element Bayes-Durham shuffle-box.
<p>
<a name="RAN3"></a>
<tt>RNG::RAN3</tt><br>
Generator: gsl_rng_ran3 Numerical recipes ran3 implements Knuth's portable
subtractive generator.

<h3>Other random number generators</h3>

The generators in this section are provided for compatibility with
existing libraries. If you are converting an existing program to use GSL
then you can select these generators to check your new implementation
against the original one, using the same random number generator. After
verifying that your new program reproduces the original results you can
then switch to a higher-quality generator.
<p>
Note that most of the generators in this section are based on single
linear congruence relations, which are the least sophisticated type of
generator. In particular, linear congruences have poor properties when
used with a non-prime modulus, as several of these routines do (e.g. with
a power of two modulus, 2^31 or 2^32). This leads to periodicity in the
least significant bits of each number, with only the higher bits having
any randomness. Thus if you want to produce a random bitstream it is
best to avoid using the least significant bits.
<p>
<a name="RANF"></a>
<tt>RNG::RANF</tt><br>

This is the CRAY random number generator RANF. Its sequence is
<br>
x_{n+1} = (a x_n) mod m
defined on 48-bit unsigned integers with a = 44485709377909 and m =
2^48. The seed specifies the lower 32 bits of the initial value, x_1,
with the lowest bit set to prevent the seed taking an even value. The
upper 16 bits of x_1 are set to 0. A consequence of this procedure is
that the pairs of seeds 2 and 3, 4 and 5, etc produce the same sequences.
<br>
The generator compatibile with the CRAY MATHLIB routine RANF. It produces
double precision floating point numbers which should be identical to
those from the original RANF.
<br>
There is a subtlety in the implementation of the seeding. The initial
state is reversed through one step, by multiplying by the modular
inverse of a mod m. This is done for compatibility with the original
CRAY implementation.
<br>
Note that you can only seed the generator with integers up to 2^32,
while the original CRAY implementation uses non-portable wide integers
which can cover all 2^48 states of the generator.
<br>
The function gsl_rng_get returns the upper 32 bits from each term of the
sequence. The function gsl_rng_uniform uses the full 48 bits to return
the double precision number x_n/m.
The period of this generator is 2^46.
<p>
<a name="RANMAR"></a>
<tt>RNG::RANMAR</tt><br>

This is the RANMAR lagged-fibonacci generator of
Marsaglia, Zaman and Tsang. It is a 24-bit generator, originally designed
for single-precision IEEE floating point numbers. It was included in
the CERNLIB high-energy physics library.
<p>
<a name="R250"></a>
<tt>RNG::R250</tt><br>

This is the shift-register generator of Kirkpatrick and Stoll. The sequence is
<br>
x_n = x_{n-103} ^^ x_{n-250}
<br>
where ^^ denote "exclusive-or", defined on 32-bit words. The period
of this generator is about 2^250 and it uses 250 words of state per
generator.
<br>
For more information see,
<ul><li>
S. Kirkpatrick and E. Stoll, "A very fast shift-register sequence random
number generator", Journal of Computational Physics, 40, 517-526 (1981)
</ul>
<p>
<a name="TT800"></a>
<tt>RNG::TT800</tt><br>

This is an earlier version of the twisted
generalized feedback shift-register generator, and has been superseded by
the development of MT19937. However, it is still an acceptable generator
in its own right. It has a period of 2^800 and uses 33 words of storage
per generator.
<br>
For more information see,
<ul><li>
Makoto Matsumoto and Yoshiharu Kurita, "Twisted GFSR Generators II",
ACM Transactions on Modelling and Computer Simulation, Vol. 4, No. 3,
1994, pages 254-266.
</ul>
<p>
<a name="VAX"></a>
<tt>RNG::VAX</tt><br>

This is the VAX generator MTH$RANDOM. Its sequence is,
<br>
x_{n+1} = (a x_n + c) mod m
<br>
with a = 69069, c = 1 and m = 2^32. The seed specifies the initial value,
x_1. The period of this generator is 2^32 and it uses 1 word of storage
per generator.
<p>
<a name="TRANSPUTER"></a>
<tt>RNG::TRANSPUTER</tt><br>

This is the random number generator from
the INMOS Transputer Development system. Its sequence is,<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 1664525 and m = 2^32. The seed specifies the initial value, x_1.
<p>
<a name="RANDU"></a>
<tt>RNG::RANDU</tt><br>

This is the IBM RANDU generator. Its sequence is
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 65539 and m = 2^31. The seed specifies the initial value,
x_1. The period of this generator was only 2^29. It has become a textbook
example of a poor generator.
<p>
<a name="MINSTD"></a>
<tt>RNG::MINSTD</tt><br>

This is Park and Miller's "minimal standard"
MINSTD generator, a simple linear congruence which takes care to avoid
the major pitfalls of such algorithms. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 16807 and m = 2^31 - 1 = 2147483647. The seed specifies the
initial value, x_1. The period of this generator is about 2^31.
This generator is used in the IMSL Library (subroutine RNUN) and in MATLAB
(the RAND function). It is also sometimes known by the acronym "GGL"
(I'm not sure what that stands for).
<br>
For more information see,
<ul><li>
Park and Miller, "Random Number Generators: Good ones are hard to
find", Communications of the ACM, October 1988, Volume 31, No 10,
pages 1192-1201.
</ul>
<p>
<a name="UNI"></a>
<tt>RNG::UNI</tt><br>
<a name="UNI32"></a>
<tt>RNG::UNI32</tt><br>

This is a reimplementation
of the 16-bit SLATEC random number generator RUNIF. A generalization
of the generator to 32 bits is provided by gsl_rng_uni32. The original
source code is available from NETLIB.
<p>
<a name="SLATEC"></a>
<tt>RNG::SLATEC</tt><br>

This is the SLATEC random number generator
RAND. It is ancient. The original source code is available from NETLIB.
<p>
<a name="ZUF"></a>
<tt>RNG::ZUF</tt><br>

This is the ZUFALL lagged Fibonacci series generator of Peterson. 
Its sequence is,<br>
t = u_{n-273} + u_{n-607} u_n  = t - floor(t)
<br>
The original source code is available from NETLIB. For more information
see,
<ul><li>
W. Petersen, "Lagged Fibonacci Random Number Generators for the NEC
SX-3", International Journal of High Speed Computing (1994).
</ul>
<a name="BOROSH13"></a>
<tt>RNG::BOROSH13</tt><br>

This is the Borosh, Niederreiter random
number generator. It is taken from Knuth's Seminumerical Algorithms,
3rd Ed., pages 106-108. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 1812433253 and m = 2^32. The seed specifies the initial value,
x_1.  
<p>
<a name="COVEYOU"></a>
<tt>RNG::COVEYOU</tt><br>

This is the Coveyou random number
generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed.,
Section 3.2.2. Its sequence is,
<br>
x_{n+1} = (x_n (x_n + 1)) mod m
<br>
with m = 2^32. The seed specifies the initial value, x_1.
<p>
<a name="FISHMAN18"></a>
<tt>RNG::FISHMAN18</tt><br>

This is the Fishman, Moore III random number
generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed.,
pages 106-108. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 62089911 and m = 2^31 - 1. The seed specifies the initial
value, x_1.
<p>
<a name="FISHMAN20"></a>
<tt>RNG::FISHMAN20</tt><br>

This is the Fishman random number
generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed.,
page 108. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 48271 and m = 2^31 - 1. The seed specifies the initial value,
x_1.  
<p>
<a name="FISHMAN2X"></a>
<tt>RNG::FISHMAN2X</tt><br>

This is the L'Ecuyer - Fishman random
number generator. It is taken from Knuth's Seminumerical Algorithms,
3rd Ed., page 108. Its sequence is,
<br>
z_{n+1} = (x_n - y_n) mod m
<br>
with m = 2^31 - 1. x_n and y_n are given by the fishman20 and lecuyer21
algorithms. The seed specifies the initial value, x_1.
<p>
<a name="KNUTHRAN2"></a>
<tt>RNG::KNUTHRAN2</tt><br>

This is a second-order multiple recursive
generator described by Knuth in Seminumerical Algorithms, 3rd Ed.,
page 108. Its sequence is,
<br>
x_n = (a_1 x_{n-1} + a_2 x_{n-2}) mod m
<br>
with a_1 = 271828183, a_2 = 314159269, and m = 2^31 - 1.
<p>
<a name="KNUTHRAN"></a>
<tt>RNG::KNUTHRAN</tt><br>

This is a second-order multiple recursive
generator described by Knuth in Seminumerical Algorithms, 3rd Ed.,
Section 3.6. Knuth provides its C code.
<p>
<a name="LECUYER21"></a>
<tt>RNG::LECUYER21</tt><br>

This is the L'Ecuyer random number
generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed.,
page 106-108. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
with a = 40692 and m = 2^31 - 249. The seed specifies the initial value,
x_1.  
<p>
<a name="WATERMAN14"></a>
<tt>RNG::WATERMAN14</tt><br>

This is the Waterman random number
generator. It is taken from Knuth's Seminumerical Algorithms, 3rd Ed.,
page 106-108. Its sequence is,
<br>
x_{n+1} = (a x_n) mod m
<br>
with a = 1566083941 and m = 2^32. The seed specifies the initial value,
x_1.


<h3>References and Further Reading</h3>

The subject of random number generation and testing is reviewed
extensively in Knuth's Seminumerical Algorithms.
<ul><li>
Donald E. Knuth, The Art of Computer Programming: Seminumerical
Algorithms (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
<li>
Further information is available in the review paper written by
Pierre L'Ecuyer,
<br>
P. L'Ecuyer, "Random Number Generation", Chapter 4 of
the Handbook on Simulation, Jerry Banks Ed., Wiley, 1998,
93--137. http://www.iro.umontreal.ca/~lecuyer/papers.html in the file
`handsim.ps'.
<li>
On the World Wide Web, see the pLab home page
(http://random.mat.sbg.ac.at/) for a lot of information on the
state-of-the-art in random number generation, and for numerous links
to various "random" WWW sites.
<li>
The source code for the DIEHARD random number generator tests is
also available online.
<br> DIEHARD source code G. Marsaglia,
<br>http://stat.fsu.edu/pub/diehard/
</ul>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="qrng.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="integration.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Random Number Generation</td> 
</tr></tbody></table><hr></body>
</html>
