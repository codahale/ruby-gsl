<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Hypergeometric Functions</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="laguerre.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../special.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="gegenbauer.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Hypergeometric Functions</td> 
</tr></tbody></table><hr>
<h1>
Hypergeometric Functions</h1>
Hypergeometric functions are described in Abramowitz & Stegun, 
Chapters 13 and 15.

<h2>Module Hyperg</h2>
<a href="#F01">F01</a> ,&nbsp
<a href="#F11">F11</a> ,&nbsp
<a href="#F11_int">F11_int</a> ,&nbsp
<a href="#F20">F20</a> ,&nbsp
<a href="#F21">F21</a> ,&nbsp
<a href="#F21_conj">F21_conj</a> ,&nbsp
<a href="#F21_conj_renorm">F21_conj_renorm</a> ,&nbsp
<a href="#F21_renorm">F21_renorm</a> ,&nbsp
<a href="#U">U</a> ,&nbsp
<a href="#U_int">U_int</a> ,&nbsp
<p>
<a name="F01"></a>
<tt>GSL::Special::Hyperg::F01</tt><br>
<tt>GSL::Special::Hyperg::F01_e</tt><br>
<tt>Hyperg::F01(c, x) -> d1</tt><br>
c and x are doubles.
These routines compute the hypergeometric function 0F1(c,x).
<p>
<a name="F11_int"></a>
<tt>GSL::Special::Hyperg::F11_int</tt><br>
<tt>GSL::Special::Hyperg::F11_int</tt><br>
<tt>Hyperg::F11_int(m, n, x) -> d1</tt><br>
m and n integers; x double.
These routines compute the confluent hypergeometric function 
1F1(m,n,x) = M(m,n,x) for integer parameters m, n.
<p>
<a name="F11"></a>
<tt>GSL::Special::Hyperg::F11</tt><br>
<tt>GSL::Special::Hyperg::F11_e</tt><br>
<tt>Hyperg::F11(a, b, x)</tt><br>
These routines compute the confluent hypergeometric function 
1F1(a,b,x) = M(a,b,x) for general parameters a, b.<br>
(see Hypergeometric0F1 in http://functions.wolfram.com/HypergeometricFunctions)
0F1(b,z) = exp(-2 sqrt(z)) 1F1(b - 1/2, 2 b - 1, 4 sqrt(z))
<p>
<a name="U_int"></a>
<tt>GSL::Special::Hyperg::U_int</tt><br>
<tt>Hyperg::U_int(m, n, x) -> d1</tt><br>
These routines compute the confluent hypergeometric function U(m,n,x)
for integer parameters m, n.
<p>
<tt>GSL::Special::Hyperg::U_int_e10_e</tt><br>
<tt>Hyperg::U_int_e10_e(m, n, x) -> res</tt><br>
MISSING
This routine computes the confluent hypergeometric function U(m,n,x) for 
integer parameters m, n returning res of Result10 type to return a result with 
extended range.
<p>
<a name="F21"></a>
<tt>GSL::Special::Hyperg::F21</tt><br>
<tt>GSL::Special::Hyperg::F21_e</tt><br>
<tt>Hyperg::F21(a, b, c, x) -> d1</tt><br>
a, b,c, x are doubles.
These routines compute the Gauss hypergeometric function 
2F1(a,b,c,x) for |x| < 1.<br>
If the arguments (a,b,c,x) are too close to a singularity then the function 
can return the error code GSL_EMAXITER when the series approximation 
converges too slowly. This occurs in the region of x=1, c - a - b = m 
for integer m.
<p>
<a name="F21_conj"></a>
<tt>GSL::Special::Hyperg::F21_conj</tt><br>
<tt>GSL::Special::Hyperg::F21_conj_e</tt><br>
<tt>Hyperg::F21_conj(a_R, a_I, c, x) -> d1</tt><br>
a_R, a_I, c, x are doubles.
These routines compute the Gauss hypergeometric function 
2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| < 1. 
<p>
<a name="F21_renorm"></a>
<tt>GSL::Special::Hyperg::F21_renorm</tt><br>
<tt>GSL::Special::Hyperg::F21_renorm_e</tt><br>
<tt>Hyperg::F21_renorm(a, b, c, x) -> d1</tt><br>
These routines compute the renormalized Gauss hypergeometric function 
2F1(a,b,c,x) / \Gamma(c) for |x| < 1.
<p>
<a name="F21_conj_renorm"></a>
<tt>GSL::Special::Hyperg::F21_conj_renorm</tt><br>
<tt>GSL::Special::Hyperg::F21_conj_renorm_e</tt><br>
<tt>F21_conj_renorm(a_R, a_I, c, x) -> d1</tt><br>
These routines compute the renormalized Gauss hypergeometric function 
2F1(a_R + i a_I, a_R - i a_I, c, x) / \Gamma(c) for |x| < 1.
<p>
<a name="F20"></a>
<tt>GSL::Special::Hyperg::F20</tt><br>
<tt>GSL::Special::Hyperg::F20_e</tt><br> 
<tt>Hyperg::F20(a, b, x) -> d1</tt><br> 
These routines compute the hypergeometric function 2F0(a,b,x). 
The series representation is a divergent hypergeometric series. 
However, for x < 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL
include GSL::Special
include Math
eps = 1.0e-15

puts "F01"
x = 1.2; y = 2.5; z = 0.2
r01 = Hyperg::F01(x, y)
p r01

puts "F11"
x = 1.2; y = 2.5; z = 0.2
r = Hyperg::F11(x, y, z)
p r

assert fcmp(r01, exp(-2 * sqrt(y)) * Hyperg::F11(x - 0.5, 2*x - 1, 4*sqrt(y)), eps) == 0

puts "F11_int" 
x = [2, 3, 6.9]
r = Hyperg::F11_int(*x)
p r
r = Hyperg::F11_int_e(*x)
p r.val; p r.err 
assert fcmp(r.val, Hyperg::F11(*x), eps) == 0

puts "U_int"
m = 2; n = 3; z = 6.9
r = Hyperg::U_int(m, n, z)
# Kummer's transformation
assert r == pow(z,1-n) * Hyperg::U_int(1 + m - n, 2 - n, z)

puts "U"
assert r == Hyperg::U(m, n, z)

=begin
puts "U_int_e10_e"
r10 = Hyperg::U_int_e10_e(m, n, z)
p r10.val; p r10.err; p r10.e10
assert fcmp(r10.val * 10**r10.e10, r, 10*eps) == 0
=end

puts "F21"
a = 1.1; b = 0.1; c = 0.3; x = 0.8
r = Hyperg::F21(a, b, c, x)
p r
# x = sin(M_PI/6)**2
x = 0.25
z = M_PI/6
r = Hyperg::F21(a, 1 - a, 0.5,sin(z)**2)
assert r = cos((2*a - 1)*z)/cos(z)

puts "F21_conj"
r = Hyperg::F21_conj(a, b, c, x)
p r

puts "F21_renorm"
r = Hyperg::F21_renorm(a, b, c, x)
assert r == Hyperg::F21(a, b, c, x)/Gamma::gamma(c)

puts "F21_conj_renorm"
r = Hyperg::F21_conj_renorm(a, b, c, x)
assert r == Hyperg::F21_conj(a, b, c, x)/Gamma::gamma(c)

puts "F20"
x = -0.8
r = Hyperg::F20(a, b, x)
assert r == pow(-1/x, a) * Hyperg::U(a, 1+a-b, -1/x)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="laguerre.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../special.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="gegenbauer.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Hypergeometric Functions</td> 
</tr></tbody></table><hr></body>
</html>
