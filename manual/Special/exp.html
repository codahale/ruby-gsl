<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Exponential Functions</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="expInt.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../special.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="error.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Exponential Functions</td> 
</tr></tbody></table><hr>
<h1>
Exponential Functions</h1>
<h3>Module Exp</h3>
<a href="#exp">exp</a> ,&nbsp
<a href="#exp_e10_e">exp_e10_e</a> ,&nbsp
<a href="#exp_err_e">exp_err_e</a> ,&nbsp
<a href="#exp_err_e10_e">exp_err_e10_e</a> ,&nbsp
<a href="#exp_mult">exp_mult</a> ,&nbsp
<a href="#exp_mult_e10_e">exp_mult_e10_e</a> ,&nbsp
<a href="#exp_mult_err_e">exp_mult_err_e</a> ,&nbsp
<a href="#exp_mult_err_e10_e">exp_mult_err_e10_e</a> ,&nbsp
<a href="#expm1">expm1</a> ,&nbsp
<a href="#exprel">exprel</a> ,&nbsp
<a href="#exprel_2">exprel_2</a> ,&nbsp
<a href="#exprel_n">exprel_n</a> ,&nbsp
<p>
<h4>Exponential Function</h4>
<a name="exp"></a>
<tt>GSL::Special::Exp::exp</tt><br>
<tt>GSL::Special::Exp::exp_e</tt><br>
<tt>Exp::exp(d1) -> d2</tt><br>
These routines provide an exponential function \exp(x) using GSL semantics 
and error checking.
<p>
<a name="exp_e10_e"></a>
<tt>GSL::Special::Exp::exp_e10_e</tt><br>
<tt>Exp::exp_e10_e(d1) -> res</tt><br>
This function computes the exponential \exp(x) using the Result10 type to 
return a result with extended range. This function may be useful if the 
value of \exp(x) would overflow the numeric range of double.
<p>
<a name="exp_mult"></a>
<tt>GSL::Special::Exp::exp_mult</tt><br>
<tt>GSL::Special::Exp::exp_mult_e</tt><br>
<tt>Exp::exp_mult(d1, d2) -> d3</tt><br>
These routines exponentiate x and multiply by the factor y to return the 
product y \exp(x).
<p>
<a name="exp_mult_e10_e"></a>
<tt>GSL::Special::Exp::exp_mult_e10_e</tt><br>
<tt>Exp::exp_mult_e10_e(d1, d2) -> res</tt><br>
This function computes the product y \exp(x) using the Result10 type to return 
a result with extended numeric range.

<h4>Relative Exponential Functions</h4>
<a name="expm1"></a>
<tt>GSL::Special::Exp::expm1</tt><br>
<tt>GSL::Special::Exp::expm1_e</tt><br>
<tt>GSL::Special::Exp::expm1(d1) -> d2</tt><br>
These routines compute the quantity \exp(x)-1 using an algorithm that is 
accurate for small x.
<p>
<a name="exprel"></a>
<tt>GSL::Special::Exp::exprel</tt><br>
<tt>GSL::Special::Exp::exprel_e</tt><br>
<tt>Exp::exprel(d1) -> d2</tt><br>
These routines compute the quantity (\exp(x)-1)/x using an algorithm that 
is accurate for small x. For small x the algorithm is based on the expansion 
(\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \dots.
<p>
<a name="exprel_2"></a>
<tt>GSL::Special::Exp::exprel_2</tt><br>
<tt>GSL::Special::Exp::exprel_2_e</tt><br>
<tt>Exp::exprel_2(d1) -> d2</tt><br>
These routines compute the quantity 2(\exp(x)-1-x)/x^2 using an algorithm 
that is accurate for small x. For small x the algorithm is based on the 
expansion 2(\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \dots.
<p>
<a name="exprel_n"></a>
<tt>GSL::Special::Exp::exprel_n</tt><br>
<tt>GSL::Special::Exp::exprel_n_e</tt><br>
<tt>Exp::exprel_n(n, d1) -> d2</tt><br>
These routines compute the N-relative exponential, which is the n-th 
generalization of the functions Exp::exprel and Exp::exprel_2. 
The N-relative exponential is given by,<br>
<pre>
exprel_N(x) = N!/x^N (\exp(x) - \sum_{k=0}^{N-1} x^k/k!)
            = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
	    = 1F1 (1,1+N,x)
</pre>

<h4>Exponentiation with Error Estimation</h4>
<a name="exp_err_e"></a>
<tt>GSL::Special::Exp::exp_err_e</tt><br>
<tt>Exp::exp_err_e(x, dx) -> res</tt><br>
x and dx are doubles.
This function exponentiates x with an associated absolute error dx.
It returns res of type Result.
<p>
<a name="exp_err_e10_e"></a>
<tt>GSL::Special::Exp::exp_err_e10_e</tt><br>
<tt>Exp::exp_err_e10_e(x, dx) -> res</tt><br>
This functions exponentiate a quantity x with an associated absolute error dx 
using the Result10 type to return a result with extended range.
<p>
<a name="exp_mult_err_e"></a>
<tt>GSL::Special::Exp::exp_mult_err_e</tt><br>
<tt>Exp::exp_mult_err_e(x, dx, y, dy) -> res</tt><br>
This routine computes the product y \exp(x) for the quantities x, y with 
associated absolute errors dx, dy. It returns res of type Result.
<p>
<a name="exp_mult_err_e10_e"></a>
<tt>GSL::Special::Exp::exp_mult_err_e10_e</tt><br>
<tt>Exp::exp_mult_err_e10_e(x, dx, y, dy) -> res</tt><br>
This routine computes the product y \exp(x) for the quantities x, y with 
associated absolute errors dx, dy using the gsl_sf_result_e10 type to 
return a result with extended range.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL
include GSL::Special
include Math
eps = 1.0e-15

puts "Exp::exp"
x = 4.5
r = Exp::exp(x)
assert r == exp(x) 
r = Exp::exp_e(x)
p r.val; p r.err

puts "Exp::exp_e10_e"
x = 100
r = Exp::exp_e10_e(x)
p r.val; p r.err; p r.e10
assert fcmp(r.val * 10**r.e10, exp(x), 10*eps) == 0

puts "Exp::exp_mult"
x = 5; y = 7.1 
r = Exp::exp_mult(x,y)
assert r == y * exp(x)

puts "Exp::exp_mult_e10_e"
x = 100
r = Exp::exp_mult_e10_e(x, y)
assert r.val * 10**r.e10 == y * exp(x)


puts "Exp::expm1"
x = 1.0e-5
r = Exp::expm1(x)
p r
assert fcmp(r, exp(x) - 1, 10000 * eps) == 0
r = Exp::expm1_e(x)
p r.val; p r.err

x = 4.5
r = Exp::expm1(x)
assert r == exp(x) - 1 

puts "Exp:exprel"
x = 1.0e-5
r = Exp::exprel(x)
assert fcmp(r, (exp(x) - 1)/x, 10000 * eps) == 0

x = 1
r = Exp::exprel(x)
assert r == ((exp(x) - 1)/x)

puts "Exp:exprel2"
x = 1.0e-5
r = Exp::exprel(x)
assert fcmp(r, 2*(exp(x) - 1 - x)/(x*x), 1.0e-5) == 0

puts "Exp::exprel_n"
x = 1.0e-5
r = Exp::exprel_n(2,x)
assert fcmp(r, 2*(exp(x) - 1 - x)/(x*x), 1.0e-5) == 0

puts "Exp::exp_err_e"
x = 3; dx = eps/10
r1 = Exp::exp_err_e(x, dx)
p r1.val; p r1.err
x = 3; dx = 100*eps
r2 = Exp::exp_err_e(x, dx)
p r2.val; p r2.err
assert r1.val == r2.val

puts "Exp::exp_err_e10_e" 
x = 100
r = Exp::exp_err_e10_e(x, eps)
p r.val; p r.err; p r.e10
assert fcmp(r.val * 10**r.e10, exp(x), 10*eps) == 0

puts "Exp::exp_mult_err_e"
x = 4
r = Exp::exp_mult_err_e(x, eps, y, eps)
assert r.val == y * exp(x)

puts "Exp::exp_mult_err_e10_e"
x = 100
r = Exp::exp_mult_err_e10_e(x, eps, y, eps)
assert r.val * 10**r.e10 == y * exp(x)



</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="expInt.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../special.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="error.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Exponential Functions</td> 
</tr></tbody></table><hr>

</body>
</html>
