<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Matrices</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="matrix_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="vector_complex.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Matrices</td> 
</tr></tbody></table><hr>
<h1>
Matrices</h1>
<ul>
<li><a href="#l1">Matrices in GSL</a>
<li><a href="#l2">Class Matrix</a>
<li><a href="#l3">Matrix instance methods</a>
</ul>
<hr>

<a name="l1"></a>
<h2>Matrices in GSL</h2>
Matrices are defined by a gsl_matrix structure which describes a
generalized slice of a block. Like a vector it represents a set of
elements in an area of memory, but uses two indices instead of one.
<p>
The gsl_matrix structure contains six components, the two dimensions
of the matrix, a physical dimension, a pointer to the memory where the
elements of the matrix are stored, data, a pointer to the block owned
by the matrix block, if any, and an ownership flag, owner. The physical
dimension determines the memory layout and can differ from the matrix
dimension to allow the use of submatrices. The gsl_matrix structure is
very simple and looks like this,
<pre>
typedef struct 
{ 
 size_t size1; 
 size_t size2; 
 size_t tda; 
 double * data;
 gsl_block * block; 
 int owner; 
} gsl_matrix;
</pre>
Matrices are stored in row-major order, meaning that each row of elements
forms a contiguous block in memory. This is the standard "C-language
ordering" of two-dimensional arrays. Note that FORTRAN stores arrays
in column-major order. The number of rows is size1. The range of valid
row indices runs from 0 to size1-1. Similarly size2 is the number of
columns. The range of valid column indices runs from 0 to size2-1. The
physical row dimension tda, or trailing dimension, specifies the size
of a row of the matrix as laid out in memory.
<p>
For example, in the following matrix size1 is 3, size2 is 4, and tda
is 8. The physical memory layout of the matrix begins in the top left
hand-corner and proceeds from left to right along each row in turn.
<pre>
00 01 02 03 XX XX XX XX 10 11 12 13 XX XX XX XX 20 21 22 23 XX XX XX XX
</pre>
Each unused memory location is represented by "XX". The pointer data gives
the location of the first element of the matrix in memory. The pointer
block stores the location of the memory block in which the elements of the
matrix are located (if any). If the matrix owns this block then the owner
field is set to one and the block will be deallocated when the matrix is
freed. If the matrix is only a slice of a block owned by another object
then the owner field is zero and any underlying block will not be freed.
<p>
The functions for allocating and accessing matrices are defined in
`gsl_matrix.h'

<a name="l2"></a>
<h2>Class Matrix</h2>
  The elements of the class Matrix are doubles.

<h3>Class methods</h3>
<a href="#alloc">alloc</a> ,&nbsp
<a href="#calloc">calloc</a> ,&nbsp
<a href="#new">new</a> &nbsp
<p>
<a name="new"></a>
<a name="alloc"></a>
<tt>GSL::Matrix::new</tt><br>
<tt>GSL::matrix::alloc</tt>&nbsp; (alias)<br>
<tt>Matrix.new(m, n) -> aMatrix</tt><br>
m and n are integers; aMatrix is of Matrix type, with m rows and n columns.<br>
<tt>Matrix::new(row_1, ...,row_n) -> aMatrix</tt><br>
row_1,..,row_n are of Array type; they initialize the n rows of aMatrix.<br>
<tt>Matrix::new(anArray, m, n)  -> aMatrix</tt><br>
anArray has size m*n; it corresponds to the sequence of rows of aMatrix.
<p>
<a name="calloc"></a>
<tt>GSL::matrix::calloc</tt><br>
<tt>Matrix.calloc(n1, n2) -> aMatrix</tt><br>
This function allocates memory for a matrix of size n1 rows by n2 columns 
and initializes all the elements of aMatrix to zero.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;def foo(r,c)
  0.upto(r-1) do |i|
    0.upto(c-1) do |j|
      yield i,j
    end
  end
end
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new(2, 3)
foo(2,3) {|i,j| m1.set(i, j, i + j)}
p m1

m2 = Matrix.new([0,1,2],[1,2,3])
assert m1 == m2

m2a = Matrix.new([0,1,2],[1,2,3],[1,2,3])
p m2a

m3 = Matrix.new([0,1,2,1,2,3],2, 3)
assert m1 == m3

m4 = Matrix.calloc(2,2)
foo(2,2){|i,j| assert m4.get(i,j) == 0}
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l3"></a>
<h3>Matrix instance methods</h3>
<a href="#*">*</a> ,&nbsp
<a href="#+">+</a> ,&nbsp
<a href="#-">-</a> ,&nbsp
<a href="#/">/</a> ,&nbsp
<a href="#==">==</a> ,&nbsp
<a href="#[]">[]</a> ,&nbsp
<a href="#_dump_data">_dump_data</a> ,&nbsp
<a href="#_load_data">_load_data</a> ,&nbsp
<a href="#add">add</a> ,&nbsp
<a href="#add!">add!</a> ,&nbsp
<a href="#add_constant">add_constant</a> ,&nbsp
<a href="#add_constant!">add_constant!</a> ,&nbsp
<a href="#clone">clone</a> ,&nbsp
<a href="#col">col</a> ,&nbsp
<a href="#column">column</a> ,&nbsp
<a href="#diagonal">diagonal</a> ,&nbsp
<a href="#div_elements">div_elements</a> ,&nbsp
<a href="#div_elements!">div_elements!</a> ,&nbsp
<a href="#dub!">dub!</a> ,&nbsp
<a href="#float_equal">float_equal</a> ,&nbsp
<a href="#fprintf">fprintf</a> ,&nbsp
<a href="#fread">fread</a> ,&nbsp
<a href="#fscanf">fscanf</a> ,&nbsp
<a href="#fwrite">fwrite</a> ,&nbsp
<a href="#get">get</a> ,&nbsp
<a href="#get_col">get_col</a> ,&nbsp
<a href="#get_column">get_column</a> ,&nbsp
<a href="#get_row">get_row</a> ,&nbsp
<a href="#inspect">inspect</a> ,&nbsp
<a href="#isnull">isnull</a> ,&nbsp
<a href="#max">max</a> ,&nbsp
<a href="#max_index">max_index</a> ,&nbsp
<a href="#min">min</a> ,&nbsp
<a href="#min_index">min_index</a> ,&nbsp
<a href="#minmax">minmax</a> ,&nbsp
<a href="#minmax_index">minmax_index</a> ,&nbsp
<a href="#mul">mul</a> ,&nbsp
<a href="#mul!">mul!</a> ,&nbsp
<a href="#mul_elements">mul_elements</a> ,&nbsp
<a href="#mul_elements!">mul_elements!</a> ,&nbsp
<a href="#mult">mult</a> ,&nbsp
<a href="#mult_vect">mult_vect</a> ,&nbsp
<a href="#perm">perm</a> ,&nbsp
<a href="#print">print</a> ,&nbsp
<a href="#printf">printf</a> ,&nbsp
<a href="#row">row</a> ,&nbsp
<a href="#scale">scale</a> ,&nbsp
<a href="#scale!">scale!</a> ,&nbsp
<a href="#set">set</a> ,&nbsp
<a href="#set_all">set_all</a> ,&nbsp
<a href="#set_col">set_col</a> ,&nbsp
<a href="#set_identity">set_identity</a> ,&nbsp
<a href="#set_row">set_row</a> ,&nbsp
<a href="#set_zero">set_zero</a> ,&nbsp
<a href="#size">size</a> ,&nbsp
<a href="#size1">size1</a> ,&nbsp
<a href="#size2">size2</a> ,&nbsp
<a href="#sub">sub</a> ,&nbsp
<a href="#subdiagonal">subdiagonal</a> ,&nbsp
<a href="#submatrix">submatrix</a> ,&nbsp
<a href="#superdiagonal">superdiagonal</a> ,&nbsp
<a href="#swap">swap</a> ,&nbsp
<a href="#swap_cols">swap_cols</a> ,&nbsp
<a href="#swap_cols!">swap_cols!</a> ,&nbsp
<a href="#swap_columns">swap_columns</a> ,&nbsp
<a href="#swap_columns!">swap_columns!</a> ,&nbsp
<a href="#swap_rowcol">swap_rowcol</a> ,&nbsp
<a href="#swap_rowcol!">swap_rowcol!</a> ,&nbsp
<a href="#swap_rows">swap_rows</a> ,&nbsp
<a href="#swap_rows!">swap_rows!</a> ,&nbsp
<a href="#to_a">to_a</a> ,&nbsp
<a href="#transpose">transpose</a> ,&nbsp
<a href="#transpose!">transpose!</a> ,&nbsp
<a href="#transpose_memcpy">transpose_memcpy</a>&nbsp

<h4>Accessing and setting matrix elements</h4>
The functions for accessing the elements of a matrix use the same range
checking system as vectors. You turn off range checking by recompiling
your program with the preprocessor definition GSL_RANGE_CHECK_OFF.
i<p>
The elements of the matrix are stored in "C-order", where the second index
moves continuously through memory. More precisely, the element accessed
by the function Matrix::get(m,i,j) and Matrix_set(m,i,j,x) is<br>
m->data[i * m->tda + j]
where tda is the physical row-length of the matrix.
<p>
<a name="=="></a>
<tt>GSL::Matrix#==</tt><br>
<tt>matr1 == matr2 -> aBool</tt><br>
aBool is true if the two matrices are equal.
<p>
<a name="float_equal"></a>
<tt>GSL::Matrix::float_equal</tt><br>
<tt>Matrix::float_equal(matr1, matr2, eps) -> aBool</tt><br>
eps is a double.
This function returns true if abs(matr1(i,j) - matr2(i,j)) < eps for
all elements.
<p>
<a name="get"></a> 
<tt>GSL::Matrix#get</tt><br>
<tt>matr1.get(i,j) -> d1</tt><br>
This function returns the (i,j)th element of a matrix m. If i or j
lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error
handler is invoked and 0 is returned.
<p>
<a name="set"></a>
<tt>GSL::Matrix#set</tt> &nbsp; (mutating)<br>
<tt>matr1.set(i, j, x) -> </tt><br>
i, j indices; x is a double.
This method sets the value of the (i,j)th element of a matrix matr1 to
x. If i or j lies outside the allowed range of 0 to n1-1 and 0 to n2-1
then the error handler is invoked.<br>
<tt>matr1.set(row_1, ...,row_n) -> aMatrix</tt><br>
row_1,..,row_n are of Array type; they initialize the n rows of aMatrix.<br>
<tt>matr1.set(anArray, m, n) -> aMatrix</tt><br>
anArray has size m*n; it corresponds to the sequence of rows of aMatrix.
<p>
<a name="set_all"></a>
<tt>GSL::Matrix#set_all</tt><br>
<tt>matr1.set_all(x) -> aMatrix</tt><br>
x is a double.
This method sets all the elements of the matrix m to the value x.
<p>
<a name="set_zero"></a>
<tt>GSL::Matrix#set_zero</tt><br>
<tt>matr1.set_all() -> aMatrix</tt><br>
This method sets all the elements of the matrix m to zero.
<p>
<a name="set_identity"></a>
<tt>GSL::Matrix#set_identity</tt><br>
<tt>matr1.set_identity() -> aMatrix</tt><br>
This method sets
the elements of the matrix m to the corresponding elements of the identity
matrix, m(i,j) = \delta(i,j), i.e. a unit diagonal with all off-diagonal
elements zero. This applies to both square and rectangular matrices.
<p>
<a name="to_a"></a>
<a name="_dump_data"></a>
<tt>GSL::Matrix#to_a</tt><br>
<tt>GSL::Matrix#_dump_data</tt>&nbsp; (alias)<br>
<tt>matr1.to_a() -> anArray</tt><br>
This method returns an array of GSL::Vector elements, representing the
rows of matr1.
<p>
<a name="_load_data"></a>
<tt>GSL::Matrix#_load_data</tt>&nbsp; (mutating)<br>
<tt>matr1._load_data(anArray) -> aBool</tt><br>
anArray is an array of GSL::Vector elements, representing the rows of
the allocated matrix matr1.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new(2, 3)

foo(2,3) {|i,j| m1.set(i, j, i + j)}
p m1.to_a
assert m1.to_a[0].class == GSL::Vector

m2 = Matrix.new(2, 3)
m3 = m2.set([0,1,2],[1,2,3])
assert m1 == m2 &amp;&amp; m1 == m3

m4 = Matrix.new(2, 3)
m4.set([0,1,2,1,2,3],2, 3)
assert m1 == m4

m4.set_all(2)
foo(2,3) {|i,j| assert m4.get(i,j) == 2}

m4.set_zero
foo(2,3) {|i,j| assert m4.get(i,j) == 0}

m4.set_identity
foo(2,3) {|i,j| assert( m4.get(i,j) == 0) if (i != j);
 assert(m4.get(i,j) == 1) if (i == j)}

# m5 = Matrix.allocate
m5 = Matrix.new(1,1)
m5._load_data([Vector.new([2,2]), Vector.new([1,3]) ])
assert m5 == Matrix.new([2,2],[1,3])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Reading and writing matrices</h4>
The library provides functions for reading and writing matrices to a
file as binary data or formatted text.
<p>
<a name="fwrite"></a>
<tt>GSL::Matrix#fwrite</tt><br>
<tt>matr1.fwrite(f)</tt><br>
This function writes the elements of the matrix m to the stream <tt>f</tt> in
binary format. An exception is raised if there
was a problem writing to the file. Since the data is written in the native
binary format it may not be portable between different architectures.
<p>
<a name="fread"></a>
<tt>GSL::Matrix#fread</tt><br>
<tt>matr1.fread(f)</tt><br>
This function reads into the matrix m from the open stream <tt>f</tt> in binary
format. The matrix m must be preallocated with the correct dimensions
since the function uses the size of m to determine how many bytes to
read. 
An exception is raised if there was a problem reading from the file. 
The data is assumed to have been written
in the native binary format on the same architecture.
<p>
<a name="fprintf"></a>
<tt>GSL::Matrix#fprintf</tt><br>
<tt>matr1.fprintf(f, format)</tt><br>
This function writes the elements of the matrix
m line-by-line to the stream <tt>f</tt> using the format specifier 
<tt>format</tt>,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. 
An exception is raised if there was a problem writing to the file.
<p>
<a name="printf"></a>
<tt>GSL::Matrix#printf</tt><br>
<tt>matr1.printf(format)</tt><br>
This function writes the elements of the matrix
m line-by-line to the standard output using the format specifier 
<tt>format</tt>,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. 
An exception is raised if there was a problem writing to stdout.
<p>
<p>
<a name="fscanf"></a>
<tt>GSL::Matrix#fscanf</tt><br>
<tt>matr1.fscanf(f)</tt><br>
This function reads formatted data from the stream stream into the matrix
m. The matrix m must be preallocated with the correct dimensions since the
function uses the size of m to determine how many numbers to read. 
An exception is raised if there was a problem reading from the file.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1,2],[1,2,3])
File.open("matr1.dat","w"){|f| m1.fwrite(f) }
m2 = Matrix.new(2,3)
File.open("matr1.dat"){|f| m2.fread(f) }
assert m1 == m2
File.open("vect1.dat"){|f| m2.fread(f) } if $DEBUG

File.open("matr2.dat","w"){|f| m1.fprintf(f," %g") }
m3 = Matrix.new(2,3)
File.open("matr2.dat"){|f| m3.fscanf(f) }
foo(2,3){|i,j| assert m1.get(i,j) == m3.get(i,j)}
assert m1 == m3
m1.printf("%g")
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Matrix views</h4>
A matrix view is a temporary object, stored on the stack, which can
be used to operate on a subset of matrix elements. Matrix views can be
defined for both constant and non-constant matrices using separate types
that preserve constness. A matrix view has the type gsl_matrix_view and
a constant matrix view has the type gsl_matrix_const_view. In both cases
the elements of the view can by accessed using the matrix component
of the view object. A pointer gsl_matrix * or const gsl_matrix * can
be obtained by taking the address of the matrix component with the &
operator. In addition to matrix views it is also possible to create
vector views of a matrix, such as row or column views.
<p>
<a name="submatrix"></a>
<tt>GSL::Matrix#submatrix</tt>&nbsp; (non-mutating)<br>
<tt>matr1.submatrix(k1, k2, n1, n2) -> matr2</tt><br>
k1, k2, n1 and n2 are indices.
This function returns a matrix view of a
submatrix of the matrix m. The upper-left element of the submatrix is
the element (k1,k2) of the original matrix. The submatrix has n1 rows
and n2 columns. The physical number of columns in memory given by tda
is unchanged. Mathematically, the (i,j)-th element of the new matrix is
given by,<br>
m'(i,j) = m->data[(k1*m->tda + k1) + i*m->tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix#view_array(base, n1, n2</tt> -> matr1<br>
MISSING &nbsp; (see Matrix#set)<br>
<tt>base</tt> is of type Array. n1 and n2 are integers.
This function returns a
matrix view of the array <tt>base</tt>. 
The matrix has n1 rows and n2 columns. The
physical number of columns in memory is also given by n2. Mathematically,
the (i,j)-th element of the new matrix is given by,<br>
m'(i,j) = base[i*n2 + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix#view_array_with_tda(base, n1, n2, tda)</tt> -> matr1<br>
MISSING &nbsp;<br>
This function returns a matrix view of the
array base with a physical number of columns tda which may differ from
corresponding the dimension of the matrix. The matrix has n1 rows and
n2 columns, and the physical number of columns in memory is given by
tda. Mathematically, the (i,j)-th element of the new matrix is given by,<br>
m'(i,j) = base[i*tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix#view_vector(v, n1, n2)</tt> -> matr1<br>
MISSING &nbsp;<br>
v is of type GSL::Vector.
This function returns a matrix view of the vector v. The matrix has
n1 rows and n2 columns. The vector must have unit stride. The physical
number of columns in memory is also given by n2. Mathematically, the
(i,j)-th element of the new matrix is given by,<br>
m'(i,j) = v->data[i*n2 + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix#view_vector_with_tda(v, n1, n2, tda)</tt> -> matr1<br>
MISSING &nbsp;<br>
This function returns a matrix view of the
vector v with a physical number of columns tda which may differ from the
corresponding matrix dimension. The vector must have unit stride. The
matrix has n1 rows and n2 columns, and the physical number of columns
in memory is given by tda. Mathematically, the (i,j)-th element of the
new matrix is given by,<br>
m'(i,j) = v->data[i*tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new(3, 4)

foo(3,4) {|i,j| m1.set(i, j, i + j)}
assert m1 == Matrix.new([0,1,2,3],
                        [1,2,3,4],
			[2,3,4,5])
m2 = m1.submatrix(1,1,2,2)
assert m2 == Matrix.new([2,3],
                        [3,4])
m3 = m1.submatrix(0,0,3,3)
assert m3 == Matrix.new([0,1,2],
                        [1,2,3],
			[2,3,4])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Creating row and column views</h4>
In general there are two ways to access an object, by reference or by copying. 
The functions described in this section create vector views which allow 
access to a row or column of a matrix by reference. Modifying elements of 
the view is equivalent to modifying the matrix, since both the vector view 
and the matrix point to the same memory block.

<a name="row"></a>
<tt>GSL::Matrix#row</tt><br>
<tt>matr1.row(i) -> v1</tt><br>
This method returns v1, of type GSL::Vector, which is a copy of the 
i-th row of the matrix m. It does not copy by reference; it is the
same as Matrix#get_row .
<p>
<a name="column"></a>
<tt>GSL::Matrix#column</tt><br>
<tt>matr1.column(i) -> v1</tt><br>
This method returns v1, of type GSL::Vector, which is a copy of the 
j-th column of the matrix m. 
It does not copy by reference; it is the same as Matrix#get_column .

<p>
<a name="diagonal"></a>
<tt>GSL::Matrix#diagonal</tt><br>
<tt>m1.diagonal() -> v1</tt><br>
This method returns v1, of type GSL::Vector, which is a copy of the
diagonal of the matrix m1. 
The matrix m is not required to be square. For a rectangular matrix the
length of the diagonal is the same as the smaller dimension of the matrix.
<p>
<a name="subdiagonal"></a>
<tt>GSL::Matrix#subdiagonal</tt><br>
<tt>m1.subdiagonal(k) -> v1</tt><br>
k in an integer.<br>
This method returns v1, of type GSL::Vector, which is a copy 
of the k-th subdiagonal of the matrix m. The matrix m is not required
to be square. The diagonal of the matrix corresponds to k = 0.
<p>
<a name="superdiagonal"></a>
<tt>GSL::Matrix#superdiagonal</tt><br>
<tt>m1.superdiagonal(k) -> v1</tt><br>
This method returns v1, of type GSL::Vector, which is a copy 
of the k-th superdiagonal of the matrix m. The matrix m is not required
to be square. The diagonal of the matrix corresponds to k = 0.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new(3, 4)

foo(3,4) {|i,j| m1.set(i, j, i + j)}
row1 = m1.row(1)
assert row1.to_a == [1,2,3,4]

col1 = m1.col(1)
assert col1.to_a == [1,2,3]

diag1 = m1.diagonal
assert diag1.to_a == [0,2,4]
assert m1.subdiagonal(1) == Vector.new([1,3])
assert m1.superdiagonal(3) == Vector.new([3])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Copying matrices</h4>
<p>
<a name="clone"></a>
<tt>GSL::Matrix#clone</tt><br>
<tt>matr1.clone() -> matr2</tt><br>
matr2 is a copy of matr1.
<p>
<a name="swap"></a>
<tt>GSL::Matrix#swap</tt><br>
<tt>matr1.swap(matr2) -> aMatrix</tt><br>
This function exchanges the elements of the matrices matr1 and matr2 
by copying.  The two matrices must have the same size.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new(3, 4)
foo(3,4) {|i,j| m1.set(i, j, i + j)}

m2 = m1.clone
assert m2 == m1
m2.set(1,1, 7)
assert m2 != m1
m1.swap(m2)
assert m1.get(1,1) == 7 &amp;&amp; m2.get(1,1) == 2
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Copying rows and columns</h4>
The functions described in this section copy a row or column of a matrix
into a vector. This allows the elements of the vector and the matrix to
be modified independently. Note that if the matrix and the vector point
to overlapping regions of memory then the result will be undefined. The
same effect can be achieved with more generality using gsl_vector_memcpy
with vector views of rows and columns.
<p>
<a name="get_row"></a>
<tt>GSL::Matrix#get_row</tt><br>
<tt>matr1.get_row(i) -> v1</tt><br>
Matrix#get_row is an alias of Matrix#row .
<p>
<a name="get_column"></a>
<a name="get_col"></a>
<tt>GSL::Matrix#get_col</tt>&nbsp; (alias)<br>
<tt>matr1.get_column(i) -> v1</tt><br>
Matrix#get_row is an alias of Matrix#row .
<p>
<a name="set_row"></a>
<tt>GSL::Matrix#set_row</tt><br>
<tt>matr1.set_row(i, v1) -> aMatrix</tt><br>
This method copies the elements of the vector v1, of type GSL::Vector,
into the i-th row of the matrix matr1. 
The length of the vector must be the same as the length of the row.
<p>
<a name="set_col"></a>
<tt>GSL::Matrix#set_col</tt><br>
<tt>matr1.set_col(i, v1) -> aMatrix</tt><br>
This method copies the elements of the vector v1, of type GSL::Vector,
into the i-th column of the matrix matr1. 
The length of the vector must be the same as the length of the column.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1],
                [2,3])

v1 = Vector.new([4,5])		
		
m1.set_row(1,v1)		
assert m1 = Matrix.new([0,1],
                       [4,5])
m1.set_col(1,v1)
assert m1 = Matrix.new([0,4],
                       [4,5])
		       
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Exchanging rows and columns</h4>
The following functions can be used to exchange the rows and columns of
a matrix.
<p>
<a name="swap_rows"></a>
<tt>GSL::Matrix#swap_rows</tt><br>
<tt>matr1.swap_rows(i, j) -> matr2</tt><br>
This method returns a matrix with the i-th and j-th rows exchanged.
<p>
<a name="swap_rows!"></a>
<tt>GSL::Matrix#swap_rows!</tt><br>
<tt>matr1.swap_rows!() -> matr2</tt><br>
Mutating version.
This method exchanges the i-th and j-th rows of the matrix m in-place.
<p>
<a name="swap_rowcol"></a>
<tt>GSL::Matrix#swap_rowcol</tt><br>
<tt>matr1.swap_rowcol(i, j) -> matr2</tt><br>
This method returns a matrix with the i-th row and j-th column of matr1
exchanged.
<p>
<a name="swap_rowcol!"></a>
<tt>GSL::Matrix#swap_rowcol!</tt><br>
<tt>matr1.swap_rowcol!(i, j) -> matr2</tt><br>
Mutating version.
This method exchanges the i-th row and j-th column of matr1 .
The matrix must be square for this operation to be possible.
<p>
<a name="transpose_memcpy"></a>
<a name="transpose"></a>
<tt>GSL::Matrix#transpose_memcpy</tt><br>
<tt>GSL::Matrix#transpose</tt>&nbsp; (alias)<br>
<tt>GSL::Matrix#t</tt>&nbsp; (alias)<br>
<tt>matr1.t -> matr2</tt><br>
This method makes a copy of the transpose of the matrix matr1.
src by copying the elements of src into dest. 
It works on all matrices.
<p>
<a name="transpose!"></a>
<tt>GSL::Matrix#transpose!</tt><br>
<tt>matr1.transpose!() -> matr2</tt><br>
Mutating version, but working only on square matrices.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1,2], [2,3,4])

m2 = m1.swap_rows(0,1)
assert m2 == Matrix.new([2,3,4], [0,1,2]) &amp;&amp; m1 == Matrix.new([0,1,2], [2,3,4])
m3 = m1.swap_rows!(0,1)
assert m1 == Matrix.new([2,3,4], [0,1,2]) &amp;&amp; m3 == m1

m4 = Matrix.new([4,3,5],
                [2,1,3],
		[9,8,7])

m5 = m4.swap_rowcol(0,2)
assert m5 == Matrix.new([5,3,7],
                        [2,1,3],
	      	        [9,8,4])
			
assert m4 == Matrix.new([4,3,5],[2,1,3],[9,8,7])
m4.swap_rowcol!(0,2)
assert m4 == m5

m6 = m4.transpose
m5.transpose!
assert m6 == Matrix.new([5,2,9],
                        [3,1,8],
			[7,3,4])
			
m7 = Matrix.new([0,1,2], 
                [2,3,4])
m8 = m7.transpose
assert m8 == Matrix.new([0,2],
                        [1,3],
			[2,4])
			
			
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Matrix operations</h4>
The following operations are only defined for real matrices.
<p>
<a name="add"></a>
<a name="+"></a>
<tt>GSL::Matrix#add</tt><br>
<tt>GSL::Matrix#+</tt>&nbsp; (alias)<br>
<tt>matr1.add(matr2) -> matr3</tt><br>
This method returns the sum of the matrices matr1 + matr2.
The two matrices must have the same dimensions.
<p>
<a name="add!"></a>
<tt>GSL::Matrix#add!</tt><br>
<tt>matr1.add!(matr2) -> matr3</tt><br>
Mutating version.
<p>
<a name="sub"></a>
<a name="-"></a>
<tt>GSL::Matrix#sub</tt><br>
<tt>GSL::Matrix#-</tt>&nbsp; (alias)<br>
<tt>matr1.sub(matr2) -> matr3</tt><br>
This method returns the difference of the matrices matr1 - matr2.
The two matrices must have the same dimensions.
<p> 
<a name="sub!"></a> 
<tt>GSL::Matrix#sub!</tt><br> 
<tt>matr1.sub!(matr2) -> matr3</tt><br>
Mutating version. 
<p>
<a name="mul_elements"></a>
<tt>GSL::Matrix#mul_elements</tt><br>
<tt>matr1.mul_elements(matr2) -> matr3</tt><br>
This method multiplies the elements of matrix matr1 by the elements of 
matrix matr2, matr3(i,j) = matr1(i,j) * matr2(i,j). 
The two matrices must have the same dimensions.
<p>
<a name="mul"></a>
<tt>GSL::Matrix#mul</tt><br>
<tt>matr1.mul(x) -> matr3</tt><br>
Same as GSL::Matrix#mul_elements if x is a GSL::Matrix; if it is Numeric,
it is GSL::Matrix#scale.
<p>

<a name="div_elements"></a>
<tt>GSL::Matrix#div_elements</tt><br>
<tt>matr1.div_elements(matr2) -> matr3</tt><br>
This method divides the elements of matrix matr1 by the elements of 
matrix matr2, matr3(i,j) = matr1(i,j) / matr2(i,j). 
The two matrices must have the same dimensions.
<p>
<a name="scale"></a>
<tt>GSL::Matrix#scale</tt><br>
<tt>matr1.scale(x) -> matr2</tt><br>
<tt>matr1 * x -> matr2</tt>&nbsp; (alias)<br>
x is a double.
This method multiplies the elements of matrix matr1 by the constant factor x,
matr2(i,j) = x matr1(i,j).
<p>
<a name="scale!"></a>
<tt>GSL::Matrix#scale!</tt><br>
<tt>matr1.scale!(x) -> matr2</tt><br>
Mutating method.
<p>
<a name="add_constant"></a>
<tt>GSL::Matrix#add_constant</tt><br>
<tt>matr1.add_constant(x) -> matr2</tt><br>
x is a double.
This method adds the constant value x to the elements of the matrix matr1, 
matr2(i,j) = matr1(i,j) + x.
<p>
<a name="add_constant!"></a>
<tt>GSL::Matrix#add_constant!</tt><br>
<tt>matr1.add_constant!(x) -> matr2</tt><br>
Mutating method.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1,2], [2,3,4])
m2 = Matrix.new([0,4,3], [2,3,4])
m3 = m1 + m2
assert m3 == Matrix.new([0,5,5],[4,6,8])

m2.add!(m1)
assert m2 == Matrix.new([0,5,5],[4,6,8]) &amp;&amp; m1 == Matrix.new([0,1,2], [2,3,4])

m4 = m3 - Matrix.new([0,4,3], [2,3,4])
assert m4 == m1

m2.sub!(m1)
assert m2 == Matrix.new([0,4,3], [2,3,4])

m5 = m1.mul_elements(m1)
m5 == Matrix.new([0,1,4], [4,9,16])

m6 = Matrix.new([2,2,2],[4,1,2])
m7 = m1.div_elements(m6)
assert m7 == Matrix.new([0,0.5,1],[0.5,3,2])

m8 = m1.scale(1.5)
assert m8 == Matrix.new([0,1.5,3], [3,4.5,6])

m7.scale!(0.5)
assert m7 == Matrix.new([0,0.25,0.5],[0.25,1.5,1])

m9 = m7.add_constant(0.5)
assert m9 == Matrix.new([0.5,0.75,1],[0.75,2,1.5])

m7.add_constant!(0.5)
assert m7 == Matrix.new([0.5,0.75,1],[0.75,2,1.5])

m1 = Matrix.new([0,1,2], [2,3,4])
m2 = Matrix.new([0,4,3], [2,3,4])
m10 = m1.mul(m2)
assert m10 == Matrix.new([0,4,6], [4,9,16])
assert m10 == m1.mul_elements(m2)
assert m1.mul(2) == Matrix.new([0,2,4],[4,6,8])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Finding maximum and minimum elements of matrices</h4>
<a name="max"></a>
<tt>GSL::Matrix#max</tt><br>
<tt>matr1.max() -> d1</tt><br>
This method returns the maximum value in the matrix matr1.
<a name="min"></a>
<tt>GSL::Matrix#min</tt><br>
<tt>matr1.min() -> d1</tt><br>
This method returns the minimum value in the matrix matr1.
<p>
<a name="minmax"></a>
<tt>GSL::Matrix#minmax</tt><br>
<tt>matr1.minmax() -> anArray</tt><br>
This method returns the two-dimensional array anArray = [m1.min, m1.max]
<p>
<a name="max_index"></a>
<tt>GSL::Matrix#max_index</tt><br>
<tt>matr1.max_index() -> anArray</tt><br>
This method returns the indices of the maximum
value in the matrix matr1, storing them in anArray. When there are
several equal maximum elements then the first element found is returned.
<p>
<a name="min_index"></a>
<tt>GSL::Matrix#min_index</tt><br>
<tt>matr1.min_index() -> anArray</tt><br>
This method returns the indices of the minimum
value in the matrix matr1, storing them in anArray.  When there are
several equal minimum elements then the first element found is returned.
<p>
<a name="minmax_index"></a>
<tt>GSL::Matrix#minmax_index</tt><br>
<tt>matr1.minmax_index() -> anArray</tt><br>
This method returns the indices of the minimum
and maximum values in the matrix m, storing them in 
anArray = [imin,jmin, imax,jmax] . 
When there are several equal minimum or maximum elements
then the first elements found are returned.

<h4>Matrix properties</h4>
<a name="isnull"></a>
<tt>GSL::Matrix#isnull</tt><br>
<tt>matr1.isnull() -> anInteger</tt><br>
This method returns 1 if all the elements of the matrix m are zero, 
and 0 otherwise.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1,2], [2,3,4])
assert m1.max == 4 &amp;&amp; m1.min == 0 &amp;&amp; m1.minmax == [0,4]
assert m1.max_index == [1,2] &amp;&amp; m1.min_index == [0,0] &amp;&amp; m1.minmax_index == [0, 0, 1, 2]

assert m1.isnull == 0
m2 = Matrix.new([0,0],[0,0])
assert m2.isnull == 1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>BLAS Support</h4>

<a name="mult"></a>
<tt>GSL::Matrix#mult</tt><br>
<tt>matr1.mult(matr2) -> matr3</tt><br>
<tt>matr1 * matr2 -> vect2</tt>&nbsp; (alias)<br>
This method returns the matrix product 
matr3(i,j) = \sum_k matr1(i,k) matr2(k,j)
<p>
<a name="mult_vect"></a>
<tt>GSL::Matrix#mult_vect</tt><br>
<tt>matr1.mult_vect(vect1) -> vect2</tt><br>
<tt>matr1 * vect1 -> vect2</tt>&nbsp; (alias)<br>
This method returns the matrix product
vect2(i) = \sum_j matr1(i,j) vect1(j)
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL
require 'gsl_util'

m1 = Matrix.new([2,1], [1,3])
m2 = Matrix.new([0,2], [1,-1])
m3 = m1 * m2
assert m3 == Matrix.new([1,3],[3,-1])

m4 = Matrix.new([2,1], [1,3], [1,2])
m5 = Matrix.new([2,1,1],[1,2,2])
m6 = m4 * m5
assert m6 == Matrix.new([5,4,4],[5,7,7],[4,5,5])
m7 = m5 * m4
assert m7 == Matrix.new([6,7],[6,11])

eps = 1.0e-15
v1 = Vector.new([1,0])
v2 = m1 * v1
assert v2 == Vector.new([2,1])

v3 = Vector.new([0,1])
v4 = m1 * v3
assert v4 == Vector.new([1,3])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h4>Other functions added</h4>
<p>
<a name="negative"></a>
<tt>GSL::Matrix::negative</tt><br>
<tt>GSL::Matrix::-@</tt><br>
<tt>-matr1 -> matr2</tt><br>
This method gives the negative of the matrix.
<p>
<a name="perm"></a>
<tt>GSL::Matrix::perm</tt><br>
<tt>Matrix::perm(perm1) -> matr1</tt><br>
perm1 has type Permutation; this method returns the corresponding matrix P.
The permutation matrix P is encoded in the permutation perm1. 
The j-th column of the matrix P is given by the k-th column of the identity 
matrix, where k = perm_j the j-th element of the permutation vector.


<h4>References and Further Reading</h4>

The block, vector and matrix objects in GSL follow the valarray model of C++. 
A description of this model can be found in the following reference,

B. Stroustrup, The C++ Programming Language (3rd Ed), 
Section 22.4 Vector Arithmetic. Addison-Wesley 1997, ISBN 0-201-88954-4.

    
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="matrix_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="vector_complex.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Matrices</td> 
</tr></tbody></table><hr>
</body>
</html>
