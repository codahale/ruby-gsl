<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Complex Matrices</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="matrix.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex Matrices</td> 
</tr></tbody></table><hr>
<h1>
Complex Matrices</h1>
</h1>
<ul>
<li><a href="#l1">Complex Matrices in GSL</a>
<li><a href="#l2">Class Matrix_complex</a>
<li><a href="#l3">Matrix_complex instance methods</a>
</ul>
<hr>

<a name="l1"></a>
<h2>Complex Matrices in GSL</h2>
Complex matrices are defined by a gsl_matrix_complex structure 
which describes a
generalized slice of a block. Like a vector it represents a set of
elements in an area of memory, but uses two indices instead of one.
<p>
The gsl_matrix structure contains six components, the two dimensions
of the matrix, a physical dimension, a pointer to the memory where the
elements of the matrix are stored, data, a pointer to the block owned
by the matrix block, if any, and an ownership flag, owner. The physical
dimension determines the memory layout and can differ from the matrix
dimension to allow the use of submatrices. The gsl_matrix structure is
very simple and looks like this,
<pre>
typedef struct 
{ 
 size_t size1; 
 size_t size2; 
 size_t tda; 
 double * data;
 gsl_block_complex * block; 
 int owner; 
} gsl_matrix_complex;
</pre>
Matrices are stored in row-major order, meaning that each row of elements
forms a contiguous block in memory. This is the standard "C-language
ordering" of two-dimensional arrays. Note that FORTRAN stores arrays
in column-major order. The number of rows is size1. The range of valid
row indices runs from 0 to size1-1. Similarly size2 is the number of
columns. The range of valid column indices runs from 0 to size2-1. The
physical row dimension tda, or trailing dimension, specifies the size
of a row of the matrix as laid out in memory.
<p>
For example, in the following matrix size1 is 3, size2 is 4, and tda
is 8. The physical memory layout of the matrix begins in the top left
hand-corner and proceeds from left to right along each row in turn.
<pre>
00 01 02 03 XX XX XX XX 10 11 12 13 XX XX XX XX 20 21 22 23 XX XX XX XX
</pre>
Each unused memory location is represented by "XX". The pointer data gives
the location of the first element of the matrix in memory. The pointer
block stores the location of the memory block in which the elements of the
matrix are located (if any). If the matrix owns this block then the owner
field is set to one and the block will be deallocated when the matrix is
freed. If the matrix is only a slice of a block owned by another object
then the owner field is zero and any underlying block will not be freed.
<p>
The functions for allocating and accessing matrices are defined in
`gsl_matrix.h'

<a name="l2"></a>
<h2>Class Matrix_complex</h2>
  The elements of the class GSL::Matrix have GSL::Complex type.

<h3>Class methods</h3>
<a href="#alloc">alloc</a> ,&nbsp
<a href="#calloc">calloc</a> ,&nbsp
<a href="#new">new</a> &nbsp
<p>
<a name="new"></a>
<a name="alloc"></a>
<tt>GSL::Matrix_complex::new</tt><br>
<tt>GSL::matrix::alloc</tt>&nbsp; (alias)<br>
<tt>Matrix_complex.new(m, n) -> aMatrix_complex</tt><br>
m and n are integers; aMatrix_complex is of Matrix_complex type, with m rows and n columns.<br>
<tt>Matrix_complex::new(row_1, ...,row_n) -> aMatrix_complex</tt><br>
row_1,..,row_n are of Array type; they initialize the n rows of aMatrix_complex.<br>
<tt>Matrix_complex::new(anArray, m, n)  -> aMatrix_complex</tt><br>
anArray has size m*n; it corresponds to the sequence of rows of aMatrix_complex.
<p>
<a name="calloc"></a>
<tt>GSL::matrix::calloc</tt><br>
<tt>Matrix_complex.calloc(n1, n2) -> aMatrix_complex</tt><br>
This function allocates memory for a matrix of size n1 rows by n2 columns 
and initializes all the elements of aMatrix_complex to zero.

<p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"; include GSL

m1 = Matrix_complex.new([0,0, 1,0], [1,0, 0,0])

m2 = Matrix_complex.new(2,2)
assert m2 ==  Matrix_complex.new([0,0, 0,0], [0,0, 0,0])

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l3"></a>
<h3>Matrix_complex instance methods</h3>
<a href="#*">*</a> ,&nbsp
<a href="#+">+</a> ,&nbsp
<a href="#-">-</a> ,&nbsp
<a href="#/">/</a> ,&nbsp
<a href="#==">==</a> ,&nbsp
<a href="#[]">[]</a> ,&nbsp
<a href="#_dump_data">_dump_data</a> ,&nbsp
<a href="#_load_data">_load_data</a> ,&nbsp
<a href="#add">add</a> ,&nbsp
<a href="#add!">add!</a> ,&nbsp
<a href="#add_constant">add_constant</a> ,&nbsp
<a href="#add_constant!">add_constant!</a> ,&nbsp
<a href="#clone">clone</a> ,&nbsp
<a href="#col">col</a> ,&nbsp
<a href="#column">column</a> ,&nbsp
<a href="#diagonal">diagonal</a> ,&nbsp
<a href="#div_elements">div_elements</a> ,&nbsp
<a href="#div_elements!">div_elements!</a> ,&nbsp
<a href="#dub!">dub!</a> ,&nbsp
<a href="#float_equal">float_equal</a> ,&nbsp
<a href="#fprintf">fprintf</a> ,&nbsp
<a href="#fread">fread</a> ,&nbsp
<a href="#fscanf">fscanf</a> ,&nbsp
<a href="#fwrite">fwrite</a> ,&nbsp
<a href="#get">get</a> ,&nbsp
<a href="#get_col">get_col</a> ,&nbsp
<a href="#get_column">get_column</a> ,&nbsp
<a href="#get_row">get_row</a> ,&nbsp
<a href="#inspect">inspect</a> ,&nbsp
<a href="#isnull">isnull</a> ,&nbsp
<a href="#max">max</a> ,&nbsp
<a href="#max_index">max_index</a> ,&nbsp
<a href="#min">min</a> ,&nbsp
<a href="#min_index">min_index</a> ,&nbsp
<a href="#minmax">minmax</a> ,&nbsp
<a href="#minmax_index">minmax_index</a> ,&nbsp
<a href="#mul">mul</a> ,&nbsp
<a href="#mul!">mul!</a> ,&nbsp
<a href="#mul_elements">mul_elements</a> ,&nbsp
<a href="#mul_elements!">mul_elements!</a> ,&nbsp
<a href="#mult">mult</a> ,&nbsp
<a href="#mult_vect">mult_vect</a> ,&nbsp
<a href="#perm">perm</a> ,&nbsp
<a href="#print">print</a> ,&nbsp
<a href="#printf">printf</a> ,&nbsp
<a href="#row">row</a> ,&nbsp
<a href="#scale">scale</a> ,&nbsp
<a href="#scale!">scale!</a> ,&nbsp
<a href="#set">set</a> ,&nbsp
<a href="#set_all">set_all</a> ,&nbsp
<a href="#set_col">set_col</a> ,&nbsp
<a href="#set_identity">set_identity</a> ,&nbsp
<a href="#set_row">set_row</a> ,&nbsp
<a href="#set_zero">set_zero</a> ,&nbsp
<a href="#size">size</a> ,&nbsp
<a href="#size1">size1</a> ,&nbsp
<a href="#size2">size2</a> ,&nbsp
<a href="#sub">sub</a> ,&nbsp
<a href="#subdiagonal">subdiagonal</a> ,&nbsp
<a href="#submatrix">submatrix</a> ,&nbsp
<a href="#superdiagonal">superdiagonal</a> ,&nbsp
<a href="#swap">swap</a> ,&nbsp
<a href="#swap_cols">swap_cols</a> ,&nbsp
<a href="#swap_cols!">swap_cols!</a> ,&nbsp
<a href="#swap_columns">swap_columns</a> ,&nbsp
<a href="#swap_columns!">swap_columns!</a> ,&nbsp
<a href="#swap_rowcol">swap_rowcol</a> ,&nbsp
<a href="#swap_rowcol!">swap_rowcol!</a> ,&nbsp
<a href="#swap_rows">swap_rows</a> ,&nbsp
<a href="#swap_rows!">swap_rows!</a> ,&nbsp
<a href="#to_a">to_a</a> ,&nbsp
<a href="#transpose">transpose</a> ,&nbsp
<a href="#transpose!">transpose!</a> ,&nbsp
<a href="#transpose_memcpy">transpose_memcpy</a>&nbsp

<h4>Accessing and setting matrix elements</h4>
The functions for accessing the elements of a matrix use the same range
checking system as vectors. You turn off range checking by recompiling
your program with the preprocessor definition GSL_RANGE_CHECK_OFF.
i<p>
The elements of the matrix are stored in "C-order", where the second index
moves continuously through memory. More precisely, the element accessed
by the function Matrix_complex::get(m,i,j) and Matrix_complex_set(m,i,j,x) is<br>
m->data[i * m->tda + j]
where tda is the physical row-length of the matrix.
<p>
<a name="=="></a>
<tt>GSL::Matrix_complex#==</tt><br>
<tt>matr1 == matr2 -> aBool</tt><br>
aBool is true if the two matrices are equal.
<p>
<a name="float_equal"></a>
<tt>GSL::Matrix_complex::float_equal</tt><br>
<tt>Matrix_complex::float_equal(matr1, matr2, eps) -> aBool</tt><br>
eps is a double.
This function returns true if abs(matr1(i,j) - matr2(i,j)) < eps for
all elements.
<p>
<a name="get"></a> 
<tt>GSL::Matrix_complex#get</tt><br>
<tt>matr1.get(i,j) -> d1</tt><br>
This function returns the (i,j)th element of a matrix m. If i or j
lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error
handler is invoked and 0 is returned.
<p>
<a name="set"></a>
<tt>GSL::Matrix_complex#set</tt> &nbsp; (mutating)<br>
<tt>matr1.set(i, j, x) -> </tt><br>
i, j indices; x is a double.
This method sets the value of the (i,j)th element of a matrix matr1 to
x. If i or j lies outside the allowed range of 0 to n1-1 and 0 to n2-1
then the error handler is invoked.<br>
<tt>matr1.set(row_1, ...,row_n) -> aMatrix_complex</tt><br>
row_1,..,row_n are of Array type; they initialize the n rows of aMatrix_complex.<br>
<tt>matr1.set(anArray, m, n) -> aMatrix_complex</tt><br>
anArray has size m*n; it corresponds to the sequence of rows of aMatrix_complex.
<p>
<a name="set_all"></a>
<tt>GSL::Matrix_complex#set_all</tt><br>
<tt>matr1.set_all(x) -> aMatrix_complex</tt><br>
x is a double.
This method sets all the elements of the matrix m to the value x.
<p>
<a name="set_zero"></a>
<tt>GSL::Matrix_complex#set_zero</tt><br>
<tt>matr1.set_all() -> aMatrix_complex</tt><br>
This method sets all the elements of the matrix m to zero.
<p>
<a name="set_identity"></a>
<tt>GSL::Matrix_complex#set_identity</tt><br>
<tt>matr1.set_identity() -> aMatrix_complex</tt><br>
This method sets
the elements of the matrix m to the corresponding elements of the identity
matrix, m(i,j) = \delta(i,j), i.e. a unit diagonal with all off-diagonal
elements zero. This applies to both square and rectangular matrices.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"; include GSL

c1 = Complex.new2(3,4)
c2 = Complex.new2(1,2)
m0 = Matrix_complex.new([1,0, 0,0], [0,0, 1,0])
m1 = Matrix_complex.new([0,0, 1,0], [1,0, 0,0])
m2 = Matrix_complex.new([0,0, 0,-1],[0,1, 0,0])
m3 = Matrix_complex.new([1,0, 0,0], [0,0, -1,0])
p m0
assert m0.get(0,0) == Complex.new2(1,0)
assert m0.size1 == 2 &amp;&amp; m0.size2 == 2

m0d = Matrix_complex.new([1,0, 0,0],[0,0, 1,0])
assert m0 == m0d &amp;&amp; m0 != m1
m0d[0,1] = c1
assert m0d == Matrix_complex.new([1,0, 3,4],[0,0, 1,0])
m0d.set_all(c2)
assert m0d == Matrix_complex.new([1,2, 1,2], [1,2, 1,2])
m0d.set_zero
assert m0d == Matrix_complex.new([0,0, 0,0], [0,0, 0,0])
m0d.set_identity
assert m0d == m0
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="to_a"></a>
<a name="_dump_data"></a>
<tt>GSL::Matrix_complex#to_a</tt><br>
<tt>GSL::Matrix_complex#_dump_data</tt>&nbsp; (alias)<br>
<tt>matr1.to_a() -> anArray</tt><br>
MISSING<br>
This method returns an array of GSL::Vector_complex elements, representing the
rows of matr1.
<p>
<a name="_load_data"></a>
<tt>GSL::Matrix_complex#_load_data</tt>&nbsp; (mutating)<br>
<tt>matr1._load_data(anArray) -> aBool</tt><br>
MISSING<br>
anArray is an array of GSL::Vector_complex elements, representing the rows of
the allocated matrix matr1.

<h4>Reading and writing matrices</h4>
The library provides functions for reading and writing matrices to a
file as binary data or formatted text.
<p>
<a name="fwrite"></a>
<tt>GSL::Matrix_complex#fwrite</tt><br>
<tt>matr1.fwrite(f)</tt><br>
This function writes the elements of the matrix m to the stream <tt>f</tt> in
binary format. An exception is raised if there
was a problem writing to the file. Since the data is written in the native
binary format it may not be portable between different architectures.
<p>
<a name="fread"></a>
<tt>GSL::Matrix_complex#fread</tt><br>
<tt>matr1.fread(f)</tt><br>
This function reads into the matrix m from the open stream <tt>f</tt> in binary
format. The matrix m must be preallocated with the correct dimensions
since the function uses the size of m to determine how many bytes to
read. 
An exception is raised if there was a problem reading from the file. 
The data is assumed to have been written
in the native binary format on the same architecture.
<p>
<a name="fprintf"></a>
<tt>GSL::Matrix_complex#fprintf</tt><br>
<tt>matr1.fprintf(f, format)</tt><br>
This function writes the elements of the matrix
m line-by-line to the stream <tt>f</tt> using the format specifier 
<tt>format</tt>,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. 
An exception is raised if there was a problem writing to the file.
<p>
<a name="printf"></a>
<tt>GSL::Matrix_complex#printf</tt><br>
<tt>matr1.printf(format)</tt><br>
This function writes the elements of the matrix
m line-by-line to the standard output using the format specifier 
<tt>format</tt>,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. 
An exception is raised if there was a problem writing to stdout.
<p>
<p>
<a name="fscanf"></a>
<tt>GSL::Matrix_complex#fscanf</tt><br>
<tt>matr1.fscanf(f)</tt><br>
This function reads formatted data from the stream stream into the matrix
m. The matrix m must be preallocated with the correct dimensions since the
function uses the size of m to determine how many numbers to read. 
An exception is raised if there was a problem reading from the file.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"
include GSL

m1 = Matrix.new([0,1,2],[1,2,3]).to_complex
File.open("matr1_complex.dat","w"){|f| m1.fwrite(f) }
m2 = Matrix.new(2,3).to_complex
File.open("matr1_complex.dat"){|f| m2.fread(f) }
assert m1 == m2

File.open("matr2_complex.dat","w"){|f| m1.fprintf(f," %g") }
m3 = Matrix.new(2,3).to_complex
File.open("matr2_complex.dat"){|f| m3.fscanf(f) }
m1.printf("%g")
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Matrix_complex views</h4>
A matrix view is a temporary object, stored on the stack, which can
be used to operate on a subset of matrix elements. Matrix_complex views can be
defined for both constant and non-constant matrices using separate types
that preserve constness. A matrix view has the type gsl_matrix_view and
a constant matrix view has the type gsl_matrix_const_view. In both cases
the elements of the view can by accessed using the matrix component
of the view object. A pointer gsl_matrix * or const gsl_matrix * can
be obtained by taking the address of the matrix component with the &
operator. In addition to matrix views it is also possible to create
vector views of a matrix, such as row or column views.
<p>
<a name="submatrix"></a>
<tt>GSL::Matrix_complex#submatrix</tt>&nbsp; (non-mutating)<br>
<tt>matr1.submatrix(k1, k2, n1, n2) -> matr2</tt><br>
k1, k2, n1 and n2 are indices.
This function returns a matrix view of a
submatrix of the matrix m. The upper-left element of the submatrix is
the element (k1,k2) of the original matrix. The submatrix has n1 rows
and n2 columns. The physical number of columns in memory given by tda
is unchanged. Mathematically, the (i,j)-th element of the new matrix is
given by,<br>
m'(i,j) = m->data[(k1*m->tda + k1) + i*m->tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL";  include GSL

m1 = Matrix.new([0,1,2,3],
                [1,2,3,4],
        	[2,3,4,5]).to_complex
m2 = m1.submatrix(1,1,2,2)
assert m2 == Matrix.new([2,3],
                        [3,4]).to_complex
m3 = m1.submatrix(0,0,3,3)
assert m3 == Matrix.new([0,1,2],
                        [1,2,3],
			[2,3,4]).to_complex
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<tt>GSL::Matrix_complex#view_array(base, n1, n2</tt> -> matr1<br>
MISSING &nbsp; (see Matrix_complex#set)<br>
<tt>base</tt> is of type Array. n1 and n2 are integers.
This function returns a
matrix view of the array <tt>base</tt>. 
The matrix has n1 rows and n2 columns. The
physical number of columns in memory is also given by n2. Mathematically,
the (i,j)-th element of the new matrix is given by,<br>
m'(i,j) = base[i*n2 + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix_complex#view_array_with_tda(base, n1, n2, tda)</tt> -> matr1<br>
MISSING &nbsp;<br>
This function returns a matrix view of the
array base with a physical number of columns tda which may differ from
corresponding the dimension of the matrix. The matrix has n1 rows and
n2 columns, and the physical number of columns in memory is given by
tda. Mathematically, the (i,j)-th element of the new matrix is given by,<br>
m'(i,j) = base[i*tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix_complex#view_vector(v, n1, n2)</tt> -> matr1<br>
MISSING &nbsp;<br>
v is of type GSL::Vector_complex.
This function returns a matrix view of the vector v. The matrix has
n1 rows and n2 columns. The vector must have unit stride. The physical
number of columns in memory is also given by n2. Mathematically, the
(i,j)-th element of the new matrix is given by,<br>
m'(i,j) = v->data[i*n2 + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<p>
<tt>GSL::Matrix_complex#view_vector_with_tda(v, n1, n2, tda)</tt> -> matr1<br>
MISSING &nbsp;<br>
This function returns a matrix view of the
vector v with a physical number of columns tda which may differ from the
corresponding matrix dimension. The vector must have unit stride. The
matrix has n1 rows and n2 columns, and the physical number of columns
in memory is given by tda. Mathematically, the (i,j)-th element of the
new matrix is given by,<br>
m'(i,j) = v->data[i*tda + j]
where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.
<br>
 % t2h(path + "m4.rb")

<h4>Creating row and column views</h4>
In general there are two ways to access an object, by reference or by copying. 
The functions described in this section create vector views which allow 
access to a row or column of a matrix by reference. Modifying elements of 
the view is equivalent to modifying the matrix, since both the vector view 
and the matrix point to the same memory block.

<a name="row"></a>
<tt>GSL::Matrix_complex#row</tt><br>
<tt>matr1.row(i) -> v1</tt><br>
This method returns v1, of type GSL::Vector_complex, which is a copy of the 
i-th row of the matrix m. It does not copy by reference; it is the
same as Matrix_complex#get_row .
<p>
<a name="column"></a>
<tt>GSL::Matrix_complex#column</tt><br>
<tt>matr1.column(i) -> v1</tt><br>
This method returns v1, of type GSL::Vector_complex, which is a copy of the 
j-th column of the matrix m. 
It does not copy by reference; it is the same as Matrix_complex#get_column .

<p>
<a name="diagonal"></a>
<tt>GSL::Matrix_complex#diagonal</tt><br>
<tt>m1.diagonal() -> v1</tt><br>
This method returns v1, of type GSL::Vector_complex, which is a copy of the
diagonal of the matrix m1. 
The matrix m is not required to be square. For a rectangular matrix the
length of the diagonal is the same as the smaller dimension of the matrix.
<p>
<a name="subdiagonal"></a>
<tt>GSL::Matrix_complex#subdiagonal</tt><br>
<tt>m1.subdiagonal(k) -> v1</tt><br>
k in an integer.<br>
This method returns v1, of type GSL::Vector_complex, which is a copy 
of the k-th subdiagonal of the matrix m. The matrix m is not required
to be square. The diagonal of the matrix corresponds to k = 0.
<p>
<a name="superdiagonal"></a>
<tt>GSL::Matrix_complex#superdiagonal</tt><br>
<tt>m1.superdiagonal(k) -> v1</tt><br>
This method returns v1, of type GSL::Vector_complex, which is a copy 
of the k-th superdiagonal of the matrix m. The matrix m is not required
to be square. The diagonal of the matrix corresponds to k = 0.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

m1 = Matrix_complex.new([0,0, 1,0], [1,0, 0,0])

assert m1.row(0) == Vector_complex.new([0,0, 1,0])
m4 = Matrix_complex.new([7,8, 9,10], [11,12, 13,14])
assert m4.row(0) == Vector_complex.new([7,8, 9,10])
assert m4.row(1) == Vector_complex.new([11,12, 13,14])
assert m4.col(0) == Vector_complex.new([7,8, 11,12])
assert m4.col(1) == Vector_complex.new([9,10, 13,14])
assert m4.diagonal == Vector_complex.new([7,8, 13,14])
assert m4.subdiagonal(0) == Vector_complex.new([7,8, 13,14])
assert m4.subdiagonal(1) == Vector_complex.new([11,12])
assert m4.superdiagonal(1) == Vector_complex.new([9,10])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Copying matrices</h4>
<p>
<a name="clone"></a>
<tt>GSL::Matrix_complex#clone</tt><br>
<tt>matr1.clone() -> matr2</tt><br>
matr2 is a copy of matr1.
<p>
<a name="swap"></a>
<tt>GSL::Matrix_complex#swap</tt><br>
<tt>matr1.swap(matr2) -> aMatrix_complex</tt><br>
This function exchanges the elements of the matrices matr1 and matr2 
by copying.  The two matrices must have the same size.
<br>
 % t2h(path + "m6.rb")

<h4>Copying rows and columns</h4>
The functions described in this section copy a row or column of a matrix
into a vector. This allows the elements of the vector and the matrix to
be modified independently. Note that if the matrix and the vector point
to overlapping regions of memory then the result will be undefined. The
same effect can be achieved with more generality using gsl_vector_memcpy
with vector views of rows and columns.
<p>
<a name="get_row"></a>
<tt>GSL::Matrix_complex#get_row</tt><br>
<tt>matr1.get_row(i) -> v1</tt><br>
Matrix_complex#get_row is an alias of Matrix_complex#row .
<p>
<a name="get_column"></a>
<a name="get_col"></a>
<tt>GSL::Matrix_complex#get_col</tt>&nbsp; (alias)<br>
<tt>matr1.get_column(i) -> v1</tt><br>
Matrix_complex#get_row is an alias of Matrix_complex#row .
<p>
<a name="set_row"></a>
<tt>GSL::Matrix_complex#set_row</tt><br>
<tt>matr1.set_row(i, v1) -> aMatrix_complex</tt><br>
This method copies the elements of the vector v1, of type GSL::Vector_complex,
into the i-th row of the matrix matr1. 
The length of the vector must be the same as the length of the row.
<p>
<a name="set_col"></a>
<tt>GSL::Matrix_complex#set_col</tt><br>
<tt>matr1.set_col(i, v1) -> aMatrix_complex</tt><br>
This method copies the elements of the vector v1, of type GSL::Vector_complex,
into the i-th column of the matrix matr1. 
The length of the vector must be the same as the length of the column.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

m0 = Matrix_complex.new([1,0, 0,0], [0,0, 1,0])

m0d = m0.clone
m0d.set_row(0, Vector_complex.new([7,8, 13,14]))
assert m0d == Matrix_complex.new([7,8, 13,14], [0,0, 1,0])
m0d = m0.clone
m0d.set_col(1, Vector_complex.new([7,8, 13,14]))
assert m0d == Matrix_complex.new([1,0, 7,8], [0,0, 13,14])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Exchanging rows and columns</h4>
The following functions can be used to exchange the rows and columns of
a matrix.
<p>
<a name="swap_rows"></a>
<tt>GSL::Matrix_complex#swap_rows</tt><br>
<tt>matr1.swap_rows(i, j) -> matr2</tt><br>
This method returns a matrix with the i-th and j-th rows exchanged.
<p>
<a name="swap_rows!"></a>
<tt>GSL::Matrix_complex#swap_rows!</tt><br>
<tt>matr1.swap_rows!() -> matr2</tt><br>
Mutating version.
This method exchanges the i-th and j-th rows of the matrix m in-place.
<p>
<a name="swap_rowcol"></a>
<tt>GSL::Matrix_complex#swap_rowcol</tt><br>
<tt>matr1.swap_rowcol(i, j) -> matr2</tt><br>
This method returns a matrix with the i-th row and j-th column of matr1
exchanged.
<p>
<a name="swap_rowcol!"></a>
<tt>GSL::Matrix_complex#swap_rowcol!</tt><br>
<tt>matr1.swap_rowcol!(i, j) -> matr2</tt><br>
Mutating version.
This method exchanges the i-th row and j-th column of matr1 .
The matrix must be square for this operation to be possible.
<p>
<a name="transpose_memcpy"></a>
<a name="transpose"></a>
<tt>GSL::Matrix_complex#transpose_memcpy</tt><br>
<tt>GSL::Matrix_complex#transpose</tt>&nbsp; (alias)<br>
<tt>GSL::Matrix_complex#t</tt>&nbsp; (alias)<br>
<tt>matr1.t -> matr2</tt><br>
This method makes a copy of the transpose of the matrix matr1.
src by copying the elements of src into dest. 
It works on all matrices.
<p>
<a name="transpose!"></a>
<tt>GSL::Matrix_complex#transpose!</tt><br>
<tt>matr1.transpose!() -> matr2</tt><br>
Mutating version, but working only on square matrices.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

m0 = Matrix_complex.new([1,0, 0,0], [0,0, 1,0])
m1 = Matrix_complex.new([0,0, 1,0], [1,0, 0,0])
m2 = Matrix_complex.new([0,0, 0,-1],[0,1, 0,0])

m0d = m0.clone; m1d = m1.clone
m0d.swap(m1d); assert m0d == m1 &amp;&amp; m1d == m0

assert m1.swap_rows(0,1) == m0
m1d = m1.clone; m1d.swap_rows!(0,1);	assert m1d == m0
assert m2.swap_cols(0,1) == Matrix_complex.new([0,-1, 0,0],[0,0, 0,1])
m2d = m2.clone; m2d.swap_cols!(0,1)
assert m2d == Matrix_complex.new([0,-1, 0,0],[0,0, 0,1])

m4 = Matrix_complex.new([1,2, 3,4], [5,6, 7,8])
assert m4.swap_rowcol(1,1) == Matrix_complex.new([1,2, 5,6],[3,4, 7,8])
m4d = m4.clone; m4d.swap_rowcol!(1,1)
assert m4d == Matrix_complex.new([1,2, 5,6],[3,4, 7,8])
assert m4.t == Matrix_complex.new([1,2, 5,6],[3,4, 7,8])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Matrix_complex operations</h4>
The following operations are only defined for real matrices.
<p>
<a name="add"></a>
<a name="+"></a>
<tt>GSL::Matrix_complex#add</tt><br>
<tt>GSL::Matrix_complex#+</tt>&nbsp; (alias)<br>
<tt>matr1.add(matr2) -> matr3</tt><br>
This method returns the sum of the matrices matr1 + matr2.
The two matrices must have the same dimensions.
<p>
<a name="add!"></a>
<tt>GSL::Matrix_complex#add!</tt><br>
<tt>matr1.add!(matr2) -> matr3</tt><br>
Mutating version.
<p>
<a name="sub"></a>
<a name="-"></a>
<tt>GSL::Matrix_complex#sub</tt><br>
<tt>GSL::Matrix_complex#-</tt>&nbsp; (alias)<br>
<tt>matr1.sub(matr2) -> matr3</tt><br>
This method returns the difference of the matrices matr1 - matr2.
The two matrices must have the same dimensions.
<p> 
<a name="sub!"></a> 
<tt>GSL::Matrix_complex#sub!</tt><br> 
<tt>matr1.sub!(matr2) -> matr3</tt><br>
Mutating version. 
<p>
<a name="mul_elements"></a>
<tt>GSL::Matrix_complex#mul_elements</tt><br>
<tt>matr1.mul_elements(matr2) -> matr3</tt><br>
This method multiplies the elements of matrix matr1 by the elements of 
matrix matr2, matr3(i,j) = matr1(i,j) * matr2(i,j). 
The two matrices must have the same dimensions.
<p>
<a name="div_elements"></a>
<tt>GSL::Matrix_complex#div_elements</tt><br>
<tt>matr1.div_elements(matr2) -> matr3</tt><br>
This method divides the elements of matrix matr1 by the elements of 
matrix matr2, matr3(i,j) = matr1(i,j) / matr2(i,j). 
The two matrices must have the same dimensions.
<p>
<a name="scale"></a>
<tt>GSL::Matrix_complex#scale</tt><br>
<tt>matr1.scale(x) -> matr2</tt><br>
<tt>matr1 * x -> matr2</tt>&nbsp; (alias)<br>
x is a complex.
This method multiplies the elements of matrix matr1 by the constant factor x,
matr2(i,j) = x matr1(i,j).
<p>
<a name="*"></a>
<tt>GSL::Matrix_complex#*</tt><br>
<tt>matr1 * x -> matr2</tt>&nbsp; (alias)<br>
x is GSL::Complex, real, GSL::Matrix or GSL::Vector. 
<p>
<a name="scale!"></a>
<tt>GSL::Matrix_complex#scale!</tt><br>
<tt>matr1.scale!(x) -> matr2</tt><br>
Mutating method.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require 'foo'
require "GSL"; include GSL
require 'gsl_util'

I = Complex.new2(0,1)
m0 = Matrix_complex.new([1,0, 0,0], [0,0, 1,0])
m1 = Matrix_complex.new([0,0, 1,0], [1,0, 0,0])
m2 = Matrix_complex.new([0,0, 0,-1],[0,1, 0,0])
m3 = Matrix_complex.new([1,0, 0,0], [0,0, -1,0])

assert m0 + m2 == Matrix_complex.new([1,0, 0,-1], [0,1, 1,0])
m0_dup = m0.clone; m0_dup.add!(m2);	assert m0 + m2 == m0_dup

assert m0_dup - m2 == m0
m0_dup.sub!(m2);			 assert m0_dup == m0

m4 = Matrix_complex.new([1,2, 3,4], [5,6, 7,8])
assert m2.mul_elements(m4) == Matrix_complex.new([0,0, 4,-3], [-6,5, 0,0])
m2_dup = m2.clone;m2_dup.mul_elements!(m4); assert m2_dup == m2.mul_elements(m4)

assert m2_dup.div_elements(m4) =~ m2
m2_dup.div_elements!(m4);		 assert m2_dup =~ m2

assert m0.scale(I) == Matrix_complex.new([0,1, 0,0], [0,0, 0,1])
assert m1 * 2 == Matrix_complex.new([0,0, 2,0], [2,0, 0,0])
m0_dup = m0.clone; m0_dup.scale!(I)
assert m0_dup == Matrix_complex.new([0,1, 0,0], [0,0, 0,1])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h4>Matrix_complex properties</h4>
<a name="isnull"></a>
<tt>GSL::Matrix_complex#isnull</tt><br>
<tt>matr1.isnull() -> anInteger</tt><br>
This method returns 1 if all the elements of the matrix m are zero, 
and 0 otherwise.
<br>
 % t2h(path + "m10.rb")

<h4>BLAS Support</h4>

<a name="mult"></a>
<tt>GSL::Matrix_complex#mult</tt><br>
<tt>matr1.mult(matr2) -> matr3</tt><br>
<tt>matr1 * matr2 -> vect2</tt>&nbsp; (alias)<br>
This method returns the matrix product 
matr3(i,j) = \sum_k matr1(i,k) matr2(k,j)
<p>
<a name="mult_vect"></a>
<tt>GSL::Matrix_complex#mult_vect</tt><br>
<tt>matr1.mult_vect(vect1) -> vect2</tt><br>
<tt>matr1 * vect1 -> vect2</tt>&nbsp; (alias)<br>
This method returns the matrix product
vect2(i) = \sum_j matr1(i,j) vect1(j)
<br>
 % t2h(path + "m11.rb")


<h4>Other functions added</h4>
<p>
<a name="negative"></a>
<tt>GSL::Matrix_complex::negative</tt><br>
<tt>GSL::Matrix_complex::-@</tt><br>
<tt>-matr1 -> matr2</tt><br>
This method gives the negative of the matrix.
<p>
<a name="perm"></a>
<tt>GSL::Matrix_complex::perm</tt><br>
<tt>Matrix_complex::perm(perm1) -> matr1</tt><br>
perm1 has type Permutation; this method returns the corresponding matrix P.
The permutation matrix P is encoded in the permutation perm1. 
The j-th column of the matrix P is given by the k-th column of the identity 
matrix, where k = perm_j the j-th element of the permutation vector.


<h4>References and Further Reading</h4>

The block, vector and matrix objects in GSL follow the valarray model of C++. 
A description of this model can be found in the following reference,

B. Stroustrup, The C++ Programming Language (3rd Ed), 
Section 22.4 Vector Arithmetic. Addison-Wesley 1997, ISBN 0-201-88954-4.

    
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="matrix.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex Matrices</td> 
</tr></tbody></table><hr></body>
</html>
