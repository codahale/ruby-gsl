<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Complex Vectors</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="matrix.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="vector.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex Vectors</td> 
</tr></tbody></table><hr>
<h1>
Complex Vectors</h1>
<ul>
<li><a href="#l1">Complex Vectors in GSL</a>
<li><a href="#l2">Class Vector_Complex</a>
<li><a href="#l3">Vector_complex instance methods</a>
<hr>

<a name="l1"></a>
<h2>Complex Vectors in GSL</h2>
Complex Vectors are defined by a gsl_vector structure which describes 
a slice of a 
block. Different vectors can be created which point to the same block.
A vector slice is a set of equally-spaced elements of an area of memory.
<p>
The gsl_vector structure contains five components, the size, the stride,
a pointer to the memory where the elements are stored, data, a pointer 
to the block owned by the vector, block, if any, and an ownership flag, 
owner. The structure is very simple and looks like this,
<pre>
typedef struct
{
  size_t size;
  size_t stride;
  double * data;
  gsl_block_complex * block;
  int owner;
} gsl_vector_complex;
</pre>
The size is simply the number of vector elements. The range of valid indices 
runs from 0 to size-1. The stride is the step-size from one element to the 
next in physical memory, measured in units of the appropriate datatype. 
The pointer data gives the location of the first element of the vector 
in memory. The pointer block stores the location of the memory block in 
which the vector elements are located (if any). If the vector owns this 
block then the owner field is set to one and the block will be deallocated 
when the vector is freed. If the vector points to a block owned by another 
object then the owner field is zero and any underlying block will not be 
deallocated.
	  
<a name="l2"></a>	  
<h2>Class Vector_complex</h2>
The elements of the class GSL::Vector_complex have type GSL::Complex.
<h3>Class methods</h3>
<a href="#alloc">alloc</a> ,&nbsp
<a href="#new">new</a> ,&nbsp
<a href="#new2">new2</a> ,&nbsp
<p>
<a name="new"></a>
<tt>GSL::Vector_complex::new</tt><br>
<tt>GSL::Vector_complex::alloc</tt>&nbsp; (alias)<br>
<tt>Vector_complex.new(x) -> vect1</tt><br>
If x is a number, a vector of dimension x is allocated; if it is of 
class Array of the form
[r0,i0, r1, i1,...]
a vector is initialized with the elements of r0 + i i0, r1 + i i1, ...
<p>
<a name="new2"></a>
<tt>GSL::Vector_complex::new2</tt><br>
<tt>Vector_complex.new(x) -> vect1</tt><br>
If x = c1,c2,...  where c1,c2,... are complex numbers,
this method initializes a vector with c1, c2,...<br>
If x = n, c, with n integer and c has type GSL::Complex, 
it initializes a vector with n copies c.

<h3>Example</h3>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

a = GSL::Complex.new2(5.12, 6)
b = GSL::Complex.new2(3,4)
c = GSL::Complex.new2(1,1.1)
v1 = Vector_complex.new([5.12,6, 3,4])
v2 = Vector_complex.new2(a,b)
assert v2 == v1
v3 = Vector_complex.new(2)
assert v3 == Vector_complex.new([0,0, 0,0])

v4 = Vector_complex.new2(3, c)
assert v4 == Vector_complex.new([1,1.1, 1,1.1, 1,1.1])



</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l3"></a>
<h3>Vector_complex instance methods</h3>
<a href="#+">+</a> ,&nbsp
<a href="#-">-</a> ,&nbsp
<a href="#/">/</a> ,&nbsp
<a href="#[]">[]</a> ,&nbsp
<a href="#==">==</a> ,&nbsp
<a href="#add">add</a> ,&nbsp
<a href="#add!">add!</a> ,&nbsp
<a href="#add_const">add_const</a> ,&nbsp
<a href="#add_const!">add_const!</a> ,&nbsp
<a href="#clone">clone</a> ,&nbsp
<a href="#div">div</a> ,&nbsp
<a href="#dub">dub</a> ,&nbsp
<a href="#each">each</a> ,&nbsp
<a href="#equal">equal ,&nbsp
<a href="#float_equal">float_equal ,&nbsp
<a href="#fprintf">fprintf</a> ,&nbsp
<a href="#fread">fread</a> ,&nbsp
<a href="#fscanf">fscanf</a> ,&nbsp
<a href="#fwrite">fwrite</a> ,&nbsp
<a href="#get">get</a> ,&nbsp
<a href="#inspect">inspect</a> ,&nbsp
<a href="#isnull">isnull</a> ,&nbsp
<a href="#memcpy">memcpy</a> ,&nbsp
<a href="#min">min</a> ,&nbsp
<a href="#min_index">min_index</a> ,&nbsp
<a href="#mul">mul</a> ,&nbsp
<a href="#mul!">mul!</a> ,&nbsp
<a href="#owner">owner</a> ,&nbsp
<a href="#print">print</a> ,&nbsp
<a href="#printf">printf</a> ,&nbsp
<a href="#reverse!">reverse!</a> ,&nbsp
<a href="#scale">scale</a> ,&nbsp
<a href="#scale!">scale!</a> ,&nbsp
<a href="#set1">set1</a> ,&nbsp
<a href="#set_all">set_all</a> ,&nbsp
<a href="#set_basis">set_basis</a> ,&nbsp
<a href="#set_basis!">set_basis!</a> ,&nbsp
<a href="#set_zero">set_zero</a> ,&nbsp
<a href="#size">size</a> ,&nbsp
<a href="#stride">stride</a> ,&nbsp
<a href="#sub!">sub!</a> ,&nbsp
<a href="#subvector">subvector</a> ,&nbsp
<a href="#subvector_with_stride">subvector_with_stride</a> ,&nbsp
<a href="#swap">swap</a> ,&nbsp
<a href="#swap_elements">swap_elements</a> ,&nbsp
<a href="#to_a">to_a</a> ,&nbsp
<a href="#to_complex">to_complex</a> ,&nbsp
<a href="#to_gv">to_gv</a> ,&nbsp
<a href="#to_v">to_v</a>&nbsp

<h4>Accessing vector elements</h4>
Unlike FORTRAN compilers, C compilers do not usually provide support for
range checking of vectors and matrices. Range checking is available in
the GNU C Compiler extension checkergcc but it is not available on every
platform. The functions Vector_complex::get and Vector_complex::set can perform
portable range checking for you and report an error if you attempt to
access elements outside the allowed range.

The functions for accessing the elements of a vector or matrix are defined
in `gsl_vector.h' and declared extern inline to eliminate function-call
overhead. 
If necessary you can turn off range checking completely
without modifying any source files by recompiling your program with
the preprocessor definition GSL_RANGE_CHECK_OFF. Provided your compiler
supports inline functions the effect of turning off range checking is to
replace calls to Vector_complex::get(v,i) by v->data[i*v->stride] and calls
to Vector_complex_set(v,i,x) by v->data[i*v->stride]=x. Thus there should
be no performance penalty for using the range checking functions when
range checking is turned off.
<p>
<a name="get"></a>
<tt>GSL::Vector_complex#get</tt><br>
<a name="[]"></a>
<tt>GSL::Vector_complex#[]</tt>&nbsp; (alias)<br>
<tt>vect1.get(i) -> d1</tt><br>
i is an index.
This function returns the i-th element of a vector v. If i lies outside
the allowed range of 0 to n-1 then an exception is raised.
<p>
<a name="set1"></a>
<tt>GSL::Vector_complex#set1</tt>&nbsp;(mutating)<br>
<tt>GSL::Vector_complex#[]=</tt>&nbsp; (alias)<br>
vect1.set1(i, x) -> vect1</tt><br>
vect1[i] = x<br>
integer i >= 0, GSL::Complex x<br>
<p>
<h4>Initializing vector elements</h4>
<a name="set_all"></a>
<tt>GSL::Vector_complex#set_all</tt>&nbsp;(mutating)<br>
vect1.set_all(x) -> vect2</tt><br>
x is a double.
This function sets all the elements of the vector vect1 to the value x and 
returns it.
<p>
<a name="set_zero"></a>
<tt>GSL::Vector_complex#set_zero</tt><br>
vect1.set_zero() -> vect2</tt><br>
This function sets all the elements of the vector v to zero and returns it.
<p>
<a name="set_basis"></a>
<tt>GSL::Vector_complex#set_basis</tt><br>
vect1.set_basis(i) -> vect2</tt><br>
i is an index.
This function makes a basis vector by setting all the elements of the 
vector v to zero except for the i-th element which is set to one.
<p>
<a name="set_basis!"></a>
<tt>GSL::Vector_complex#set_basis!</tt><br>
Mutating version.
<p>
<a name="isnull"></a>
<tt>GSL::Vector_complex#isnull</tt><br>
Return2 1 if the vector is null, zero otherwise.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

b = GSL::Complex.new2(3,4)
v1 = Vector_complex.new([5.12,6,3,4])
assert v1.size == 2
c = v1[1]
assert c == b

v1[1] = Complex.new2(8,9)
assert v1 == Vector_complex.new([5.12,6,8,9])
v2 = Vector_complex.new(2)
v2.set_all([3,2])
assert v2 == Vector_complex.new([3,2,3,2])
v2.set_zero
assert v2 == Vector_complex.new([0,0,0,0])
assert v2.isnull == 1 &amp;&amp; v1.isnull == 0
v3 = v2.set_basis(1)
assert v3 == Vector_complex.new([0,0, 1,0]) &amp;&amp; v3 != v2
v2.set_basis!(1)
assert v3 == v2

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Reading and writing vectors</h4>
The library provides functions for reading and writing vectors to a file
as binary data or formatted text.
<p>
<a name="fwrite"></a>
<tt>GSL::Vector_complex#fwrite</tt><br>
vect1.fwrite(f) -> status</tt><br>
writes the elements of the vector vect1 to the stream f in binary format.
This function writes the elements of the vector vect1 to the stream  <tt>f</tt>
in binary format. The return value is 0 for success and GSL_EFAILED if there
was a problem writing to the file. Since the data is written in the native
binary format it may not be portable between different architectures.
<p>
<a name="fread"></a>
<tt>GSL::Vector_complex#fread</tt><br>
vect1.fread(f) -> status</tt><br>
This function reads into the vector v from the open stream stream in binary
format. The vector v must be preallocated with the correct length since
the function uses the size of v to determine how many bytes to read. The
return value is 0 for success and GSL_EFAILED if there was a problem
reading from the file. The data is assumed to have been written in the
native binary format on the same architecture.
<p>
<a name="fprintf"></a>
<tt>GSL::Vector_complex#fprintf</tt><br>
vect1.fprintf(f) -> status</tt><br>
This function writes the elements of the vector
v line-by-line to the stream <tt>f</tt> using the format specifier format,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. The function returns 0 for success and GSL_EFAILED
if there was a problem writing to the file.
<p>
<a name="fscanf"></a>
<tt>GSL::Vector_complex#fscanf</tt><br>
vect1.fscanf(f) -> status</tt><br>
This function reads formatted data from the stream stream into the vector
v. The vector v must be preallocated with the correct length since the
function uses the size of v to determine how many numbers to read. The
function returns 0 for success and GSL_EFAILED if there was a problem
reading from the file.
<p>
<a name="printf"></a>
<tt>GSL::Vector_complex#printf</tt><br>
vect1.printf() -> status</tt><br>
Same as vect1.fprintf(stdout)
<p>

<a name="print"></a>
<tt>GSL::Vector_complex#print</tt><br>
vect1.fprint(f) -> status</tt><br>
This function writes the elements of the vector
<p>
<a name="inspect"></a>
<tt>GSL::Vector_complex#inspect</tt><br>
vect1.inspect(f) -> status</tt><br>
It calls GSL::Vector_complex#print

<a name="each"></a>
<tt>GSL::Vector_complex#each</tt><br>
vect1.each </tt><br>


<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

v = Vector_complex.new([5.12,6,3,4])
v.print

File.open("vect_complex.dump", "w"){|f| v.fwrite(f) }

v1 = Vector_complex.new(2)
File.open("vect_complex.dump", "r"){|f| v1.fread(f) }
assert v == v1

File.open("vector_complex.dat", "w"){|f| v.fprintf f, "%.5g" }
v2 = Vector_complex.new(2)
File.open("vector_complex.dat"){|f| v2.fscanf f }
assert v2 == v

v.printf("%.5g")
v.each{|e| print e, "\t"}
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Vector_complex views</h4>

In addition to creating vectors from slices of blocks it is also possible
to slice vectors and create vector views. For example, a subvector of
another vector can be described with a view, or two views can be made
which provide access to the even and odd elements of a vector.

A vector view is a temporary object, stored on the stack, which can
be used to operate on a subset of vector elements. Vector_complex views can be
defined for both constant and non-constant vectors, using separate types
that preserve constness. A vector view has the type gsl_vector_view and
a constant vector view has the type gsl_vector_const_view. In both cases
the elements of the view can be accessed as a gsl_vector using the vector
component of the view object. A pointer to a vector of type gsl_vector
* or const gsl_vector * can be obtained by taking the address of this
component with the & operator.
<p>
<a name="subvector"></a>
<tt>GSL::Vector_complex#subvector</tt>&nbsp; (non-mutating)<br>
vect1.subvector(offset, n) -> vect2</tt><br>
offset and n are integers.
This function returns a subvector of another vector v. 
The start of the new vector is offset by offset elements
from the start of the original vector. The new vector has n
elements. Mathematically, the i-th element of the new vector v'
is given by,<br>
v'(i) = v->data[(offset + i)*v->stride]
where the index i runs from 0 to n-1.
<p>
<a name="subvector_with_stride"></a>
<tt>GSL::Vector_complex#subvector_with_stride</tt><br>
vect1.subvector_with_stride(offset, stride, n) -> vect2</tt><br>
This function returns a vector view of a subvector of another
vector v with an additional stride argument. The subvector
is formed in the same way as for subvector but the 
new vector has n elements with a step-size of stride from one
element to the next in the original vector. Mathematically,
the i-th element of the new vector v' is given by,<br>
 v'(i) = v->data[(offset + i*stride)*v->stride]
  where the index i runs from 0 to n-1. 
<p>
<tt>GSL::Vector_complex#real</tt><br>
<tt>v.real -> v1</tt><br>
This method returns the real part of the complex vector v.
<p>
<tt>GSL::Vector_complex#imag</tt><br>
<tt>v.imag -> v1</tt><br>
This method returns the imaginary part of the complex vector v.
<p>
<tt>GSL::Vector_complex#_view_array</tt><br>
MISSING (see GSL::Vector_complex::new)<br>
This functions returns a vector view
of an array. The start of the new vector is given by base and has n
elements. Mathematically, the i-th element of the new vector v' is
given by,<br>
v'(i) = base[i]
where the index i runs from 0 to n-1.
<p>
<tt>GSL::Vector_complex#_view_array_with_stride</tt><br>
MISSING<br>
This function returns a vector view of an array
base with an additional stride argument. The subvector is formed in the
same way as for gsl_vector_view_array but the new vector has n elements
with a step-size of stride from one element to the next in the original
array. Mathematically, the i-th element of the new vector v' is given by,<br>
v'(i) = base[i*stride]
where the index i runs from 0 to n-1.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

v = Vector_complex.new([1,0, 2,3])
assert v.real == Vector.new([1, 2])
assert v.imag == Vector.new([0, 3])

v1_real = Vector.new((0..9).to_a)
v1 = v1_real.to_complex
v2 = v1.subvector(4,3)
assert v2 = Vector_complex.new([4,0, 5,0, 6,0])

v3 = v1.subvector_with_stride(4,2,3)
assert v3 == Vector_complex.new([4,0, 6,0, 8,0])
v4 = v1.subvector_with_stride(0, 2, v1.size/2.0)
assert v4 == Vector_complex.new([0,0, 2,0, 4,0, 6,0, 8,0])
v5 = v1.subvector_with_stride(1, 2, v1.size/2.0)
assert v5 == Vector_complex.new([1,0, 3,0, 5,0, 7,0, 9,0])
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Copying vectors</h4>

Common operations on vectors such as addition and multiplication
are available in the BLAS part of the library (see section BLAS
Support). However, it is useful to have a small number of utility
functions which do not require the full BLAS code. The following functions
fall into this category.
<p>
<a name="memcpy"></a>
<tt>GSL::Vector_complex::memcpy</tt><br>
<tt>Vector_complex::memcpy(dest, src)</tt><br>
This function copies the elements of the vector src into the vector
dest. The two vectors must have the same length.
<p>
<a name="clone"></a>
<tt>GSL::Vector_complex#clone</tt><br>
vect1.clone() -> vect2</tt><br>
This method returns a copy of vect1 .
<p>
<a name="swap"></a>
<tt>GSL::Vector_complex::swap</tt><br>
swap(v, w)</tt><br>
This function exchanges the elements of the vectors v and w by copying. The
two vectors must have the same length.

<h4>Exchanging elements</h4>
The following function can be used to exchange, or permute, the elements
of a vector.
<p>
<a name="swap_elements"></a>
<tt>GSL::Vector_complex#swap_elements</tt>&nbsp; (mutating)<br>
vect1.swap_elements(i,j) -> vect2</tt><br>
This function exchanges the i-th and j-th elements of the
vector vect1 in-place and returns it.
<p>
<a name="reverse!"></a>
<tt>GSL::Vector_complex#reverse!</tt><br>
vect1.reverse!() -> </tt><br>
This function reverses the order of the elements of the vector vect1.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL

v1 = Vector_complex.new([5.12,6,3,4])

v2 = Vector_complex.new([1,2,3,4])

Vector_complex::swap(v1,v2)
assert v1 == Vector_complex.new([1,2,3,4]) &amp;&amp; v2 == Vector_complex.new([5.12,6,3,4])

v3 = Vector.new((0..3).to_a).to_complex
v3.swap_elements(1,2)
assert v3 = Vector_complex.new([0,0, 2,0, 1,0, 3,0])
v3.reverse!
assert Vector_complex.new([3,0, 1,0, 2,0, 0,0])


</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Vector_complex operations</h4>
The following operations are only defined for real vectors.
<p>
<a name="add"></a>
<tt>GSL::Vector_complex#add</tt>&nbsp; (non-mutating)<br>
<tt>GSL::Vector_complex#+</tt>&nbsp; (alias)<br>
<tt>a.add(b) -> vect1</tt><br>
This function adds the elements of vector b to the elements of vector a,
a'_i = a_i + b_i. The two vectors must have the same length.
<p>
<a name="add!"></a>
<tt>GSL::Vector_complex#add!</tt><br>
<tt>a.add!(b) ->  vect1</tt>&nbsp; (mutating)<br>
This function adds the elements of vector b to the elements of vector a,
a_i = a_i + b_i. The two vectors must have the same length.
<p>
<a name="sub"></a>
<tt>GSL::Vector_complex#sub</tt>&nbsp; (non-mutating)<br>
<tt>GSL::Vector_complex#-</tt>&nbsp; (alias)<br>
<tt>a.add(b) -> a'</tt><br> 
This function subtracts the elements of vector b from the elements of
vector a, a'_i = a_i - b_i. The two vectors must have the same length.
<p>
<a name="sub!"></a>
<tt>GSL::Vector_complex#sub!</tt><br>
<tt>a.sub!() -> </tt>&nbsp; (mutating)<br>
This function multiplies the elements of vector a by the elements of
vector b, a_i = a_i * b_i. The two vectors must have the same length.
<p>
<a name="scale"></a>
<tt>GSL::Vector_complex#scale</tt><br>
<tt>vect1.scale(x) -> vect2</tt><br>
x is a GSL::Complex
This function multiplies the elements of vector a by the constant factor x,
a'_i = x a_i.
<p>
<a name="scale!"></a>
<tt>GSL::Vector_complex#scale!</tt>&nbsp; (mutating)<br>
<tt>vect1.scale!() -> vect2</tt><br>
<p>
<a name="*"></a>
<tt>vect1 * x -> vect2</tt><br>
GSL::Vector_complex vect1, vect2; x can be a Float, a Fixnum or a GSL::Complex .
If x can be a Float or a Fixnum, it is converted to GSL::Complex, then
GSL::Vector_complex#scale is used.
<p>
<a name="add_const"></a>
<tt>GSL::Vector_complex#add_const</tt><br>
<tt>vect1.add_const(x) -> vect2</tt><br>
This function adds the constant value x to the elements of the vector a,
a'_i = a_i + x.
<p>
<a name="add_const!"></a>
<tt>GSL::Vector_complex#add_const!</tt>&nbsp; (mutating)<br>
<tt>vect1.add_const!(x) -> vect2</tt><br>

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

v1 = Vector_complex.new([1,0,0,1])
v2 = Vector_complex.new([9,9,9,9])
v3 = v1 + v2
assert v3 == Vector_complex.new([10,9,9,10])
v1d = v1.clone
v1d.add!(v2)
assert v1d == v3

v4 = v3 - v2
assert v4 == v1
v3d = v3.clone
v3d.sub!(v2)
assert v3d == v1

v5 = v1 * Complex.new2(2,0)
assert v5 == Vector_complex.new([2,0,0,2])
v1d = v1.clone
v1d.scale!(Complex.new2(2,0))
assert v1d == v5 
v6 = v1 * 2.0
assert v6 == v5

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>
<a name="isnull"></a>
<tt>GSL::Vector_complex#isnull</tt><br>
<tt>vect1.isnull() -> anInteger </tt><br>
This function returns 1 if all the elements of the vector v are zero, 
and 0 otherwise.
<p> 
<a name="equal"></a>
<a name="=="></a>
<tt>GSL::Vector_complex::equal</tt><br>
<tt>GSL::Vector_complex::==</tt>&nbsp; (alias)<br>
<tt>vect1 == vect2 -> aBool</tt><br>
This method returns true if the two methods have all the elements equal.
<p>
<a name="float_equal"></a>
<tt>GSL::Vector_complex::float_equal</tt><br>
<tt>Vector_complex::float_equal(vect1, vect2, eps) -> aBool</tt><br>
eps is a double. This function returns true if abs(vect1(i) - vect2(i)) < eps 
for all elements.
<p>
<a name="to_complex"></a>
<tt>v1.to_complex() -> v2</tt><br>
GSL::Vector v1; GSL::Vector_complex v2<br>
This method returns the GSL::Vector_complex version of a GSL::Vector .

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="matrix.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="vector.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex Vectors</td> 
</tr></tbody></table><hr></body>
</html>
