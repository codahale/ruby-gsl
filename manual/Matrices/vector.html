<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Vectors</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="vector_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Vectors</td> 
</tr></tbody></table><hr>
<h1>
Vectors</h1>
<ul>
<li><a href="#l1">Vectors in GSL</a>
<li><a href="#l2">Class Vector</a>
<li><a href="#l3">Vector instance methods</a>
<hr>
<a name="l1"></a>
<h2>Vectors in GSL</h2>
Vectors are defined by a gsl_vector structure which describes a slice of a 
block. Different vectors can be created which point to the same block.
A vector slice is a set of equally-spaced elements of an area of memory.
<p>
The gsl_vector structure contains five components, the size, the stride,
a pointer to the memory where the elements are stored, data, a pointer 
to the block owned by the vector, block, if any, and an ownership flag, 
owner. The structure is very simple and looks like this,
<pre>
typedef struct
{
  size_t size;
  size_t stride;
  double * data;
  gsl_block * block;
  int owner;
} gsl_vector;
</pre>
The size is simply the number of vector elements. The range of valid indices 
runs from 0 to size-1. The stride is the step-size from one element to the 
next in physical memory, measured in units of the appropriate datatype. 
The pointer data gives the location of the first element of the vector 
in memory. The pointer block stores the location of the memory block in 
which the vector elements are located (if any). If the vector owns this 
block then the owner field is set to one and the block will be deallocated 
when the vector is freed. If the vector points to a block owned by another 
object then the owner field is zero and any underlying block will not be 
deallocated.
	  
<a name="l2"></a>	  
<h2>Class Vector</h2>
The elements of the class Vector are doubles.
<h3>Class methods</h3>
<a href="#alloc">alloc</a> ,&nbsp
<a href="#calloc">calloc</a> ,&nbsp
<a href="#new">new</a> ,&nbsp
<p>
<a name="new"></a>
<tt>GSL::Vector::new</tt><br>
<tt>GSL::Vector::alloc</tt>&nbsp; (alias)<br>
<tt>Vector.new(x) -> vect1</tt><br>
If x is a number, a vector of dimension x is allocated; if it is of 
class Array, a vector is initialized with the elements of x.
<p>
<a name="calloc"></a>
<tt>GSL::Vector::calloc</tt><br>
<tt>Vector.calloc(n) -> vect1</tt><br>
This function allocates memory for a vector of length n and initializes 
all the elements of the vector to zero.

<h3>Example</h3>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"
include GSL

puts "new(x), x integer"
v = Vector.new 4
0.upto(3) do |i|
  v.set i, 1.23 + i
end
0.upto(3) { |i| print v[i], "\t" }

puts "\nnew(x), x array"
ary = [2, 7.1, 3, 2.5]
v = Vector.new(ary)
0.upto(3) { |i| print v[i], "\t" }

puts "\ncalloc"
v = Vector.calloc(4)
0.upto(3) { |i| print v[i], "\t" }
v.inspect
p v


</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="l3"></a>
<h3>Vector instance methods</h3>
<a href="#+">+</a> ,&nbsp
<a href="#-">-</a> ,&nbsp
<a href="#/">/</a> ,&nbsp
<a href="#[]">[]</a> ,&nbsp
<a href="#==">==</a> ,&nbsp
<a href="#add">add</a> ,&nbsp
<a href="#add!">add!</a> ,&nbsp
<a href="#add_const">add_const</a> ,&nbsp
<a href="#add_const!">add_const!</a> ,&nbsp
<a href="#clone">clone</a> ,&nbsp
<a href="#div">div</a> ,&nbsp
<a href="#dub">dub</a> ,&nbsp
<a href="#each">each</a> ,&nbsp
<a href="#equal">equal ,&nbsp
<a href="#float_equal">float_equal ,&nbsp
<a href="#fprintf">fprintf</a> ,&nbsp
<a href="#fread">fread</a> ,&nbsp
<a href="#fscanf">fscanf</a> ,&nbsp
<a href="#fwrite">fwrite</a> ,&nbsp
<a href="#get">get</a> ,&nbsp
<a href="#inspect">inspect</a> ,&nbsp
<a href="#isnull">isnull</a> ,&nbsp
<a href="#max">max</a> ,&nbsp
<a href="#max_index">max_index</a> ,&nbsp
<a href="#memcpy">memcpy</a> ,&nbsp
<a href="#min">min</a> ,&nbsp
<a href="#min_index">min_index</a> ,&nbsp
<a href="#minmax">minmax</a> ,&nbsp
<a href="#minmax_index">minmax_index</a> ,&nbsp
<a href="#mul">mul</a> ,&nbsp
<a href="#mul!">mul!</a> ,&nbsp
<a href="#owner">owner</a> ,&nbsp
<a href="#print">print</a> ,&nbsp
<a href="#printf">printf</a> ,&nbsp
<a href="#reverse!">reverse!</a> ,&nbsp
<a href="#scale">scale</a> ,&nbsp
<a href="#scale!">scale!</a> ,&nbsp
<a href="#set">set</a> ,&nbsp
<a href="#set1">set1</a> ,&nbsp
<a href="#set_all">set_all</a> ,&nbsp
<a href="#set_basis">set_basis</a> ,&nbsp
<a href="#set_basis!">set_basis!</a> ,&nbsp
<a href="#set_zero">set_zero</a> ,&nbsp
<a href="#size">size</a> ,&nbsp
<a href="#stride">stride</a> ,&nbsp
<a href="#sub!">sub!</a> ,&nbsp
<a href="#subvector">subvector</a> ,&nbsp
<a href="#subvector_with_stride">subvector_with_stride</a> ,&nbsp
<a href="#swap">swap</a> ,&nbsp
<a href="#swap_elements">swap_elements</a> ,&nbsp
<a href="#to_a">to_a</a> ,&nbsp
<a href="#to_gv">to_gv</a> ,&nbsp
<a href="#to_v">to_v</a>&nbsp

<h4>Accessing vector elements</h4>
Unlike FORTRAN compilers, C compilers do not usually provide support for
range checking of vectors and matrices. Range checking is available in
the GNU C Compiler extension checkergcc but it is not available on every
platform. The functions Vector::get and Vector::set can perform
portable range checking for you and report an error if you attempt to
access elements outside the allowed range.

The functions for accessing the elements of a vector or matrix are defined
in `gsl_vector.h' and declared extern inline to eliminate function-call
overhead. 
If necessary you can turn off range checking completely
without modifying any source files by recompiling your program with
the preprocessor definition GSL_RANGE_CHECK_OFF. Provided your compiler
supports inline functions the effect of turning off range checking is to
replace calls to Vector::get(v,i) by v->data[i*v->stride] and calls
to Vector_set(v,i,x) by v->data[i*v->stride]=x. Thus there should
be no performance penalty for using the range checking functions when
range checking is turned off.
<p>
<a name="get"></a>
<tt>GSL::Vector#get</tt><br>
<a name="[]"></a>
<tt>GSL::Vector#[]</tt>&nbsp; (alias)<br>
<tt>vect1.get(i) -> d1</tt><br>
i is an index.
This function returns the i-th element of a vector v. If i lies outside
the allowed range of 0 to n-1 then an exception is raised.
<p>
<a name="set"></a>
<tt>GSL::Vector#set</tt>&nbsp;(mutating)<br>
vect1.set(arg, x) -> vect1</tt><br>
if arg = i is an index and x a double,
this function sets the value of the i-th element of a vector vect1 to x. 
If i lies outside the allowed range of 0 to n-1 then the error handler 
is invoked.<br>
If arg is of type Array, the vector is initializes with the elements of arg.
<p>
<a name="set1"></a>
<tt>GSL::Vector#set1</tt>&nbsp;(mutating)<br>
<tt>GSL::Vector#[]=</tt>&nbsp; (alias)<br>
vect1.set1(arg, x) -> vect1</tt><br>
vect1[i] = value<br>
integer i >= 0, double value<br>
<p>
<h4>Initializing vector elements</h4>
<a name="set_all"></a>
<tt>GSL::Vector#set_all</tt>&nbsp;(mutating)<br>
vect1.set_all(x) -> vect2</tt><br>
x is a double.
This function sets all the elements of the vector vect1 to the value x and 
returns it.
<p>
<a name="set_zero"></a>
<tt>GSL::Vector#set_zero</tt><br>
vect1.set_zero() -> vect2</tt><br>
This function sets all the elements of the vector v to zero and returns it.
<p>
<a name="set_basis"></a>
<tt>GSL::Vector#set_basis</tt><br>
vect1.set_basis(i) -> vect2</tt><br>
i is an index.
This function makes a basis vector by setting all the elements of the 
vector v to zero except for the i-th element which is set to one.
<p>
<a name="set_basis!"></a>
<tt>GSL::Vector#set_basis!</tt><br>
Mutating version.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

puts "new(x), x integer"
v = Vector.new 4
0.upto(3) do |i|
  v.set i, 1.23 + i
end
0.upto(3) { |i| print v[i], "\t" }

puts "\nset"
v.set(2, 10)
assert v.to_a == [1.23, 2.23, 10, 4.23]
ary = [2, 7.1, 3, 2.5]
v.set(ary)
assert v.to_a ==  [2, 7.1, 3, 2.5]

puts "set_all"
p v.set_all(3)
assert v.to_a == [3,3,3,3]

v.set1(2,7)
assert v.to_a == [3,3,7,3]
v[1] = 8
assert v.to_a == [3,8,7,3]

puts "set_zero"
p v.set_zero
assert v.to_a == [0,0,0,0]

puts "set_basis"
v1 = v.set_basis(2)
assert v.to_a == [0,0,0,0] &amp;&amp; v1.to_a == [0,0,1,0]

puts "set_basis!"
v1 = v.set_basis!(2)
assert v.to_a == [0,0,1,0] &amp;&amp; v1.to_a == [0,0,1,0]
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Reading and writing vectors</h4>
The library provides functions for reading and writing vectors to a file
as binary data or formatted text.
<p>
<a name="fwrite"></a>
<tt>GSL::Vector#fwrite</tt><br>
vect1.fwrite(f) -> status</tt><br>
writes the elements of the vector vect1 to the stream f in binary format.
This function writes the elements of the vector vect1 to the stream  <tt>f</tt>
in binary format. The return value is 0 for success and GSL_EFAILED if there
was a problem writing to the file. Since the data is written in the native
binary format it may not be portable between different architectures.
<p>
<a name="fread"></a>
<tt>GSL::Vector#fread</tt><br>
vect1.fread(f) -> status</tt><br>
This function reads into the vector v from the open stream stream in binary
format. The vector v must be preallocated with the correct length since
the function uses the size of v to determine how many bytes to read. The
return value is 0 for success and GSL_EFAILED if there was a problem
reading from the file. The data is assumed to have been written in the
native binary format on the same architecture.
<p>
<a name="fprintf"></a>
<tt>GSL::Vector#fprintf</tt><br>
vect1.fprintf(f) -> status</tt><br>
This function writes the elements of the vector
v line-by-line to the stream <tt>f</tt> using the format specifier format,
which should be one of the %g, %e or %f formats for floating point numbers
and %d for integers. The function returns 0 for success and GSL_EFAILED
if there was a problem writing to the file.
<p>
<a name="fscanf"></a>
<tt>GSL::Vector#fscanf</tt><br>
vect1.fscanf(f) -> status</tt><br>
This function reads formatted data from the stream stream into the vector
v. The vector v must be preallocated with the correct length since the
function uses the size of v to determine how many numbers to read. The
function returns 0 for success and GSL_EFAILED if there was a problem
reading from the file.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

v1 = Vector.new 4
0.upto(3) do |i|
  v1.set i, 1 + i
end
assert v1.to_a == [1,2,3,4]
File.open("vect.dump", "w"){|f| v1.fwrite(f) }

v2 = Vector.new 4
File.open("vect.dump", "r"){|f| v2.fread(f) }
assert v1.to_a == v2.to_a

v3 = Vector.new([0.3,1])
File.open("vector.dat", "w"){|f| v3.fprintf f, "%.5g" }

v4 = Vector.new 2
File.open("vector.dat"){|f| v4.fscanf f }
assert v4.to_a == [0.3,1]

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Vector views</h4>

In addition to creating vectors from slices of blocks it is also possible
to slice vectors and create vector views. For example, a subvector of
another vector can be described with a view, or two views can be made
which provide access to the even and odd elements of a vector.

A vector view is a temporary object, stored on the stack, which can
be used to operate on a subset of vector elements. Vector views can be
defined for both constant and non-constant vectors, using separate types
that preserve constness. A vector view has the type gsl_vector_view and
a constant vector view has the type gsl_vector_const_view. In both cases
the elements of the view can be accessed as a gsl_vector using the vector
component of the view object. A pointer to a vector of type gsl_vector
* or const gsl_vector * can be obtained by taking the address of this
component with the & operator.
<p>
<a name="subvector"></a>
<tt>GSL::Vector#subvector</tt>&nbsp; (non-mutating)<br>
vect1.subvector(offset, n) -> vect2</tt><br>
offset and n are integers.
This function returns a subvector of another vector v. 
The start of the new vector is offset by offset elements
from the start of the original vector. The new vector has n
elements. Mathematically, the i-th element of the new vector v'
is given by,<br>
v'(i) = v->data[(offset + i)*v->stride]
where the index i runs from 0 to n-1.
<p>
<a name="subvector_with_stride"></a>
<tt>GSL::Vector#subvector_with_stride</tt><br>
vect1.subvector_with_stride(offset, stride, n) -> vect2</tt><br>
This function returns a vector view of a subvector of another
vector v with an additional stride argument. The subvector
is formed in the same way as for subvector but the 
new vector has n elements with a step-size of stride from one
element to the next in the original vector. Mathematically,
the i-th element of the new vector v' is given by,<br>
 v'(i) = v->data[(offset + i*stride)*v->stride]
  where the index i runs from 0 to n-1. 
<p>
<tt>GSL::Vector#_view_array</tt><br>
MISSING (see GSL::Vector::new)<br>
This functions returns a vector view
of an array. The start of the new vector is given by base and has n
elements. Mathematically, the i-th element of the new vector v' is
given by,<br>
v'(i) = base[i]
where the index i runs from 0 to n-1.
<p>
<tt>GSL::Vector#_view_array_with_stride</tt><br>
MISSING<br>
This function returns a vector view of an array
base with an additional stride argument. The subvector is formed in the
same way as for gsl_vector_view_array but the new vector has n elements
with a step-size of stride from one element to the next in the original
array. Mathematically, the i-th element of the new vector v' is given by,<br>
v'(i) = base[i*stride]
where the index i runs from 0 to n-1.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

v1 = Vector.new((0..9).to_a)
v2 = v1.subvector(4,3)
assert v2.to_a == [4.0, 5.0, 6.0] &amp;&amp; v1.to_a == (0..9).to_a
v3 = v1.subvector_with_stride(4,2,3)
assert v3.to_a == [4.0, 6.0, 8.0]
v4 = v1.subvector_with_stride(0, 2, v1.size/2.0)
assert v4.to_a == [0.0, 2.0, 4.0, 6.0, 8.0]
v5 = v1.subvector_with_stride(1, 2, v1.size/2.0)
assert v5.to_a == [1.0, 3.0, 5.0, 7.0, 9.0]


</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Copying vectors</h4>

Common operations on vectors such as addition and multiplication
are available in the BLAS part of the library (see section BLAS
Support). However, it is useful to have a small number of utility
functions which do not require the full BLAS code. The following functions
fall into this category.
<p>
<a name="memcpy"></a>
<tt>GSL::Vector::memcpy</tt><br>
<tt>Vector::memcpy(dest, src)</tt><br>
This function copies the elements of the vector src into the vector
dest. The two vectors must have the same length.
<p>
<a name="clone"></a>
<tt>GSL::Vector#clone</tt><br>
vect1.clone() -> vect2</tt><br>
This method returns a copy of vect1 .
<p>
<a name="swap"></a>
<tt>GSL::Vector::swap</tt><br>
swap(v, w)</tt><br>
This function exchanges the elements of the vectors v and w by copying. The
two vectors must have the same length.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

v1 = Vector.new((0..3).to_a)
v2 = Vector.new(4)
Vector::memcpy(v2, v1)
assert v1.to_a == [0,1,2,3] &amp;&amp; v2.to_a == v1.to_a
v3 = v1.clone
assert v1.to_a == [0,1,2,3] &amp;&amp; v3.to_a == v1.to_a

v4 = Vector.new(4)
Vector::swap(v1,v4)
assert v1.to_a == [0,0,0,0] &amp;&amp; v4.to_a == [0,1,2,3] 
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Exchanging elements</h4>
The following function can be used to exchange, or permute, the elements
of a vector.
<p>
<a name="swap_elements"></a>
<tt>GSL::Vector#swap_elements</tt>&nbsp; (mutating)<br>
vect1.swap_elements(i,j) -> vect2</tt><br>
This function exchanges the i-th and j-th elements of the
vector vect1 in-place and returns it.
<p>
<a name="reverse!"></a>
<tt>GSL::Vector#reverse!</tt><br>
vect1.reverse!() -> </tt><br>
This function reverses the order of the elements of the vector vect1.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

v1 = Vector.new((5..8).to_a)
assert v1.swap_elements(1,2).to_a == [5,7,6,8] &amp;&amp; v1.to_a == [5,7,6,8]

assert v1.reverse!().to_a == [8,6,7,5] &amp;&amp; v1.to_a == [8,6,7,5] 
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
i<h4>Vector operations</h4>
The following operations are only defined for real vectors.
<p>
<a name="add"></a>
<tt>GSL::Vector#add</tt>&nbsp; (non-mutating)<br>
<tt>GSL::Vector#+</tt>&nbsp; (alias)<br>
<tt>a.add(b) -> vect1</tt><br>
This function adds the elements of vector b to the elements of vector a,
a'_i = a_i + b_i. The two vectors must have the same length.
<p>
<a name="add!"></a>
<tt>GSL::Vector#add!</tt><br>
<tt>a.add!(b) ->  vect1</tt>&nbsp; (mutating)<br>
This function adds the elements of vector b to the elements of vector a,
a_i = a_i + b_i. The two vectors must have the same length.
<p>
<a name="sub"></a>
<tt>GSL::Vector#sub</tt>&nbsp; (non-mutating)<br>
<tt>GSL::Vector#-</tt>&nbsp; (alias)<br>
<tt>a.add(b) -> a'</tt><br> 
This function subtracts the elements of vector b from the elements of
vector a, a'_i = a_i - b_i. The two vectors must have the same length.
<p>
<a name="sub!"></a>
<tt>GSL::Vector#sub!</tt><br>
<tt>a.sub!() -> </tt>&nbsp; (mutating)<br>
This function multiplies the elements of vector a by the elements of
vector b, a_i = a_i * b_i. The two vectors must have the same length.
<p>
<a name="div"></a>
<tt>GSL::Vector#div</tt>&nbsp; (non-mutating)<br>
<tt>GSL::Vector#/</tt>&nbsp; (alias)<br>
<tt>a.div(b) -> </tt><br>
This function divides the elements of vector a by the elements of vector b,
a'_i = a_i / b_i. The two vectors must have the same length.
<p>
<a name="div!"></a>
<tt>GSL::Vector#div!</tt>&nbsp; (mutating)<br>
<tt>a.div!(b) -> </tt><br>
<p>
<a name="scale"></a>
<tt>GSL::Vector#scale</tt><br>
<tt>vect1.scale(x) -> vect2</tt><br>
x is a double.
This function multiplies the elements of vector a by the constant factor x,
a'_i = x a_i.
<p>
<a name="scale!"></a>
<tt>GSL::Vector#scale!</tt>&nbsp; (mutating)<br>
<tt>vect1.scale!() -> vect2</tt><br>
<p>
<a name="add_const"></a>
<tt>GSL::Vector#add_const</tt><br>
<tt>vect1.add_const(x) -> vect2</tt><br>
This function adds the constant value x to the elements of the vector a,
a'_i = a_i + x.
<p>
<a name="add_const!"></a>
<tt>GSL::Vector#add_const!</tt>&nbsp; (mutating)<br>
<tt>vect1.add_const!(x) -> vect2</tt><br>

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL

v1 = Vector.new((5..8).to_a)
v2 = Vector.new([1,2,3,8])
v3 = v1 + v2
assert v3.to_a == [6,8,10,16]

v4 = v1.add!(v2)
assert v1.to_a == [6,8,10,16] &amp;&amp;  v4.to_a == [6,8,10,16]

v5 = v1 - v2
assert v5.to_a == [5,6,7,8]

v6 = v1.sub!(v2)
assert v1.to_a == [5,6,7,8] &amp;&amp; v6.to_a == [5,6,7,8]

x = 0.5
v7 = v1.scale(x)
assert v7.to_a == [2.5, 3.0, 3.5, 4.0]
v8 = v1.scale!(x)
assert v1.to_a == [2.5, 3.0, 3.5, 4.0] &amp;&amp; v8.to_a == [2.5, 3.0, 3.5, 4.0]

v9 = v1.add_const(1)
assert v9.to_a ==  [3.5, 4.0, 4.5, 5.0]
v10 = v1.add_const!(1)
assert v1.to_a ==  [3.5, 4.0, 4.5, 5.0] &amp;&amp; v10.to_a ==  [3.5, 4.0, 4.5, 5.0]
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h4>Finding maximum and minimum elements of vectors</h4>
<a name="max"></a>
<tt>GSL::Vector#max</tt><br>
<tt>vect1.max() -> d1</tt><br>
This function returns the maximum value in the vector v.
<a name="min"></a>
<tt>GSL::Vector#min</tt><br>
<tt>vect1.min() -> d1</tt><br>
This function returns the minimum value in the vector v.
<p>
<a name="minmax"></a>
<tt>GSL::Vector#minmax</tt><br>
<tt>vect1.minmax() -> anArray</tt><br>
This function returns the minimum and maximum values
in the vector v, storing them in the Array object containing the
doubles min and max.
<p>
<a name="max_index"></a>
<tt>GSL::Vector#max_index</tt><br>
<tt>vect1.max_index() -> anIndex</tt><br>
This function
returns the index of the maximum value in the vector v. When there are
several equal maximum elements then the lowest index is returned.
<p>
<a name="min_index"></a>
<tt>GSL::Vector#min_index</tt><br>
<tt>vect1.min_index() -> anIndex</tt><br>
This function
returns the index of the minimum value in the vector v. When there are
several equal minimum elements then the lowest index is returned.
<p>
<a name="minmax_index"></a>
<tt>GSL::Vector#minmax_index</tt><br>
<tt>vect1.minmax_index() -> anArray</tt><br>
This function returns the indices of the minimum
and maximum values in the vector v, storing them in imin and imax. When
there are several equal minimum or maximum elements then the lowest
indices are returned.
<p>
<a name="isnull"></a>
<tt>GSL::Vector#isnull</tt><br>
<tt>vect1.isnull() -> anInteger </tt><br>
This function returns 1 if all the elements of the vector v are zero, 
and 0 otherwise.
<p> 
<a name="equal"></a>
<a name="=="></a>
<tt>GSL::Vector::equal</tt><br>
<tt>GSL::Vector::==</tt>&nbsp; (alias)<br>
<tt>vect1 == vect2 -> aBool</tt><br>
This method returns true if the two methods have all the elements equal.
<p>
<a name="float_equal"></a>
<tt>GSL::Vector::float_equal</tt><br>
<tt>Vector::float_equal(vect1, vect2, eps) -> aBool</tt><br>
eps is a double. This function returns true if abs(vect1(i) - vect2(i)) < eps 
for all elements.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL
require 'gsl_util'

v1 = Vector.new((5..8).to_a)
assert v1.max == 8 &amp;&amp; v1.min == 5
assert v1.minmax == [5,8]

v2 =  Vector.new([3,7,1,7])
assert v2.max_index == 1 &amp;&amp; v2.min_index == 2
assert v2.minmax_index == [2, 1]  
assert v2.isnull == 0

v3 =  Vector.new([0,0])
assert v3.isnull == 1

eps = 1.0e-15
v4 = Vector.new([3,7,1,7 + eps/2])
v5 = Vector.new([3,7,1,7 + eps*2])
assert v2 =~ v4 &amp;&amp; v2 !~ v5
v5 = Vector.new([3,7,1,7+eps/1000])
assert v5 == v2 &amp;&amp; v4 != v2
assert v4 =~ v2
assert v4 =~ [v2, eps] &amp;&amp; v4 !~ [v2, eps/10]
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="vector_complex.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="../matrices.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Vectors</td> 
</tr></tbody></table><hr>
</body>
</html>
