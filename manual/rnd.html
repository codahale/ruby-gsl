<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Random Number Distributions</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="stats.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="qrng.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Random Number Distributions</td> 
</tr></tbody></table><hr><h1>
Random Number Distributions</h1>
<hr>
This chapter describes functions for generating random variates and
computing their probability distributions. Samples from the distributions
described in this chapter can be obtained using any of the random number
generators in the library as an underlying source of randomness. In the
simplest cases a non-uniform distribution can be obtained analytically
from the uniform distribution of a random number generator by applying
an appropriate transformation. This method uses one call to the random
number generator.

More complicated distributions are created by the acceptance-rejection
method, which compares the desired distribution against a distribution
which is similar and known analytically. This usually requires several
samples from the generator.

The functions described in this section are declared in `gsl_randist.h'.

<h2>Module RND</h2>
It is defined under the module GSL::Random.

<h3>The Gaussian Tail Distribution</h3>

<p>
<a name="gaussian_tail"></a>
<tt>GSL::Random::RND::gaussian_tail</tt><br>
<tt>RND::gaussian_tail(rng, a, sigma) -> aDouble</tt><br>
RND rnd; double a, sigma<br>

This function provides random variates from the upper tail of a
Gaussian distribution with standard deviation sigma. The values returned
are larger than the lower limit a, which must be positive. The method is
based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann Math Stat
32, 894-899 (1961)), with this aspect explained in Knuth, v2, 3rd ed,
p139,586 (exercise 11).
<br>
The probability distribution for Gaussian tail random variates is,
<br>
p(x) dx = {1 \over N(a;\sigma)} \exp (- x^2/(2 \sigma^2)) dx
<br>
for x > a where N(a;\sigma) is the normalization constant,
<br>
N(a;\sigma) = (1/2) erfc(a / sqrt(2 sigma^2)).
<p>
<a name="gaussian_tail_pdf"></a>
<tt>GSL::Random::RND::gaussian_tail_pdf</tt><br>
<tt>RND::gaussian_tail_pdf(x, a, sigma-> aDouble</tt><br>
double x, a, sigma<br>
This function computes the probability density p(x) at x for a
Gaussian tail distribution with standard deviation sigma and lower limit
a, using the formula given above.
<p>
<a name="ugaussian_tail"></a>
<tt>GSL::Random::RND::ugaussian_tail</tt><br>
<tt>RND::ugaussian_tail(rng, a) -> aDouble</tt><br>
RNG rng; double a<br>
<a name="ugaussian_tail_pdf"></a>
<tt>GSL::Random::RND::ugaussian_tail_pdf</tt><br>
<tt>RND::ugaussian_tail_pdf(x, a) -> aDouble</tt><br>

These functions compute results for the tail of a unit Gaussian
distribution. They are equivalent to the functions above with a standard
deviation of one, sigma = 1.

<h3>The Bivariate Gaussian Distribution</h3>
<a name="bivariate_gaussian"></a>
<tt>GSL::Random::RND::bivariate_gaussian</tt><br>
<tt>RND::bivariate_gaussian(rng, sigma_x, sigma_y, rho) -> [x, y]</tt><br>
RNG rng; double sigma_x, sigma_y, rho, x, y<br>
This
function generates a pair of correlated gaussian variates, with mean zero,
correlation coefficient rho and standard deviations sigma_x and sigma_y
in the x and y directions. The probability distribution for bivariate
gaussian random variates is,
<br>
p(x,y) dx dy = {1 \over 2 \pi \sigma_x \sigma_y \sqrt{1-\rho^2}} \exp
(-(x^2 + y^2 - 2 \rho x y)/2\sigma_x^2\sigma_y^2 (1-\rho^2)) dx dy
<br>
for x,y in the range -\infty to +\infty. The correlation coefficient
rho should lie between 1 and -1.
<p>
<a name="bivariate_gaussian_pdf"></a>
<tt>GSL::Random::RND::bivariate_gaussian_pdf</tt><br>
<tt>RND::bivariate_gaussian_pdf(x, y, sigma_x, sigma_y, rho) -> p</tt><br>

This function computes the
probability density p(x,y) at (x,y) for a bivariate gaussian distribution
with standard deviations sigma_x, sigma_y and correlation coefficient rho,
using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new
puts "gaussian_tail"
3.times { p RND::gaussian_tail(r, 1, 1)}
puts "gaussian_tail_pdf"
p RND::gaussian_tail_pdf(1.5, 1,1)

puts "bivariate_gaussian"
3.times{ p RND::bivariate_gaussian(r, 0.4, 0.5, 0.6)}
puts "bivariate_gaussian_pdf"
p RND::bivariate_gaussian_pdf(1.2, 1.3, 0.5, 0.6, 0.7)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Exponential Distribution</h3>
<a name="exponential"></a>
<tt>GSL::Random::RND::exponential</tt><br>
<tt>RND::exponential(rng, mu) -> </tt><br>
RNG rng; double mu<br>

This function returns a random variate from the exponential distribution with
mean mu. The distribution is,
<br>
p(x) dx = {1 \over \mu} \exp(-x/\mu) dx
<br>
for x >= 0.
<p>
<a name="exponential_pdf"></a>
<tt>GSL::Random::RND::exponential_pdf</tt><br>
<tt>RND::exponential_pdf(x, mu) -> p </tt><br>
This function computes the probability density p(x) at x for an exponential
distribution with mean mu, using the formula given above.


<h3>The Laplace Distribution</h3>
<a name="laplace"></a>
<tt>GSL::Random::RND::laplace</tt><br>
<tt>RND::laplace(rng, a) -> </tt><br>
RNG rng; double a<br>
This function
returns a random variate from the Laplace distribution with width a. The
distribution is,
<br>
p(x) dx = {1 \over 2 a}  \exp(-|x/a|) dx
<br>
for -\infty < x < \infty.
<p>
<a name="laplace_pdf"></a>
<tt>GSL::Random::RND::laplace_pdf</tt><br>
<tt>RND::laplace_pdf() -> </tt><br>

This function
computes the probability density p(x) at x for a Laplace distribution
with mean a, using the formula given above.

<h3>The Exponential Power Distribution</h3>
<a name="exppow"></a>
<tt>GSL::Random::RND::exppow</tt><br>
<tt>RND::exppow(rng, a, b) -> aDouble</tt><br>

This function returns a random variate from the exponential power
distribution with scale parameter a and exponent b. The distribution is,
<br>
p(x) dx = {1 \over 2 a \Gamma(1+1/b)} \exp(-|x/a|^b) dx
<br>
for x >= 0. For b = 1 this reduces to the Laplace distribution. For b =
2 it has the same form as a gaussian distribution, but with a = \sqrt{2}
\sigma.
<p>
<a name="exppow_pdf"></a>
<tt>GSL::Random::RND::exppow_pdf</tt><br>
<tt>RND::exppow_pdf(x, a, b) -> aDouble</tt><br>

This function computes the probability density p(x) at x for an exponential
power distribution with scale parameter a and exponent b, using the
formula given above.

<h3>The Cauchy Distribution</h3>
<a name="cauchy"></a>
<tt>GSL::Random::RND::cauchy</tt><br>
<tt>RND::cauchy(rng, a) -> aDouble</tt><br>

This function
returns a random variate from the Cauchy distribution with scale parameter
a. The probability distribution for Cauchy random variates is,
<br>
p(x) dx = {1 \over a\pi (1 + (x/a)^2) } dx
<br>
for x in the range -\infty to +\infty. The Cauchy distribution is also
known as the Lorentz distribution.
<p>
<a name="cauchy_pdf"></a>
<tt>GSL::Random::RND::cauchy_pdf</tt><br>
<tt>RND::cauchy_pdf() -> </tt><br>
This function
computes the probability density p(x) at x for a Cauchy distribution
with scale parameter a, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "exponential"
3.times { p RND::exponential(r, 0.9)}
p RND::exponential_pdf(1.5, 0.2)

puts "laplace"
3.times {p RND::laplace(r, 0.9)}
p RND::laplace_pdf(1.5, 0.2)

puts "exppow"
3.times {p RND::exppow(r, 0.9, 0.8)}
p RND::exppow_pdf(1.5, 0.2, 1)

puts "cauchy"
3.times{p RND::cauchy(r, 2)}
p RND::cauchy_pdf(1.5, 0.2)


</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>The Rayleigh Distribution</h3>
<a name="rayleigh"></a>
<tt>GSL::Random::RND::rayleigh</tt><br>
<tt>RND::rayleigh(rng, sigma) -> aDouble</tt><br>

This function returns a random variate from the Rayleigh distribution with
scale parameter sigma. The distribution is,
<br>
p(x) dx = {x \over \sigma^2} \exp(- x^2/(2 \sigma^2)) dx
<br>
for x > 0.
<p>
<a name="rayleigh_pdf"></a>
<tt>GSL::Random::RND::rayleigh_pdf</tt><br>
<tt>RND::rayleigh_pdf(x, sigma) -> aDouble</tt><br>

This function computes the probability density p(x) at x for a Rayleigh
distribution with scale parameter sigma, using the formula given above.

<h3>The Rayleigh Tail Distribution</h3>
<a name="rayleigh_tail"></a>
<tt>GSL::Random::RND::rayleigh_tail</tt><br>
<tt>RND::rayleigh_tail(rng, a, sigma) -> aDouble</tt><br>

This function returns a random variate from the tail of
the Rayleigh distribution with scale parameter sigma and a lower limit
of a. The distribution is,
<br>
p(x) dx = {x \over \sigma^2} \exp ((a^2 - x^2) /(2 \sigma^2)) dx
<br>
for x > a.
<p>
<a name="rayleigh_tail_pdf"></a>
<tt>GSL::Random::RND::rayleigh_tail_pdf</tt><br>
<tt>RND::rayleigh_tail_pdf(x, a, sigma) -> </tt><br>

This function computes the probability density p(x) at x for a
Rayleigh tail distribution with scale parameter sigma and lower limit a,
using the formula given above.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "rayleigh"
3.times { p RND::rayleigh(r, 0.9)}
p RND::rayleigh_pdf(1.5, 0.2)

puts "rayleigh_tail"
3.times { p RND::rayleigh_tail(r, 0.9, 0.2)}
p RND::rayleigh_tail_pdf(1.5, 0.9, 0.2)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Landau Distribution</h3>
<a name="landau"></a>
<tt>GSL::Random::RND::landau</tt><br>
<tt>RND::landau(rng) -> aDouble</tt><br>

This function
returns a random variate from the Landau distribution. The probability
distribution for Landau random variates is defined analytically by the
complex integral,
<br>
p(x) = (1/(2 \pi i)) \int_{c-i\infty}^{c+i\infty} ds exp(s log(s) + x s)
<br>
For numerical purposes it is more convenient to use the following
equivalent form of the integral,
<br>
p(x) = (1/\pi) \int_0^\infty dt \exp(-t \log(t) - x t) \sin(\pi t).
<p>
<a name="landau_pdf"></a>
<tt>GSL::Random::RND::landau_pdf</tt><br>
<tt>RND::landau_pdf(x) -> aDouble</tt><br>

This function computes
the probability density p(x) at x for the Landau distribution using an
approximation to the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "landau"
3.times { p RND::landau(r)}
p RND::landau_pdf(0.3)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Levy alpha-Stable Distributions</h3>
<a name="levy"></a>
<tt>GSL::Random::RND::levy</tt><br>
<tt>RND::levy(rng, c, alpha) -> </tt><br>
RNG rng; double c, alpha<br>
This function returns a random variate from the Levy symmetric stable
distribution with scale c and exponent alpha. The symmetric stable
probability distribution is defined by a fourier transform,
<br>
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x -
|c t|^alpha)
<br>
There is no explicit solution for the form of p(x) and the library does
not define a corresponding pdf function. For \alpha = 1 the distribution
reduces to the Cauchy distribution. For \alpha = 2 it is a Gaussian
distribution with \sigma = \sqrt{2} c. For \alpha < 1 the tails of the
distribution become extremely wide.
<br>
The algorithm only works for 0 < alpha <= 2.

<h3>The Levy skew alpha-Stable Distribution</h3>
<p>
<a name="levy_skew"></a>
<tt>GSL::Random::RND::levy_skew</tt><br>
<tt>RND::levy_skew(rng, c, alpha, beta) -> </tt><br>

This function returns a random variate from
the Levy skew stable distribution with scale c, exponent alpha and
skewness parameter beta. The skewness parameter must lie in the range
[-1,1]. The Levy skew stable probability distribution is defined by a
fourier transform,
<br>
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c
t|^alpha (1-i beta sign(t) tan(pi alpha/2)))
When \alpha = 1 the term \tan(\pi \alpha/2) is replaced by
-(2/\pi)\log|t|. There is no explicit solution for the form of p(x) and
the library does not define a corresponding pdf function. For \alpha =
2 the distribution reduces to a Gaussian distribution with \sigma =
\sqrt{2} c and the skewness parameter has no effect. For \alpha <
1 the tails of the distribution become extremely wide. The symmetric
distribution corresponds to \beta = 0.
<br>
The algorithm only works for 0 < alpha <= 2.
<br>
The Levy alpha-stable distributions have the property that if N
alpha-stable variates are drawn from the distribution p(c, \alpha, \beta)
then the sum Y = X_1 + X_2 + \dots + X_N will also be distributed as an
alpha-stable variate, p(N^(1/\alpha) c, \alpha, \beta).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "levy"
3.times { p RND::levy(r, 0.5, 1.1)}

3.times { p RND::levy_skew(r, 0.5, 1.1, 0.4)}

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>The Gamma Distribution</h3>
<a name="gamma"></a>
<tt>GSL::Random::RND::gamma</tt><br>
<tt>RND::gamma(rng, a, b) -> </tt><br>
RNG rng; double a,b<br>
This function returns a random variate from the gamma distribution. The
distribution function is,
<br>
p(x) dx = {1 \over \Gamma(a) b^a} x^{a-1} e^{-x/b} dx
<br>
for x > 0.
<p>
<a name="gamma_pdf"></a>
<tt>GSL::Random::RND::gamma_pdf</tt><br>
<tt>RND::gamma_pdf(x, a, b) -> aDouble</tt><br>

This function computes the probability density p(x) at x for a gamma
distribution with parameters a and b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "gamma"
3.times { p RND::gamma(r, 0.5, 1.1)}

p RND::gamma_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Flat (Uniform) Distribution</h3>
<a name="flat"></a>
<tt>GSL::Random::RND::flat</tt><br>
<tt>RND::flat(rng, a, b) -> aDouble</tt><br>

This function returns a random variate from the flat (uniform) distribution
from a to b. The distribution is,
<br>
p(x) dx = {1 \over (b-a)} dx
<br>
if a <= x < b and 0 otherwise.
<p>
<a name="flat_pdf"></a>
<tt>GSL::Random::RND::flat_pdf</tt><br>
<tt>RND::flat_pdf(x, a, b) -> aDouble</tt><br>

This function computes the probability density p(x) at x for a uniform
distribution from a to b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "flat"
3.times { p RND::flat(r, 0.5, 1.1)}

p RND::flat_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Lognormal Distribution</h3>
<a name="lognormal"></a>
<tt>GSL::Random::RND::lognormal</tt><br>
<tt>RND::lognormal(rng, zeta, sigma) -> aDouble</tt><br>
RNG rng; double zeta, sigma<br>
This function returns a random variate from the lognormal
distribution. The distribution function is,
<br>
p(x) dx = {1 \over x \sqrt{2 \pi \sigma^2} } \exp(-(\ln(x) - \zeta)^2/2
\sigma^2) dx
<br>
for x > 0.
<p>
<a name="lognormal_pdf"></a>
<tt>GSL::Random::RND::lognormal_pdf</tt><br>
<tt>RND::lognormal_pdf(x, zeta, sigma) -> aDouble</tt><br>

This function computes the probability density p(x) at x for a
lognormal distribution with parameters zeta and sigma, using the formula
given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "lognormal"
3.times { p RND::lognormal(r, 0.5, 1.1)}

p RND::lognormal_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Chi-squared Distribution</h3>

The chi-squared distribution arises in statistics If Y_i are n independent
gaussian random variates with unit variance then the sum-of-squares,
<br>
X_i = \sum_i Y_i^2
<br>
has a chi-squared distribution with n degrees of freedom.
<a name="chisq"></a>
<tt>GSL::Random::RND::chisq</tt><br>
<tt>RND::chisq(rng, nu) -> aDouble</tt><br>

This function returns a random variate from the chi-squared distribution 
with nu degrees of freedom. The distribution function is,
<br>
p(x) dx = {1 \over \Gamma(\nu/2) } (x/2)^{\nu/2 - 1} \exp(-x/2) dx
<br>
for x >= 0.
<p>
<a name="chisq_pdf"></a>
<tt>GSL::Random::RND::chisq_pdf</tt><br>
<tt>RND::chisq_pdf(x, nu) -> p</tt><br>

This function
computes the probability density p(x) at x for a chi-squared distribution
with nu degrees of freedom, using the formula given above.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "chisq"
3.times { p RND::chisq(r, 0.5)}

p RND::chisq_pdf(0.8, 0.5)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The F-distribution</h3>

The F-distribution arises in statistics. If Y_1 and Y_2 are chi-squared
deviates with \nu_1 and \nu_2 degrees of freedom then the ratio,
<br>
X = { (Y_1 / \nu_1) \over (Y_2 / \nu_2) }
<br>
has an F-distribution F(x;\nu_1,\nu_2).
<a name="fdist"></a>
<tt>GSL::Random::RND::fdist</tt><br>
<tt>RND::fdist(rng, nu1, nu2) -> </tt><br>

This function returns a random variate from the F-distribution with
degrees of freedom nu1 and nu2. The distribution function is,
<br>
p(x) dx = { \Gamma((\nu_1 + \nu_2)/2) \over \Gamma(\nu_1/2)
\Gamma(\nu_2/2) } \nu_1^{\nu_1/2} \nu_2^{\nu_2/2} x^{\nu_1/2 - 1}
(\nu_2 + \nu_1 x)^{-\nu_1/2 -\nu_2/2}
<br>
for x >= 0.
<p>
<a name="fdist_pdf"></a>
<tt>GSL::Random::RND::fdist_pdf</tt><br>
<tt>RND::fdist_pdf(x, nu1, nu2) -> </tt><br>

This function computes the probability density p(x) at x for an F-distribution
with nu1 and nu2 degrees of freedom, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "fdist"
3.times { p RND::fdist(r, 0.5, 1.1)}

p RND::fdist_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The t-distribution</h3>

The t-distribution arises in statistics. If Y_1 has a normal distribution
and Y_2 has a chi-squared distribution with \nu degrees of freedom then
the ratio,
<br>
X = { Y_1 \over \sqrt{Y_2 / \nu} }
<br>
has a t-distribution t(x;\nu) with \nu degrees of freedom.
<a name="tdist"></a>
<tt>GSL::Random::RND::tdist</tt><br>
<tt>RND::tdist(rng, nu) -> </tt><br> 
This function returns a random variate from the t-distribution. The distribution
function is,
<br>
p(x) dx = {\Gamma((\nu + 1)/2) \over \sqrt{\pi \nu} \Gamma(\nu/2)}
(1 + x^2/\nu)^{-(\nu + 1)/2} dx
<br>
for -\infty < x < +\infty.
<p>
<a name="tdist_pdf"></a>
<tt>GSL::Random::RND::tdist_pdf</tt><br>
<tt>RND::tdist_pdf(x, nu) -> </tt><br>

This function
computes the probability density p(x) at x for a t-distribution with nu
degrees of freedom, using the formula given above.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "tdist"
3.times { p RND::tdist(r, 0.5)}

p RND::tdist_pdf(0.8, 0.5)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Beta Distribution</h3>
<a name="beta"></a>
<tt>GSL::Random::RND::beta</tt><br>
<tt>RND::beta(rng, a, b) -> </tt><br>

This function returns a random variate from the beta distribution. The
distribution function is,
<br>
p(x) dx = {\Gamma(a+b) \over \Gamma(a) \Gamma(b)} x^{a-1} (1-x)^{b-1} dx
<br>
for 0 <= x <= 1.
<p>
<a name="beta_pdf"></a>
<tt>GSL::Random::RND::beta_pdf</tt><br>
<tt>RND::beta_pdf(x, a, b) -> </tt><br>

This function computes the probability density p(x) at x for a beta
distribution with parameters a and b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "beta"
3.times { p RND::beta(r, 0.5, 1.1)}

p RND::beta_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Logistic Distribution</h3>
<a name="logistic"></a>
<tt>GSL::Random::RND::logistic</tt><br>
<tt>RND::logistic(rng, a) -> aDouble</tt><br>

This
function returns a random variate from the logistic distribution. The
distribution function is,
<br>
p(x) dx = { \exp(-x/a) \over a (1 + \exp(-x/a))^2 } dx
<br>
for -\infty < x < +\infty.
<p>
<a name="logistic_pdf"></a>
<tt>GSL::Random::RND::logistic_pdf</tt><br>
<tt>RND::logistic_pdf(x, a) -> p</tt><br>

This function
computes the probability density p(x) at x for a logistic distribution
with scale parameter a, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "logistic"
3.times { p RND::logistic(r, 0.5)}

p RND::logistic_pdf(0.8, 0.5)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>The Pareto Distribution</h3>
<a name="pareto"></a>
<tt>GSL::Random::RND::pareto</tt><br>
<tt>RND::pareto(rng, a, b) -> aDouble</tt><br>

This function returns a random variate from the Pareto distribution of
order a. The distribution function is,
<br>
p(x) dx = (a/b) / (x/b)^{a+1} dx
<br>
for x >= b.
<p>
<a name="pareto_pdf"></a>
<tt>GSL::Random::RND::pareto_pdf</tt><br>
<tt>RND::pareto_pdf(x, a, b) -> p</tt><br>

This function computes the probability density p(x) at x for a Pareto
distribution with exponent a and scale b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "pareto"
3.times { p RND::pareto(r, 0.5, 0.7)}

p RND::pareto_pdf(0.8, 0.5, 0.7)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Spherical Distribution (2D & 3D)</h3>

The spherical distributions generate random vectors, located on a
spherical surface. They can be used as random directions, for example
in the steps of a random walk.
<a name="dir_2d"></a>
<tt>GSL::Random::RND::dir_2d</tt><br>
<tt>RND::dir_2d(rng) -> [x, y]</tt><br>
RNG rng; double x, y<br>
<a name="dir_2d_trig_method"></a>
<tt>GSL::Random::RND::dir_2d_trig_method</tt><br>
<tt>RND::dir_2d_trig_method(rng) -> [x, y]</tt><br>

This function returns a random direction vector v = (x,y) in
two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 =
1. The obvious way to do this is to take a uniform random number between
0 and 2\pi and let x and y be the sine and cosine respectively. Two trig
functions would have been expensive in the old days, but with modern
hardware implementations, this is sometimes the fastest way to go. 
<br>
One can avoid the trig evaluations by choosing x and y in
the interior of a unit circle (choose them at random from the interior
of the enclosing square, and then reject those that are outside the unit
circle), and then dividing by \sqrt{x^2 + y^2}. A much cleverer approach,
attributed to von Neumann (See Knuth, v2, 3rd ed, p140, exercise 23),
requires neither trig nor a square root. In this approach, u and v
are chosen at random from the interior of a unit circle, and then
x=(u^2-v^2)/(u^2+v^2) and y=uv/(u^2+v^2).

<a name="dir_3d"></a>
<tt>GSL::Random::RND::dir_3d</tt><br>
<tt>RND::dir_3d(rng) -> [x, y, z]</tt><br>

This function returns a random direction vector v = (x,y,z)
in three dimensions. The vector is normalized such that |v|^2 = x^2 +
y^2 + z^2 = 1. The method employed is due to Robert E. Knop (CACM 13, 326
(1970)), and explained in Knuth, v2, 3rd ed, p136. It uses the surprising
fact that the distribution projected along any axis is actually uniform
(this is only true for 3d).
<p>
<a name="dir_nd"></a>
<tt>GSL::Random::RND::dir_nd</tt><br>
<tt>RND::dir_nd(rng, n) -> [x_1, ..., x_n]</tt><br>
RNG rng; integer n<br>

This function returns a random direction vector v = (x_1,x_2,...,x_n) in
n dimensions. The vector is normalized such that |v|^2 = x_1^2 + x_2^2 +
... + x_n^2 = 1. The method uses the fact that a multivariate gaussian
distribution is spherically symmetric. Each component is generated to
have a gaussian distribution, and then the components are normalized. The
method is described by Knuth, v2, 3rd ed, p135-136, and attributed to
G. W. Brown, Modern Mathematics for the Engineer (1956).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "flat"
3.times { a = RND::dir_2d(r); p a; p a[0]**2 + a[1]**2}

3.times { a = RND::dir_2d_trig_method(r); p a; p a[0]**2 + a[1]**2}

3.times { a = RND::dir_3d(r); p a; p a[0]**2 + a[1]**2 + a[2]**2}

3.times { a = RND::dir_nd(r, 3); p a; p a[0]**2 + a[1]**2 + a[2]**2}



</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Weibull Distribution</h3>
<a name="weibull"></a>
<tt>GSL::Random::RND::weibull</tt><br>
<tt>RND::weibull(rng, a, b) -> aDouble</tt><br>

This function returns a random variate from the Weibull distribution. The
distribution function is,
<br>
p(x) dx = {b \over a^b} x^{b-1}  \exp(-(x/a)^b) dx
<br>
for x >= 0.
<a name="weibull_pdf"></a>
<tt>GSL::Random::RND::weibull_pdf</tt><br>
<tt>RND::weibull_pdf(x, a, b) -> p</tt><br>

This function computes the probability density p(x) at x for a Weibull
distribution with scale a and exponent b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "weibull"
3.times { p RND::weibull(r, 0.5, 1.1)}

p RND::weibull_pdf(0.8, 0.5, 1.1)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Type-1 Gumbel Distribution</h3>
<a name="gumbel1"></a>
<tt>GSL::Random::RND::gumbel1</tt><br>
<tt>RND::gumbel1(rng, a, b) -> aDouble</tt><br>

This function returns a random variate from the Type-1 Gumbel
distribution. The Type-1 Gumbel distribution function is,
<br>
p(x) dx = a b \exp(-(b \exp(-ax) + ax)) dx
<br>
for -\infty < x < \infty.
<p>
<a name="gumbel1_pdf"></a>
<tt>GSL::Random::RND::gumbel1_pdf</tt><br>
<tt>RND::gumbel1_pdf(x, a, b) -> p</tt><br>

This function computes the probability density p(x) at x for a Type-1 Gumbel
distribution with parameters a and b, using the formula given above.

<h3>The Type-2 Gumbel Distribution</h3>
<a name="gumbel2"></a>
<tt>GSL::Random::RND::gumbel2</tt><br>
<tt>RND::gumbel2(rng, a, b) -> aDouble</tt><br>
This function returns a random variate from the Type-2 Gumbel
distribution. The Type-2 Gumbel distribution function is,
<br>
p(x) dx = a b x^{-a-1} \exp(-b x^{-a}) dx
<br>
for 0 < x < \infty.
<p>
<a name="gumbel2_pdf"></a>
<tt>GSL::Random::RND::gumbel2_pdf</tt><br>
<tt>RND::gumbel2_pdf(x, a, b) -> p</tt><br>

This function computes the probability density p(x) at x for a Type-2 Gumbel
distribution with parameters a and b, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "flat"
3.times { p RND::gumbel1(r, 0.5, 1.1)}

p RND::gumbel1_pdf(0.8, 0.5, 1.1)

3.times { p RND::gumbel2(r, 0.5, 1.1)}

p RND::gumbel2_pdf(0.8, 0.5, 1.1)


</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>The Dirichlet Distribution</h3>
<a name="dirichlet"></a>
<tt>GSL::Random::RND::dirichlet</tt><br>
<tt>RND::dirichlet(rng, K, alpha, theta)</tt>&nbsp; (mutating theta)<br>
RNG rng; integer K; Array alpha, theta,br>
This function mutates theta into an array
of K random variates from a Dirichlet distribution of order K-1. The
distribution function is
<br>
p(\theta_1, ..., \theta_K) d\theta_1 ... d\theta_K = (1/Z) \prod_{i=1}^K
\theta_i^{\alpha_i - 1} \delta(1 -\sum_{i=1}^K \theta_i) d\theta_1
... d\theta_K
<br>
for theta_i >= 0 and alpha_i >= 0. The normalization factor Z is
<br>
Z = {\prod_{i=1}^K \Gamma(\alpha_i)} / {\Gamma( \sum_{i=1}^K \alpha_i)}
<br>
The random variates are generated by sampling K values from gamma
distributions with parameters a=alpha_i, b=1, and renormalizing. See
A.M. Law, W.D. Kelton, Simulation Modeling and Analysis (1991).
<p>
<a name="dirichlet_pdf"></a>
<tt>GSL::Random::RND::dirichlet_pdf</tt><br>
<tt>RND::dirichlet_pdf(K, alpha, theta) -> </tt><br>

Function: double gsl_ran_dirichlet_pdf (const size_t K, const double
alpha[], const double theta[]) This function computes the probability
density p(\theta_1, ... , \theta_K) at theta[K] for a Dirichlet
distribution with parameters alpha[K], using the formula given above.
<p>
<a name="dirichlet_lnpdf"></a>
<tt>GSL::Random::RND::dirichlet_lnpdf</tt><br>
<tt>RND::dirichlet_lnpdf(K, alpha, theta) -> </tt><br>

This function computes the logarithm
of the probability density p(\theta_1, ... , \theta_K) for a Dirichlet
distribution with parameters alpha[K].
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "dirichlet"
alpha = [1.0, 1.1, 1.2]
theta = [2.0, 2.1, 2.2]
3.times{ RND::dirichlet(r, 3, alpha, theta); p theta}

assert Math::log(RND::dirichlet_pdf(3, alpha, theta)) == RND::dirichlet_lnpdf(3, alpha, theta)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>General Discrete Distributions</h3>

Given K discrete events with different probabilities P[k], produce a
random value k consistent with its probability.
<p>
The obvious way to do this is to preprocess the probability list by
generating a cumulative probability array with K+1 elements:
<pre>
C[0] = 0 
C[k+1] = C[k]+P[k].
</pre>
Note that this construction produces C[K]=1. Now choose a uniform
deviate u between 0 and 1, and find the value of k such that C[k] <= u <
C[k+1]. Although this in principle requires of order \log K steps per
random number generation, they are fast steps, and if you use something
like \lfloor uK \rfloor as a starting point, you can often do pretty well.
<br>
But faster methods have been devised. Again, the idea is to preprocess
the probability list, and save the result in some form of lookup table;
then the individual calls for a random discrete event can go rapidly. An
approach invented by G. Marsaglia (Generating discrete random numbers
in a computer, Comm ACM 6, 37-38 (1963)) is very clever, and readers
interested in examples of good algorithm design are directed to this
short and well-written paper. Unfortunately, for large K, Marsaglia's
lookup table can be quite large.
<br>
A much better approach is due to Alastair J. Walker (An efficient method
for generating discrete random variables with general distributions,
ACM Trans on Mathematical Software 3, 253-256 (1977); see also Knuth, v2,
3rd ed, p120-121,139). This requires two lookup tables, one floating point
and one integer, but both only of size K. After preprocessing, the random
numbers are generated in O(1) time, even for large K. The preprocessing
suggested by Walker requires O(K^2) effort, but that is not actually
necessary, and the implementation provided here only takes O(K) effort. In
general, more preprocessing leads to faster generation of the individual
random numbers, but a diminishing return is reached pretty early. Knuth
points out that the optimal preprocessing is combinatorially difficult
for large K.  This method can be used to speed up some of the discrete
random number generators below, such as the binomial distribution. To
use if for something like the Poisson Distribution, a modification would
have to be made, since it only takes a finite set of K outcomes.
<br>
MISSING<br>
Function: gsl_ran_discrete_t * gsl_ran_discrete_preproc (size_t K,
const double * P) This function returns a pointer to a structure that
contains the lookup table for the discrete random number generator. The
array P[] contains the probabilities of the discrete events; these array
elements must all be positive, but they needn't add up to one (so you
can think of them more generally as "weights") -- the preprocessor will
normalize appropriately. This return value is used as an argument for
the gsl_ran_discrete function below.
<br>
MISSING<br>

Random: size_t gsl_ran_discrete (const gsl_rng * r, const
gsl_ran_discrete_t * g) After the preprocessor, above, has been called,
you use this function to get the discrete random numbers.
<br>
MISSING<br>

Function: double gsl_ran_discrete_pdf (size_t k, const gsl_ran_discrete_t
* g) Returns the probability P[k] of observing the variable k. Since
P[k] is not stored as part of the lookup table, it must be recomputed;
this computation takes O(K), so if K is large and you care about the
original array P[k] used to create the lookup table, then you should
just keep this original array P[k] around.
Function: void gsl_ran_discrete_free (gsl_ran_discrete_t * g) De-allocates
the lookup table pointed to by g.

<h3>The Poisson Distribution</h3>
<a name="poisson"></a>
<tt>GSL::Random::RND::poisson</tt><br>
<tt>RND::poisson(rng, mu) -> anInteger</tt><br>
RNG rng; double mu<br>
This function returns a random integer from the Poisson distribution
with mean mu. The probability distribution for Poisson variates is,
<br>
p(k) = {\mu^k \over k!} \exp(-\mu)
<br>
for k >= 0.
<p>
<a name="poisson_pdf"></a>
<tt>GSL::Random::RND::poisson_pdf</tt><br>
<tt>RND::poisson_pdf(k, mu) -> p</tt><br>
integer k; doub;e mu<br>
This function computes the probability p(k) of obtaining k from a Poisson
distribution with mean mu, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "poisson"
3.times { p RND::poisson(r, 0.5)}

p RND::poisson_pdf(0.8, 0.5)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Bernoulli Distribution</h3>
<a name="bernoulli"></a>
<tt>GSL::Random::RND::bernoulli</tt><br>
<tt>RND::bernoulli(rng, p) -> anInteger</tt><br>
RNG rng; double p; anInteger is 0 or 1.
This function returns either 0 or 1, the result of a Bernoulli trial
with probability p. The probability distribution for a Bernoulli trial is,
<br>
p(0) = 1 - p &nbsp; ; &nbsp; p(1) = p
<p>
<a name="bernoulli_pdf"></a>
<tt>GSL::Random::RND::bernoulli_pdf</tt><br>
<tt>RND::bernoulli_pdf(k, p) -> p1</tt><br>
unsigned integer k; double p<br>
This function computes the probability p1(k) of obtaining k from a Bernoulli
distribution with probability parameter p, using the formula given above.

<h3>The Binomial Distribution</h3>
<a name="binomial"></a>
<tt>GSL::Random::RND::binomial</tt><br>
<tt>RND::binomial(rng, p, n) -> i1</tt><br>
RNG rng; double p; unsigned int n, i1<br>
This function returns a random integer from the binomial
distribution, the number of successes in n independent trials with
probability p. The probability distribution for binomial variates is,
<br>
p(k) = {n! \over k! (n-k)! } p^k (1-p)^{n-k}
<br>
for 0 <= k <= n.
<p>
<a name="binomial_pdf"></a>
<tt>GSL::Random::RND::binomial_pdf</tt><br>
<tt>RND::binomial_pdf(k, p, n) -> </tt><br>
unsigned int k, n; double p<br>
This function computes the probability p(k) of obtaining k from
a binomial distribution with parameters p and n, using the formula
given above.

<h3>The Multinomial Distribution</h3>
<a name="multinomial"></a>
<tt>GSL::Random::RND::multinomial</tt><br> 
<tt>RND::multinomial(rng, K, N, p, n)</tt><br>
RNG rng; int K, N; Array p, n<br>
where p is an array of doubles, n an array of unsigned integers.<br>

This function returns an array of K random variates from a multinomial
distribution. The distribution function is,
<br>
P(n_1, n_2, ..., n_K) = (N!/(n_1! n_2! ... n_K!)) p_1^n_1 p_2^n_2 ... p_K^n_K
<br>
where (n_1, n_2, ..., n_K) are nonnegative integers with sum_{k=1,K} n_k = N, 
and (p_1, p_2, ..., p_K) is a probability distribution with \sum p_i = 1. 
If the array p[K] is not normalized then its entries will be
treated as weights and normalized appropriately.
<br>
Random variates are generated using the conditional binomial method
(see C.S. David, The computer generation of multinomial random variates,
Comp. Stat. Data Anal. 16 (1993) 205-217 for details).
<p>
<a name="multinomial_pdf"></a>
<tt>GSL::Random::RND::multinomial_pdf</tt><br>
<tt>RND::multinomial_pdf(K, p, n) -> P</tt><br>

This function computes the probability
P(n_1, n_2, ..., n_K) of sampling n[K] from a multinomial distribution
with parameters p[K], using the formula given above.
<p>
<a name="multinomial_lnpdf"></a>
<tt>GSL::Random::RND::multinomial_lnpdf</tt><br>
<tt>RND::multinomial_lnpdf(K, p, n) -> P</tt><br>

This function returns the logarithm of
the probability for the multinomial distribution P(n_1, n_2, ..., n_K)
with parameters p[K].
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "multinomial"
p = [0.1, 0.2, 0.7]
n = [2, 1, 0]
3.times { p RND::multinomial(r,3,4,p,n); p n}

p RND::multinomial_pdf(3,p,n)
p RND::multinomial_lnpdf(3,p,n)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Negative Binomial Distribution</h3>
<a name="negative_binomial"></a>
<tt>GSL::Random::RND::negative_binomial</tt><br>
<tt>RND::negative_binomial(rng, p, n) -> i1</tt><br>
RNG rng; double p, n; int i1<br>
This function returns a random integer i1 from the
negative binomial distribution, the number of failures occurring before
n successes in independent trials with probability p of success. The
probability distribution for negative binomial variates is,
<br>
p(k) = {\Gamma(n + k) \over \Gamma(k+1) \Gamma(n) } p^n (1-p)^k
<br>
Note that n is not required to be an integer.
<p>
<a name="negative_binomial_pdf"></a>
<tt>GSL::Random::RND::negative_binomial_pdf</tt><br>
<tt>RND::negative_binomial_pdf(k, p, n) -> P</tt><br>
unsigned int k; double p, n<br>
This function computes the probability P(k) of obtaining
k from a negative binomial distribution with parameters p and n, using
the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "negative_binomial"
3.times { p RND::negative_binomial(r, 0.5, 4)}

p RND::negative_binomial_pdf(2, 0.5, 4)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Pascal Distribution</h3>
<a name="pascal"></a>
<tt>GSL::Random::RND::pascal</tt><br>
<tt>RND::pascal(rng, p, n) -> i1</tt><br>
RNG r; double p; unsigned int n, i1<br>
This function returns a random integer from the Pascal
distribution. The Pascal distribution is simply a negative binomial
distribution with an integer value of n.
<br>
p(k) = {(n + k - 1)! \over k! (n - 1)! } p^n (1-p)^k
<br>
for k = 0, 1, ..., n .
<p>
<a name="pascal_pdf"></a>
<tt>GSL::Random::RND::pascal_pdf</tt><br>
<tt>RND::pascal_pdf(k, p, n) -> P</tt><br>
unsigned int k, n; double p<br>
This function computes the probability P(k) of obtaining k from
a Pascal distribution with parameters p and n, using the formula given
above.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "pascal"
3.times { p RND::pascal(r, 0.5, 4)}

p RND::pascal_pdf(2, 0.5, 4)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Geometric Distribution</h3>
<a name="geometric"></a>
<tt>GSL::Random::RND::geometric</tt><br>
<tt>RND::geometric(rng, p) -> i1</tt><br>
RNG rng; double p; unsigned int i1<br>
This function returns a random integer from the geometric distribution,
the number of independent trials with probability p until the first
success. The probability distribution for geometric variates is,
<br>
p(k) =  p (1-p)^(k-1)
<br>
for k >= 1.
<p>
<a name="geometric_pdf"></a>
<tt>GSL::Random::RND::geometric_pdf</tt><br>
<tt>RND::geometric_pdf(k, p) -> P</tt><br>
unsigned int k; double p, P<br>
This function computes the probability P(k) of obtaining k from a geometric
distribution with probability parameter p, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "geometric"
3.times { p RND::geometric(r, 0.5)}

p RND::geometric_pdf(7, 0.2)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>The Hypergeometric Distribution</h3>
<a name="hypergeometric"></a>
<tt>GSL::Random::RND::hypergeometric</tt><br>
<tt>RND::hypergeometric(rng, n1, n2, t) -> i1</tt><br>
RNG rng; unsigned int n1, n2, t, i1<br>
This function returns a random
integer from the hypergeometric distribution. The probability distribution
for hypergeometric random variates is,
<br>
p(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k)
<br>
where C(a,b) = a!/(b!(a-b)!). The domain of k is max(0,t-n_2), ...,
max(t,n_1).
<p>
<a name="hypergeometric_pdf"></a>
<tt>GSL::Random::RND::hypergeometric_pdf</tt><br>
<tt>RND::hypergeometric_pdf(k, n1, n2, t) -> P</tt><br>
unsigned int k, n1, n2, t; double P<br>
This function computes the
probability P(k) of obtaining k from a hypergeometric distribution with
parameters n1, n2, n3, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "hypergeometric"
3.times { p RND::hypergeometric(r, 2, 4, 3)}

p RND::hypergeometric_pdf(2, 4, 4, 2)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>The Logarithmic Distribution</h3>
<a name="logarithmic"></a>
<tt>GSL::Random::RND::logarithmic</tt><br>
<tt>RND::logarithmic(rng, p) -> i1</tt><br>
RNG rng; double p; unsigned int i1<br>
This function returns a random integer from the logarithmic
distribution. The probability distribution for logarithmic random
variates is,
<br>
p(k) = {-1 \over \log(1-p)} {(p^k \over k)}
<br>
for k >= 1.
<p>
<a name="logarithmic_pdf"></a>
<tt>GSL::Random::RND::logarithmic_pdf</tt><br>
<tt>RND::logarithmic_pdf(k, p) -> P</tt><br>
unsigned int k; double p, P<br>
This function computes the probability P(k) of obtaining k from a logarithmic
distribution with probability parameter p, using the formula given above.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "logarithmic"
3.times { p RND::logarithmic(r, 0.5)}

p RND::logarithmic_pdf(3, 0.5)

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Shuffling and Sampling</h3>

The following functions allow the shuffling and sampling of a set of
objects. The algorithms rely on a random number generator as source of
randomness and a poor quality generator can lead to correlations in
the output. In particular it is important to avoid generators with a
short period. For more information see Knuth, v2, 3rd ed, Section 3.4.2,
"Random Sampling and Shuffling".
<a name="shuffle"></a>
<tt>GSL::Random::RND::shuffle</tt><br>
<tt>RND::shuffle(rng, base) -> base</tt>&nbsp; (Mutating <tt>base</tt>)<br>

This function randomly shuffles the order of n objects, stored in the 
array base[0..n-1]. The output of the random number
generator r is used to produce the permutation. The algorithm generates
all possible n! permutations with equal probability, assuming a perfect
source of random numbers.
<a name="shuffle"></a>
<tt>Array#shuffle</tt><br>
<tt>ary.shuffle(rng) -> ary</tt>&nbsp; (Mutating <tt>ary</tt>)<br>
This method shuffles the order of n objects; the result is the same as
with GSL::Random::RND::shuffle(rng,ary) .
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

r = RNG.new

puts "shuffle"
ary = [1,3,5,7]
3.times { p RND::shuffle(r, ary); p ary}

r = RNG.new
ary = [[1,2], [3,4], [5,6], [7,8]]
3.times { p RND::shuffle(r, ary); p ary}

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>
<a name="choose"></a>
<tt>RND::choose</tt><br>
<tt>GSL::Random::RND::choose(rng, k, src) -> dest</tt><br>

This function fills the array dest[k] with k
objects taken randomly from the n elements of the array src[0..n-1]. The
objects are each of size size. The output of the random number generator
r is used to make the selection. The algorithm ensures all possible
samples are equally likely, assuming a perfect source of randomness.
<br>
The objects are sampled without replacement, thus each object can only
appear once in dest[k]. It is required that k be less than or equal to
n. The objects in dest will be in the same relative order as those in
src. You will need to call gsl_ran_shuffle(r, dest, n, size) if you want
to randomize the order.
<p>
<tt>Array#choose</tt><br>
<tt>ary.choose(rng, k) -> dest</tt><br>
This method does the same as RND::choose .
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

puts "choose"
r = RNG.new
ary = [1,3,5,7]
3.times{ a = RND::choose(r, 3, ary); p a} 
3.times{ p ary.choose(r, 3)}
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="sample"></a>
<tt>GSL::Random::RND::sample</tt><br>
<tt>RND::sample(rng, k, src) -> dest</tt><br>
This function is like gsl_ran_choose
but samples k items from the original array of n items src with
replacement, so the same object can appear more than once in the output
sequence dest. There is no requirement that k be less than n in this case.
<tt>Array#sample</tt><br>
<tt>ary.sample(rng, k) -> dest</tt><br>
Corresponding Array method.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL; include GSL::Random

puts "sample"
r = RNG.new
ary = [1,3,5,7]
3.times{ a = RND::sample(r, 3, ary); p a} 
3.times{ p ary.sample(r, 3)}
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="example"></a>
<h3>Example</h3>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: rnd.html,v 1.1 2003/09/07 22:25:20 pernici Exp $

require "GSL"
include GSL

# Test histogramms and random number distributions
# generate output suitable for graph(1) from GNU plotutils:
# rnd.rb | awk '{print $1, $3; print $2, $3}' | graph -Tps &gt; g.ps

STDERR.puts "Running tests for histograms and RND..."

h = Histogram::Hist.new2(100, -4, 4)
r = Random::RNG.new
puts "#m=1,S=0"
10000.times do
  begin
    h.increment(Random::RND::gamma(r, 1, 1))
  rescue RangeError
	next
  end
end
h.dump
h.reset
puts "#m=2,S=0"
10000.times do
  begin
    h.increment(Random::RND::gamma(r, 3, 1))
  rescue RangeError
	next
  end
end
h.dump

STDERR.puts "\ndone."
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>References</h3>
consult the book Non-Uniform Random Variate Generation by Luc Devroye. It
covers every imaginable distribution and provides hundreds of algorithms.
<ul><li>
Luc Devroye, Non-Uniform Random Variate Generation, Springer-Verlag,
ISBN 0-387-96305-7.
</ul>

The subject of random variate generation is also reviewed by Knuth,
who describes algorithms for all the major distributions.
<ul><li>
Donald E. Knuth, The Art of Computer Programming: Seminumerical
Algorithms (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
</ul>

The Particle Data Group provides a short review of techniques for
generating distributions of random numbers in the "Monte Carlo" section
of its Annual Review of Particle Physics.
<ul><li>
Review of Particle Properties R.M. Barnett et al., Physical Review D54,
1 (1996) http://pdg.lbl.gov/.
</ul>
The Review of Particle Physics is available online in postscript and
pdf format.

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="stats.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="qrng.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Random Number Distributions</td> 
</tr></tbody></table><hr></body>
</html>
