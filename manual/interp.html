<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Interpolation</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="diff.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href=".html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Interpolation</td> 
</tr></tbody></table><hr><h1>
Interpolation</h1>
<hr>

This chapter describes functions for performing interpolation. The library
provides a variety of interpolation methods, including Cubic splines
and Akima splines. The interpolation types are interchangeable, allowing
different methods to be used without recompiling. Interpolations can be
defined for both normal and periodic boundary conditions. Additional
functions are available for computing derivatives and integrals of
interpolating functions.
<br>
The functions described in this section are declared in the header files
`gsl_interp.h' and `gsl_spline.h'.  

<h2>Introduction</h2>

Given a set of data points (x_1, y_1) ... (x_n, y_n) the routines
described in this section compute a continuous interpolating function y(x)
such that y_i = y(x_i). The interpolation is piecewise smooth, and its
behavior at the end-points is determined by the type of interpolation
used.

<h3>Interpolation Functions</h3>

The interpolation function for a given dataset is stored in a gsl_interp
object. These are created by the following functions.

<h2>Module Interpolation</h2>

<h3>Class Interp</h3>
The class Interp is defined under the  module Interpolation.
<p>
<tt>GSL::Interpolation::Interp::new</tt><br>
<tt>Interp.new(func, size) -> interp1</tt><br>
It returns an interpolation object of type T for size data-points.

<p>
<tt>GSL::Interpolation::Interp#init</tt><br>
<tt>interp1.init(xa, ya)</tt><br>
Array xa, ya<br>

This method initializes the
interpolation object <tt>interp1</tt> for the data (xa,ya) where xa and ya are
arrays of doubles. The interpolation object (gsl_interp) does not save
the data arrays xa and ya and only stores the static state computed from
the data. The xa data array is always assumed to be strictly ordered;
the behavior for other arrangements is not defined.

<h3>Interpolation Types</h3>

The interpolation library provides five interpolation types:
<ul>
<li>GSL::Interpolation::LINEAR <br>
This interpolation method does not require any additional memory.
<li>GSL::Interpolation::POLYNOMIAL <br>
This method should only be used for interpolating small numbers of points
because polynomial interpolation introduces large oscillations, even
for well-behaved datasets. The number of terms in the interpolating
polynomial is equal to the number of points.
<li>GSL::Interpolation::CSPLINE <br>
Cubic spline with natural boundary conditions.
<li>GSL::Interpolation::CSPLINE_PERIODIC <br>
Cubic spline with periodic boundary conditions.
<li>GSL::Interpolation::AKIMA<br>
Akima spline with natural boundary conditions.
<li>GSL::Interpolation::AKIMA_PERIODIC<br>
Akima spline with periodic boundary conditions.
</ul>
The following related functions are available:
<p>
<tt>GSL::Interpolation::Interp#name</tt><br>
<tt>interp1.name() -> aString</tt><br>

This function returns the name of the interpolation type used by interp. 
<p>
<tt>GSL::Interpolation::Interp#min_size</tt><br>
<tt>interp1.min_size() -> anInteger</tt><br>

This method returns the minimum number of points required by the
interpolation type of interp. For example, Akima spline interpolation
requires a minimum of 5 points.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math
include GSL::Interpolation

x = []
y = []
0.upto(9) do |i|
  x[i] = i + 0.5 * sin(i)
  y[i] = i + cos(i * i)
end

i = Interp.new(Interp::LINEAR, 10)
i.init(x, y)

assert i.name == "linear" &amp;&amp; i.min_size == 2
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Index Look-up and Acceleration</h3>

The state of searches can be stored in a gsl_interp_accel object, which
is a kind of iterator for interpolation lookups. It caches the previous
value of an index lookup. When the subsequent interpolation point falls
in the same interval its index value can be returned immediately.

<h3>Class Accel</h3>
The class Accel is defined under the module Interpolation.
<p>
<tt>GSL::Interpolation::Accel::new</tt><br>
<tt>Accel.new() -> acc1</tt><br>
It returns an Accel object.
<p>
<tt>GSL::Interpolation::Accel#bsearch</tt><br>
<tt>acc1.bsearch(x_array, x, index_lo, index_hi) -> anInteger</tt><br>
Array x_array; integer index_lo, index_hi<br>
This function returns the index i of
the array x_array such that x_array[i] <= x < x_array[i+1]. The index
is searched for in the range [index_lo,index_hi].

<p>
<tt>GSL::Interpolation::Accel#find</tt><br>
<tt>acc1.find(x_array, x) -> anInteger</tt><br>
Array x_array; double x<br>
This function performs a
lookup action on the data array x_array, using the given
accelerator acc1. This is how lookups are performed during evaluation of
an interpolation. The function returns an index i such that xarray[i]
<= x < xarray[i+1].
<p> 
<tt>GSL::Interpolation::Accel#reset</tt><br>
<tt>acc1.reset() -> status</tt><br>
This method resets the Accel object inner parameters to zero.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math
include GSL::Interpolation

x = []
y = []
0.upto(9) do |i|
  x[i] = i + 0.5 * sin(i)
  y[i] = i + cos(i * i)
end

i = Interp.new(Interp::LINEAR, 10)
i.init(x, y)

acc = Accel.new
xi = x[0]

while (xi &lt; x[9]) do
  yi = i.eval(x, y, xi, acc)
  printf "%g %g\n", xi, yi
  xi += 1
end

p x
puts "bsearch"
p acc.bsearch(x, 2.8, 1, 8)

puts "find"
p acc.find(x, 2.8)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Evaluation of Interpolating Functions</h3>
<tt>GSL::Interpolation::Interp#eval</tt><br>
<tt>interp1.eval(xa, ya, x, a) -> aDouble</tt><br>
Array xa, ya; double x; GSL::Interpolation::Accel a<br>
This method
returns the interpolated value of y for a given point x, using the
interpolation object interp1, data arrays xa and ya and the accelerator a.
<p>
<tt>GSL::Interpolation::Interp#eval_e</tt><br>
<tt>interp1.eval_e(xa, ya, x, a, res) -> status</tt><br>
Array xa, ya; double x; GSL::Interpolation::Accel a; GSL::Result res<br>
(NOT TESTED)<br>
<p>
<tt>GSL::Interpolation::Interp#deriv</tt><br> 
<tt>interp1.deriv(xa, ya, x, a) -> d</tt><br> 
Array xa, ya; double x; GSL::Interpolation::Accel a; double d<br> 
This method returns the derivative d of an interpolated
function for a given point x, using the interpolation object interp1,
data arrays xa and ya and the accelerator a.
<p>
<tt>GSL::Interpolation::Interp#deriv_e</tt><br> 
<tt>interp1.deriv_e(xa, ya, x, a, res) -> status</tt><br> 
Array xa, ya; double x; GSL::Interpolation::Accel a; GSL::Result res<br>
(NOT TESTED)<br> 
<p>
<tt>GSL::Interpolation::Interp#deriv2</tt><br>
<tt>interp1.deriv2(xa, ya, x, a) -> d2</tt><br>
Array xa, ya; double x; GSL::Interpolation::Accel a; double d<br>
This method returns the second derivative d2 of an interpolated
function for a given point x, using the interpolation object interp,
data arrays xa and ya and the accelerator a.
<p>
<tt>GSL::Interpolation::Interp#deriv2_e</tt><br>
<tt>interp1.deriv2_e(xa, ya, x, a, res) -> status</tt><br>
Array xa, ya; double x; GSL::Interpolation::Accel a; GSL::Result res<br>
(NOT TESTED)<br>
<p>
<tt>GSL::Interpolation::Interp#integ</tt><br>
<tt>interp1.integ(xa, ya, a, b, acc) -> aDouble</tt><br>
Array xa, ya; double a, b; GSL::Interpolation::Accel acc<br>
This method returns
the numerical integral result of an interpolated function over the range
[a, b], using the interpolation object interp, data arrays xa and ya
and the accelerator a.
<p>
<tt>GSL::Interpolation::Interp#integ_e</tt><br>
(NOT TESTED)<br>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math
include GSL::Interpolation
require 'gsl_util'

x = []
y = []
0.upto(9) do |i|
  x[i] = i
  y[i] = i * i + 1
end

acc = Accel.new
i = GSL::Interpolation::Interp.new(POLYNOMIAL, 10)
i.init(x, y)

xi = x[0]

  while (xi &lt; x[9]) do
    yi = i.eval(x, y, xi, acc)
    assert yi =~ [xi * xi + 1, 1.0e-13]
    assert i.eval_deriv(x, y, xi, acc) =~ 2 * xi
    assert i.eval_deriv2(x, y, xi, acc) == 2
    xi += 0.01
  end

assert i.eval_integ(x, y, 0, 1, acc) == 4.0/3

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Higher-level Interface</h3>

The functions described in the previous sections required the user
to supply pointers to the x and y arrays on each call. The following
functions are equivalent to the corresponding gsl_interp functions but
maintain a copy of this data in the gsl_spline object. This removes
the need to pass both xa and ya as arguments on each evaluation. These
functions are defined in the header file `gsl_spline.h'.

<h3>Class Spline</h3>
The class Spline  is defined under the  module Interpolation.
<p>
<tt>GSL::Interpolation::Spline::new</tt><br>
<tt>Spline.new(func, size) -> spline1</tt><br> 
It returns a Spline object of type T for <tt>size</tt> data-points.

<p>
<tt>GSL::Interpolation::Spline#init</tt><br>
<tt>spline1.init(xa, ya)</tt><br>
Array xa, ya<br>

This method initializes the
Spline object <tt>spline1</tt> for the data (xa,ya) where xa and ya are
arrays of doubles. 
The xa data array is always assumed to be strictly ordered;
the behavior for other arrangements is not defined.


<h3>Evaluation of Interpolating Functions</h3>
<tt>GSL::Interpolation::Spline#eval</tt><br>
<tt>spline1.eval(x, a) -> aDouble</tt><br>
double x; GSL::Interpolation::Accel a<br>
This method
returns the interpolated value of y for a given point x, using the
interpolation object interp1 and the accelerator a.

<p>
<tt>GSL::Interpolation::Spline#deriv</tt><br> 
<tt>spline1.deriv(x, a) -> d</tt><br> 
double x; GSL::Interpolation::Accel a; double d<br>
This method returns the derivative d of an interpolated
function for a given point x, using the interpolation object spline1
and the accelerator a.
<p>
<tt>GSL::Interpolation::Spline#deriv_e</tt><br> 
(NOT TESTED)<br> 
<p>
<tt>GSL::Interpolation::Spline#deriv2</tt><br>
<tt>spline1.deriv2(x, a) -> d2</tt><br>
double x; GSL::Interpolation::Accel a; double d<br>
This method returns the second derivative d2 of an interpolated
function for a given point x, using the interpolation object spline1
and the accelerator a.
p>
<tt>GSL::Interpolation::Spline#deriv2_e</tt><br>
(NOT TESTED)<br>  


<p>
<tt>GSL::Interpolation::Spline#integ</tt><br>
<tt>spline1.integ(xa, ya, a, b, acc) -> aDouble</tt><br>
Array xa, ya; double a, b; GSL::Interpolation::Accel acc<br>
This method returns
the numerical integral result of an interpolated function over the range
[a, b], using the interpolation object interp, data arrays xa and ya
and the accelerator a.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math
include GSL::Interpolation
require 'gsl_util'

x = []
y = []
0.upto(9) do |i|
  x[i] = i
  y[i] = i * i + 1
end

acc = Accel.new
i = Spline.new(POLYNOMIAL, 10)
i.init(x, y)

xi = x[0]

  while (xi &lt; x[9]) do
    yi = i.eval(xi, acc)
    assert yi =~ [xi * xi + 1, 1.0e-13]
    assert i.eval_deriv(xi, acc) =~ 2 * xi
    assert i.eval_deriv2(xi, acc) == 2
    
    xi += 0.01
  end

assert i.eval_integ(0, 1, acc) == 4.0/3
  

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Example</h3>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: interp.html,v 1.1 2003/09/20 12:17:22 pernici Exp $

require "GSL"
include GSL

# Test module Interpolation
# generate output suitable for graph(1) from GNU plotutils:
# interp.rb | graph -Tps &gt; interp.ps

STDERR.puts "Running interpolation tests (interp)..."

x = []
y = []
puts "#m=0,S=2"
0.upto(9) do |i|
  x[i] = i + 0.5 * Special::Trig::sin(i)
  y[i] = i + Special::Trig::cos(i * i)
  printf "%g %g\n", x[i], y[i]
end

acc = Interpolation::Accel.new
type = [Interpolation::LINEAR, Interpolation::CSPLINE, Interpolation::AKIMA]
type.each_index do |k|
  i = Interpolation::Interp.new type[k], 10
  #STDERR.print "#{i.name}\n"
  ret = i.init x, y
  STDERR.puts strerror(ret) if ret != GSL_SUCCESS

  puts "#m=#{k},S=0"
  xi = x[0]
  d = Result.new
  while (xi &lt; x[9]) do
    yi = i.eval x, y, xi, acc
    printf "%g %g\n", xi, yi
    xi += 0.01
  end

  acc.reset
end

STDERR.puts "\ndone."
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>References and Further Reading</h3>
Descriptions of the interpolation algorithms and further references can be 
found in the following book,
<ul><li>
C.W. Ueberhuber, Numerical Computation (Volume 1), Chapter 9 "Interpolation", 
Springer (1997), ISBN 3-540-62058-3.
</ul>
    

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="diff.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href=".html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Interpolation</td> 
</tr></tbody></table><hr></body>
</html>
