<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Monte Carlo Integration</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href=".html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href=".html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Monte Carlo Integration</td> 
</tr></tbody></table><hr><h1>
Monte Carlo Integration</h1>
<hr>

This chapter describes routines for multidimensional Monte Carlo
integration. These include the traditional Monte Carlo method and adaptive
algorithms such as VEGAS and MISER which use importance sampling and
stratified sampling techniques. Each algorithm computes an estimate of
a multidimensional definite integral of the form,
<br>
I = \int_xl^xu dx \int_yl^yu  dy ...  f(x, y, ...)
<br>
over a hypercubic region ((x_l,x_u), (y_l,y_u), ...) using a fixed number
of function calls. The routines also provide a statistical estimate of
the error on the result. This error estimate should be taken as a guide
rather than as a strict error bound --- random sampling of the region
may not uncover all the important features of the function, resulting
in an underestimate of the error.
<br>
The functions are defined in separate header files for each routine,
gsl_monte_plain.h, `gsl_monte_miser.h' and `gsl_monte_vegas.h'.  

<h3>Interface</h3>

All of the Monte Carlo integration routines use the same interface. There
is an allocator to allocate memory for control variables and workspace,
a routine to initialize those control variables, the integrator itself,
and a function to free the space when done.
Each integration function requires a random number generator to be
supplied, and returns an estimate of the integral and its standard
deviation. The accuracy of the result is determined by the number of
function calls specified by the user. If a known level of accuracy is
required this can be achieved by calling the integrator several times and
averaging the individual results until the desired accuracy is obtained.
<p>
Random sample points used within the Monte Carlo routines are always
chosen strictly within the integration region, so that endpoint
singularities are automatically avoided.
<p>
The function to be integrated has its own datatype, defined in the header
file `gsl_monte.h'.
<ul>
Data Type: gsl_monte_function
<br>
This data type defines a general function with parameters for Monte
Carlo integration.
<li>
double (* f) (double * x, size_t dim, void * params) <br>
this function should
return the value f(x,params) for argument x and parameters params, where
x is an array of size dim giving the coordinates of the point where the
function is to be evaluated. 
<li>size_t dim <br>
the number of dimensions for x
<li>void * params <br>
a pointer to the parameters of the function
</ul>

<h3>PLAIN Monte Carlo</h3>

The plain Monte Carlo algorithm samples points randomly from the
integration region to estimate the integral and its error. Using this
algorithm the estimate of the integral E(f; N) for N randomly distributed
points x_i is given by,<br>

E(f; N) ==  V <f> = (V / N) \sum_i^N f(x_i).
<br>
where V is the volume of the integration region. The error on this
estimate \sigma(E;N) is calculated from the estimated variance of
the mean,
<br>
\sigma^2 (E; N) = (V / N) \sum_i^N (f(x_i) -  <f>)^2
<br>
For large N this variance decreases asymptotically as var(f)/N,
where var(f) is the true variance of the function over the
integration region. The error estimate itself should decrease as
\sigma(f)/\sqrt{N}. The familiar law of errors decreasing as 1/\sqrt{N}
applies -- to reduce the error by a factor of 10 requires a 100-fold
increase in the number of sample points.
The functions described in this section are declared in the header file
`gsl_monte_plain.h'

<h3>Module MonteCarlo</h3>

<h4>Class Function</h4>
The class Function is defined under the module MonteCarlo
<tt>GSL::MonteCarlo::Function::new</tt><br>
<tt>Function.new(dim, param, proc) -> f</tt><br>
where proc is a Proc object with two parameters; the first is an
array, the second is the parameter, which can be a double, or a
struct of doubles (or else) as in the following example.

<h4>Class Plain</h4>
It is a subclass of GSL::MonteCarlo .
<tt>GSL::MonteCarlo::Plain::new</tt><br>
<tt>Plain.new(dim) -> plain1</tt><br>
integer dim<br>
It returns an object of the Plain class, to perform plain 
MonteCarlo integration in <tt>dim</tt> dimensions.
<p>
<tt>GSL::MonteCarlo::Plain#integrate</tt><br>
<tt>plain1.integrate(f, xl, xu, calls, r) -> [result, abserr]</tt><br>
Function f; Array xl, xu; integer calls, Random::RNG r<br>
This routine uses the plain Monte Carlo algorithm to integrate the
function <tt>f</tt> over the dim-dimensional hypercubic region defined by the
lower and upper limits in the arrays <tt>xl</tt> and <tt>xu</tt>, 
each of size <tt>dim</tt>. The
integration uses a fixed number of function calls <tt>calls</tt>, and obtains
random sampling points using the random number generator <tt>r</tt>. 
The result of the integration is returned in <tt>result</tt>, 
with an estimated absolute error <tt>abserr</tt>.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL; include Math
include GSL::MonteCarlo

p1 = Proc.new {|k, p| p * k[0] }
param1 = 10; dim1 = 1
f1 = Function.new(dim1, param1, p1)
plain1 = Plain.new(dim1)

xl1 = [0]; xu1 = [2]; calls1 = 100000
rng1 = Random::RNG.new

p plain1.integrate(f1, xl1, xu1, calls1, rng1)

struct = Struct.new("Params", :a, :b, :c)
params = struct.new(1, 2, 3)
p2 = Proc.new {|x, p| p.a * x[0] + p.b * x[0] * x[1]}
dim2 = 2
f2 = Function.new(dim2, params, p2)
assert f2.eval([1,2], params) == 5
plain2 = Plain.new(dim2)
xl2 = [0,0]; xu2 = [1,1];  calls2 = 100000
rng2 = Random::RNG.new
p plain2.integrate(f2, xl2, xu2, calls2, rng2)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>MISER</h3>

The MISER algorithm of Press and Farrar is based on recursive stratified
sampling. This technique aims to reduce the overall integration error
by concentrating integration points in the regions of highest variance.
<br>
The idea of stratified sampling begins with the observation that for
two disjoint regions a and b with Monte Carlo estimates of the integral
E_a(f) and E_b(f) and variances \sigma_a^2(f) and \sigma_b^2(f), the
variance Var(f) of the combined estimate E(f) = (1/2) (E_a(f) + E_b(f))
is given by,
<br>
Var(f) = (\sigma_a^2(f) / 4 N_a) + (\sigma_b^2(f) / 4 N_b)
<br>
It can be shown that this variance is minimized by distributing the
points such that,
<br>
N_a / (N_a + N_b) = \sigma_a / (\sigma_a + \sigma_b)
<br>
Hence the smallest error estimate is obtained by allocating sample
points in proportion to the standard deviation of the function in each
sub-region.

<h4>Class Miser</h4>
It is a subclass of GSL::MonteCarlo .
<tt>GSL::MonteCarlo::Miser::new</tt><br>
<tt>Miser.new(dim) -> m1</tt><br>
integer dim<br>
It returns an object of the Miser class, to perform 
MonteCarlo integration with the MISER algorithm in <tt>dim</tt> dimensions.
<p>
<tt>GSL::MonteCarlo::Miser#integrate</tt><br>
<tt>m1.integrate(f, xl, xu, calls, r) -> [result, abserr]</tt><br>
Function f; Array xl, xu; integer calls, Random::RNG r<br>
Function f; Array xl, xu; integer calls, Random::RNG r<br>
This routine uses the Miser Monte Carlo algorithm to integrate the
function <tt>f</tt> over the dim-dimensional hypercubic region defined by the
lower and upper limits in the arrays <tt>xl</tt> and <tt>xu</tt>,
each of size <tt>dim</tt>. The
integration uses a fixed number of function calls <tt>calls</tt>, and obtains
random sampling points using the random number generator <tt>r</tt>.
The result of the integration is returned in <tt>result</tt>,
with an estimated absolute error <tt>abserr</tt>.
<p>
<tt>GSL::MonteCarlo::Miser#estimate_frac</tt><br>
<tt>m1.estimate_frac() -> aDouble</tt><br>

This method specifies the fraction of
the currently available number of function calls which are allocated to
estimating the variance at each recursive step. The default value is 0.1.
<p>
<tt>GSL::MonteCarlo::Miser#min_calls</tt><br>
<tt>m1.min_calls -> anInteger</tt><br>
This method specifies the minimum number of
function calls required for each estimate of the variance. If the number
of function calls allocated to the estimate using estimate_frac falls
below min_calls then min_calls are used instead. This ensures that each
estimate maintains a reasonable level of accuracy. The default value of
min_calls is 16 * dim.
<p>
<tt>GSL::MonteCarlo::Miser#min_calls=</tt><br>
<tt>m1.min_calls = v</tt><br>
integer v<br>
This method  sets the minimum number of
function calls required for each estimate of the variance.
<p>
<tt>GSL::MonteCarlo::Miser#min_calls_per_bisection</tt><br>
<tt>m1.min_calls_per_bisection() -> anInteger</tt><br>

This method specifies
the minimum number of function calls required to proceed with a
bisection step. When a recursive step has fewer calls available than
min_calls_per_bisection it performs a plain Monte Carlo estimate of
the current sub-region and terminates its branch of the recursion. The
default value of this parameter is 32 * min_calls.

<p>
<tt>GSL::MonteCarlo::Miser#alpha</tt><br>
<tt>m1.alpha() -> aDouble</tt><br>
This method gives the estimated variances
for the two sub-regions of a bisection are combined when allocating
points. With recursive sampling the overall variance should scale better
than 1/N, since the values from the sub-regions will be obtained using
a procedure which explicitly minimizes their variance. To accommodate
this behavior the MISER algorithm allows the total variance to depend
on a scaling parameter \alpha,
<br>
Var(f) = {\sigma_a \over N_a^\alpha} + {\sigma_b \over N_b^\alpha}
<br>
The authors of the original paper describing MISER recommend the value
\alpha = 2 as a good choice, obtained from numerical experiments, and
this is used as the default value in this implementation.
<p>
<tt>GSL::MonteCarlo::Miser#alpha=</tt><br>
<tt>m1.alpha = v</tt><br>
double v<br>
This method sets the estimated variances
for the two sub-regions of a bisection are combined when allocating
points. 
p>
<tt>GSL::MonteCarlo::Miser#dither</tt><br>
<tt>m1.dither() -> aDouble</tt><br>

This method returns the random fractional
variation of size dither into each bisection, which can be used to break
the symmetry of integrands which are concentrated near the exact center of
the hypercubic integration region. The default value of dither is zero,
so no variation is introduced. If needed, a typical value of dither is
around 0.1.

<p>
<tt>GSL::MonteCarlo::Miser#dither=</tt><br>
<tt>m1.dither = v</tt><br>
double v<br> 
This method sets the  random fractional
variation of size dither into each bisection.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL; include Math
include GSL::MonteCarlo

struct = Struct.new("Params", :a, :b, :c)
params = struct.new(1, 2, 3)
p2 = Proc.new {|x, p| p.a * x[0] + p.b * x[0] * x[1]}
dim2 = 2
f2 = Function.new(dim2, params, p2)
assert f2.eval([1,2], params) == 5
m2 = Miser.new(dim2)
xl2 = [0,0]; xu2 = [1,1];  calls2 = 100000
rng2 = Random::RNG.new
p m2.integrate(f2, xl2, xu2, calls2, rng2)

puts "estimate_frac"
p m2.estimate_frac

puts "min_calls"
p m2.min_calls

puts "min_calls="
m2.min_calls = 40
p m2.min_calls

puts "min_calls_per_bisection"
p m2.min_calls_per_bisection

puts "alpha"
p m2.alpha

puts "alpha="
m2.alpha = 2.3
p m2.alpha

puts "dither"
p m2.dither

puts "dither="
m2.dither = 0.1
p m2.dither

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>VEGAS</h3>

The VEGAS algorithm of Lepage is based on importance sampling. It samples
points from the probability distribution described by the function |f|,
so that the points are concentrated in the regions that make the largest
contribution to the integral.
<br>
In general, if the Monte Carlo integral of f is sampled with points
distributed according to a probability distribution described by the
function g, we obtain an estimate E_g(f; N),
<br>
E_g(f; N) = E(f/g; N)
<br>
with a corresponding variance,
<br>
Var_g(f; N) = Var(f/g; N)
<br>
If the probability distribution is chosen as g = |f|/I(|f|) then it
can be shown that the variance V_g(f; N) vanishes, and the error in
the estimate will be zero. In practice it is not possible to sample
from the exact distribution g for an arbitrary function, so importance
sampling algorithms aim to produce efficient approximations to the
desired distribution.
The VEGAS algorithm approximates the exact distribution by making a
number of passes over the integration region while histogramming the
function f. Each histogram is used to define a sampling distribution
for the next pass. Asymptotically this procedure converges to the
desired distribution. In order to avoid the number of histogram bins
growing like K^d the probability distribution is approximated by a
separable function: g(x_1, x_2, ...) = g_1(x_1) g_2(x_2) ... so that
the number of bins required is only Kd. This is equivalent to locating
the peaks of the function from the projections of the integrand onto
the coordinate axes. The efficiency of VEGAS depends on the validity of
this assumption. It is most efficient when the peaks of the integrand
are well-localized. If an integrand can be rewritten in a form which is
approximately separable this will increase the efficiency of integration
with VEGAS.
<br>
VEGAS incorporates a number of additional features, and combines both
stratified sampling and importance sampling. The integration region is
divided into a number of "boxes", with each box getting in fixed number
of points (the goal is 2). Each box can then have a fractional number
of bins, but if bins/box is less than two, Vegas switches to a kind
variance reduction (rather than importance sampling).

<h4>Class Vegas</h4>
The class Vegas is a subclass of the module MonteCarlo
<p>
<tt>GSL::MonteCarlo::initialize</tt><br>
(SKIPPED)<br>
Function: int gsl_monte_vegas_init (gsl_monte_vegas_state* s) This
function initializes a previously allocated integration state. This
allows an existing workspace to be reused for different integrations.
<p>
<tt>GSL::MonteCarlo::Vegas::new</tt><br>
<tt>Vegas.new(dim) -> v1</tt><br>
integer dim<br>
It returns an object of the Vegas class, to perform
MonteCarlo integration with the Vegas algorithm in <tt>dim</tt> dimensions.
<p>
<tt>GSL::MonteCarlo::Vegas#integrate</tt><br>
<tt>v1.integrate(f, xl, xu, calls, r) -> [result, abserr]</tt><br>
Function f; Array xl, xu; integer calls, Random::RNG r<br>
Function f; Array xl, xu; integer calls, Random::RNG r<br>
This routine uses the Miser Monte Carlo algorithm to integrate the
function <tt>f</tt> over the dim-dimensional hypercubic region defined by the
lower and upper limits in the arrays <tt>xl</tt> and <tt>xu</tt>,
each of size <tt>dim</tt>. The
integration uses a fixed number of function calls <tt>calls</tt>, and obtains
random sampling points using the random number generator <tt>r</tt>.
The result of the integration is returned in <tt>result</tt>,
with an estimated absolute error <tt>abserr</tt>.
<p>
<tt>GSL::MonteCarlo::Vegas#sigma</tt><br>
<tt>v1.sigma() -> aDouble</tt><br>
This method contains the raw value of the integral result 
from the last iteration of the algorithm.
<p>
<tt>GSL::MonteCarlo::Vegas#result</tt><br>
<tt>v1.result() -> aDouble</tt><br>
 This method contains the error sigma of the integral result 
 from the last iteration of the algorithm.
<p>
<tt>GSL::MonteCarlo::Vegas#iterations</tt><br>
<tt>v1.iterations() -> anInteger</tt><br>
This method returns the number of iterations to perform for each
call to the routine. The default value is 5 iterations.  
<p>
<tt>GSL::MonteCarlo::Vegas#iterations =</tt><br>
<tt>v1.iterations -> v</tt><br>
integer v<br>
This method sets the number of iterations to perform for each
call to the routine.
<p>
<tt>GSL::MonteCarlo::Vegas#stage</tt><br>
<tt>v1.stage() -> anInteger</tt><br>
This method  determines the stage of the calculation. Normally,
stage = 0 which begins with a new uniform grid and empty weighted
average. Calling vegas with stage = 1 retains the grid from the
previous run but discards the weighted average, so that one can "tune"
the grid using a relatively small number of points and then do a large
run with stage = 1 on the optimized grid. Setting stage = 2 keeps the
grid and the weighted average from the previous run, but may increase
(or decrease) the number of histogram bins in the grid depending on the
number of calls available. Choosing stage = 3 enters at the main loop,
so that nothing is changed, and is equivalent to performing additional
iterations in a previous call.

<p>
<tt>GSL::MonteCarlo::Vegas#stage=</tt><br>
<tt>v1.stage = v</tt><br>
integer v<br>
<p>
<tt>GSL::MonteCarlo::Vegas#alpha</tt><br>
<tt>v1.alpha() -> aDouble</tt><br>
This method determines the parameter alpha, which  controls the stiffness 
of the rebinning algorithm. It is typically set between one and two. A value
of zero prevents rebinning of the grid. The default value is 1.5.

<p>
<tt>GSL::MonteCarlo::Vegas#alpha=</tt><br>
<tt>v1.alpha = v</tt><br>
This method sets the parameter alpha, which  controls the stiffness 
of the rebinning algorithm.
<p>
<tt>GSL::MonteCarlo::Vegas#chisq</tt><br>
<tt>v1.chisq() -> aDouble</tt><br>

This method returns the parameter which gives the chi-squared per degree
of freedom for the weighted estimate of the integral. The value of chisq
should be close to 1. A value of chisq which differs significantly from 1
indicates that the values from different iterations are inconsistent. In
this case the weighted error will be under-estimated, and further
iterations of the algorithm are needed to obtain reliable results.
<p>
<tt>GSL::MonteCarlo::Vegas#chisq=</tt><br>
<tt>v1.chisq = v</tt><br>
double v<br>
This method sets the parameter which gives the chi-squared per degree
of freedom for the weighted estimate of the integral. 
<p>
<tt>GSL::MonteCarlo::Vegas#mode</tt><br>
<tt>v1.mode() -> anInteger</tt><br>

The possible values returned are GSL_VEGAS_MODE_IMPORTANCE,
GSL_VEGAS_MODE_STRATIFIED, GSL_VEGAS_MODE_IMPORTANCE_ONLY. This determines
whether VEGAS will use importance sampling or stratified sampling,
or whether it can pick on its own. In low dimensions VEGAS uses strict
stratified sampling (more precisely, stratified sampling is chosen if
there are fewer than 2 bins per box).

<p>
<tt>GSL::MonteCarlo::Vegas#mode=</tt><br>
<tt>v1.chisq = v</tt><br>
integer v<br>
This method sets one of the values GSL_VEGAS_MODE_IMPORTANCE,
GSL_VEGAS_MODE_STRATIFIED, GSL_VEGAS_MODE_IMPORTANCE_ONLY.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
include GSL; include Math
include GSL::MonteCarlo

struct = Struct.new("Params", :a, :b, :c)
params = struct.new(1, 2, 3)
p2 = Proc.new {|x, p| p.a * x[0] + p.b * x[0] * x[1]}
dim2 = 2
f2 = Function.new(dim2, params, p2)
assert f2.eval([1,2], params) == 5
m2 = Vegas.new(dim2)
xl2 = [0,0]; xu2 = [1,1];  calls2 = 100000
rng2 = Random::RNG.new
p m2.integrate(f2, xl2, xu2, calls2, rng2)

puts "sigma"
p m2.sigma

puts "result"
p m2.result

puts "iterations"
p m2.iterations

puts "iterations="
m2.iterations = 6
p m2.iterations

puts "stage"
p m2.stage

puts "stage="
m2.stage = 2
p m2.stage

puts "alpha"
p m2.alpha

puts "alpha="
m2.alpha = 1.6
p m2.alpha

puts "chisq"
p m2.chisq

puts "chisq="
m2.chisq = 1.0003
p m2.chisq

puts "mode"
p m2.mode

assert Vegas::MODE_IMPORTANCE == 1 &amp;&amp; Vegas::MODE_IMPORTANCE_ONLY == 0 &amp;&amp;
 Vegas::MODE_STRATIFIED == -1

puts "mode"
m2.mode = Vegas::MODE_IMPORTANCE 
assert m2.mode == Vegas::MODE_IMPORTANCE
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Example</h3>
The example program below uses the Monte Carlo routines to estimate
the value of the following 3-dimensional integral from the theory of
random walks,
<br>
I = \int_{-pi}^{+pi} {dk_x/(2 pi)} \int_{-pi}^{+pi} {dk_y/(2 pi)}
\int_{-pi}^{+pi} {dk_z/(2 pi)} 1 / (1 - cos(k_x)cos(k_y)cos(k_z))
<br>
The analytic value of this integral can be shown to be I =
\Gamma(1/4)^4/(4 \pi^3) = 1.393203929685676859.... The integral gives
the mean time spent at the origin by a random walk on a body-centered
cubic lattice in three dimensions.
<br>
For simplicity we will compute the integral over the region (0,0,0) to
(\pi,\pi,\pi) and multiply by 8 to obtain the full result. The integral
is slowly varying in the middle of the region but has integrable
singularities at the corners (0,0,0), (0,\pi,\pi), (\pi,0,\pi) and
(\pi,\pi,0). The Monte Carlo routines only select points which are
strictly within the integration region and so no special measures are
needed to avoid these singularities.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: monte.html,v 1.1 2003/09/09 22:15:25 pernici Exp $

require "GSL"
include GSL
include Math
include GSL::MonteCarlo

STDERR.puts "Running tests for Monte Carlo integration..."

def display(msg, r)
  result = r[0]
  abserr = r[1]
  exact = 1.3932039296856768591842462603255
  puts msg
  printf "result = % .6f\n", result
  printf "sigma  = % .6f\n", abserr
  printf "exact  = % .6f\n", exact
  error = result - exact
  printf "error  = % .6f = %.1g sigma\n", error, error.abs / abserr
end

# toy example, pass parameters as a Struct

#struct = Struct.new("Params", :a, :b, :c)
#params = struct.new(1, 2, 3)

#p1 = Proc.new {|x, p|
#  p.a * x[0] * x[0] + p.b * x[0] * x[1] + p.c * x[1] * x[1]
#}

#x = [1, 2, 1]
#dim = 3

#f = Function.new dim, params, p1
#y = f.eval x, params

# now a real example (used to crash sometimes)

p2 = Proc.new {|k, p|
  p / (1.0 - cos(k[0]) * cos(k[1]) * cos(k[2]))
}

dim = 3
A = 1.0 / (M_PI * M_PI * M_PI)
f = Function.new dim, A, p2

xl = [0.0, 0.0, 0.0]
xu = [M_PI, M_PI, M_PI]
rng = Random::RNG.new

puts
plain = Plain.new dim
calls = 5000000
r = plain.integrate f, xl, xu, calls, rng
display "Plain", r

puts
miser = Miser.new dim

#puts miser.estimate_frac
#puts miser.min_calls
#puts miser.min_calls_per_bisection
#puts miser.alpha
#puts miser.dither


r = miser.integrate f, xl, xu, calls, rng
display "Miser", r

puts
vegas = Vegas.new dim

r = vegas.integrate f, xl, xu, 10000, rng
display "Vegas warmup", r
puts "converging..."
calls =  calls / 5
#while (vegas.chisq - 1.0).abs &gt; 0.5 do
  r = vegas.integrate f, xl, xu, calls, rng
  printf "result = % .6f sigma = % .6f chisq/dof = %.1f\n",
    r[0], r[1], vegas.chisq
#end
display "Vegas final", r

STDERR.puts "\ndone."
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
With 500,000 function calls the plain Monte Carlo algorithm achieves a
fractional error of 0.6%. The estimated error sigma is consistent with
the actual error, and the computed result differs from the true result
by about one standard deviation,
<pre>
plain ================== 
result =  1.385867 
sigma  =  0.007938 
exact  =
1.393204 
error  = -0.007337 = 0.9 sigma
</pre>
The MISER algorithm reduces the error by a factor of two, and also
correctly estimates the error,
<pre>
miser ================== 
result =  1.390656 
sigma  =  0.003743 
exact  =
1.393204 
error  = -0.002548 = 0.7 sigma
</pre>
In the case of the VEGAS algorithm the program uses an initial warm-up
run of 10,000 function calls to prepare, or "warm up", the grid. This is
followed by a main run with five iterations of 100,000 function calls. The
chi-squared per degree of freedom for the five iterations are checked
for consistency with 1, and the run is repeated if the results have not
converged. In this case the estimates are consistent on the first pass.
<pre>
vegas warm-up ================== 
result =  1.386925 sigma  =  0.002651
exact  =  1.393204 
error  = -0.006278 = 2 sigma 
converging...  
result = 1.392957 sigma =  0.000452 chisq/dof = 1.1 
vegas final ==================
result =  1.392957 
sigma  =  0.000452 
exact  =  1.393204 
error  = -0.000247 = 0.5 sigma
</pre>
If the value of chisq had differed significantly from 1 it would indicate
inconsistent results, with a correspondingly underestimated error. The
final estimate from VEGAS (using a similar number of function calls)
is significantly more accurate than the other two algorithms.

<h3>Inlining the MonteCarlo code</h3>
Using the module <tt>MInline.rb </tt> (see the <tt>contrib/</tt> directory)
one can compile on the run the C function
to be integrated with the function <br>
<tt>MInline::compile(String1, String2)</tt><br>
where <tt>String1 </tt> contains the C function definition and the 
definition of the parameters; <tt>String2 </tt> is a name associated to this
function. Then put <br>
<tt>include GSL::MonteCarlo_String2</tt><br> and continue as with the
previous examples. 
<p>
A temporary file <tt>MonteCarlo_String2.c </tt> is generated, and then
compiled. To make compilation work, put at the beginning of  
<tt>MInline.rb</tt>
<pre>
require "rbconfig"
require "ftools"

module MInline

   def MInline::compile(a, foo)
##############################################   
#  Configuration
#  Set rgsldir = ruby_gsl_install_dir 
</pre>
the path of the ruby-gsl sources. If compilation works, after execution
the temporary files are cancelled, otherwise they remain, so one can
debug the code.
<p>
For instance
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math

require "MInline"

puts "First test"
MInline::compile(%Q{
#include &lt;math.h

struct my_f_params { double a; double b; double c; };

static double g1x (double * x, size_t dim, void * p) {
    struct my_f_params * fp = (struct my_f_params *)p;
    if (dim != 2) {
      fprintf(stderr, "error: dim != 2");
      abort();
    }

   return  fp-&gt;a * x[0]  + fp-&gt;b * x[0] * x[1];
}

   struct my_f_params params = { 1.0, 2.0, 3.0 };
   static gsl_monte_function MC_FNCT  = {&amp;g1x, 2, &amp;params};

 }, "qua")

include GSL::MonteCarlo_qua
dim2 = 2
 
plain2 = Plain.new(dim2)
xl2 = [0,0]; xu2 = [1,1];  calls2 = 100000
rng2 = Random::RNG.new
p plain2.integrate(xl2, xu2, calls2, rng2)

puts "Second test"
STDERR.puts "Running tests for Monte Carlo integration..."

def display(msg, r)
  result = r[0]
  abserr = r[1]
  exact = 1.3932039296856768591842462603255
  puts msg
  printf "result = % .6f\n", result
  printf "sigma  = % .6f\n", abserr
  printf "exact  = % .6f\n", exact
  error = result - exact
  printf "error  = % .6f = %.1g sigma\n", error, error.abs / abserr
end

MInline::compile("
#include &lt;math.h&gt;
static double
g1x (double *k, size_t dim, void *params)
{
  double A = 1.0 / (M_PI * M_PI * M_PI);
  return A / (1.0 - cos (k[0]) * cos (k[1]) * cos (k[2]));
}

static gsl_monte_function MC_FNCT = { &amp;g1x, 3, 0 };
", "monte2")


include GSL::MonteCarlo_monte2
dim = 3

xl = [0.0, 0.0, 0.0]
xu = [ M_PI, M_PI, M_PI]
rng = Random::RNG.new

puts
plain = Plain.new dim
calls = 500000
puts "calls = #{calls}"
r = plain.integrate xl, xu, calls, rng
display "Plain", r

puts
puts "calls = #{calls}"
miser = Miser.new dim


r = miser.integrate xl, xu, calls, rng
display "Miser", r

puts
vegas = Vegas.new dim
puts "calls = 10000"
r = vegas.integrate xl, xu, 10000, rng
display "Vegas warmup", r
puts "converging..."

calls = calls / 5
puts "calls = #{calls}"
while ((vegas.chisq - 1.0).abs &gt; 0.5) do
  r = vegas.integrate xl, xu, calls, rng
  printf "result = % .6f sigma = % .6f chisq/dof = %.1f\n",
    r[0], r[1], vegas.chisq
end
display "Vegas final", r

STDERR.puts "\ndone."

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>is executed at essentially the same speed as the corresponding GSL executable.

<h3>References and Further Reading</h3>
The MISER algorithm is described in the following article,
<ul><li>
W.H. Press, G.R. Farrar, Recursive Stratified Sampling for
Multidimensional Monte Carlo Integration, Computers in Physics, v4
(1990), pp190-195.
</ul>
The VEGAS algorithm is described in the following papers,
<ul><li>
G.P. Lepage, A New Algorithm for Adaptive Multidimensional Integration,
Journal of Computational Physics 27, 192-203, (1978) 
<li>G.P. Lepage, VEGAS:
An Adaptive Multi-dimensional Integration Program, Cornell preprint CLNS
80-447, March 1980
</ul>


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href=""><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href=""><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Monte Carlo Integration</td> 
</tr></tbody></table><hr></body>
</html>
