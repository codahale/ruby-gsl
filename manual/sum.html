<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Series Acceleration</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="dht.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="cheb.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Series Acceleration</td> 
</tr></tbody></table><hr><h1>
Series Acceleration</h1>
<hr>

The functions described in this chapter accelerate the convergence of a
series using the Levin u-transform. This method takes a small number of
terms from the start of a series and uses a systematic approximation
to compute an extrapolated value and an estimate of its error. The
u-transform works for both convergent and divergent series, including
asymptotic series.
<br>
These functions are declared in the header file `gsl_sum.h'.  

<h3>Module Sum</h3>

<h3>Class Levin</h3>
The class Levin is defined under GSL::Sum 

<h3>Acceleration functions</h3>

The following functions compute the full Levin u-transform of a series
with its error estimate. The error estimate is computed by propagating
rounding errors from each term through to the final extrapolation.
<p>
These functions are intended for summing analytic series where each
term is known to high accuracy, and the rounding errors are assumed to
originate from finite precision. They are taken to be relative errors
of order GSL_DBL_EPSILON for each term.
<p>
The calculation of the error in the extrapolated value is an O(N^2)
process, which is expensive in time and memory. A faster but less reliable
method which estimates the error from the convergence of the extrapolated
value is described in the next section. 
<br>
For the method described here a
full table of intermediate values and derivatives through to O(N) must
be computed and stored, but this does give a reliable error estimate. .
<p>
<tt>GSL::Sum::Levin::new</tt><br>
<tt>Sum::Levin.new(n) -> s1</tt><br>
It returns an object for a Levin u-transform of n terms.
<p>
<a name="size"></a>
<tt>GSL::Sum::Levin#size</tt><br>
<tt>s1.size() -> anInteger</tt><br>
This method returns the number of terms of the Levin u-transform.
<p>
<a name="terms_used"></a>
<tt>GSL::Sum::Levin#terms_used</tt><br>
<tt>s1.terms_used() -> anInteger</tt><br>
This method returns the number of calls made.
<p>
<a name="sum_plain"></a>
<tt>GSL::Sum::Levin#sum_plain</tt><br>
<tt>s1.sum_plain() -> aDouble</tt><br>
This method returns the simple sum of series.
<p>
<a name="accel"></a>
<tt>GSL::Sum::Levin#accel</tt><br>
<tt>s1.accel(array1) -> [sum1, abserr1]</tt><br>
double sum, abserr<br>
This method takes the terms of a series in array1
and computes the extrapolated limit of the series using a Levin u-transform. 
It returns the extrapolated sum sum1 and an estimate of the
absolute error stored in abserr1. 
The algorithm calculates the truncation error (the
difference between two successive extrapolations) and round-off error
(propagated from the individual terms) to choose an optimal number of
terms for the extrapolation.
<p>
<a name="step"></a>
<tt>GSL::Sum::Levin#step</tt><br>
<tt>s1.step(term, n, nmax)-> aDouble</tt><br>
double term; integer n, nmax
SKIPPED<br>
<p>
<a name="minmax"></a>
<tt>GSL::Sum::Levin#minmax</tt><br>
<tt>s1.minmax(array1, min, max) -> [sum1, abserr1]</tt><br>
SKIPPED<br>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL
include Math

N = 20
w= Sum::Levin.new(N)
zeta_2 = M_PI * M_PI / 6.0
n = 0
t = Array.new(N)
sum = 0

while (n &lt; N)
  np = n + 1.0
  t[n] = 1.0 / (np * np)
  sum += t[n]
  n += 1
end


puts "accel"
sum_accel, err = w.accel(t)
p sum_accel, err

puts "term-by-term sum"
p sum

puts "size"
p w.size

puts "terms_used"
p w.terms_used

puts "sum_plain"
p w.sum_plain

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Class LevinTrunc</h3> 
The class LevinTrunc is defined under GSL::Sum .

<h3>Acceleration functions without error estimation</h3>

The functions described in this section compute the Levin u-transform
of series and attempt to estimate the error from the "truncation
error" in the extrapolation, the difference between the final
two approximations. Using this method avoids the need to compute an
intermediate table of derivatives because the error is estimated from the
behavior of the extrapolated value itself. Consequently this algorithm is
an O(N) process and only requires O(N) terms of storage. If the series
converges sufficiently fast then this procedure can be acceptable. It
is appropriate to use this method when there is a need to compute
many extrapolations of series with similar converge properties at
high-speed. For example, when numerically integrating a function defined
by a parameterized series where the parameter varies only slightly. A
reliable error estimate should be computed first using the full algorithm
described above in order to verify the consistency of the results.
<p> 
<tt>GSL::Sum::LevinTrunc::new</tt><br>
<tt>Sum::LevinTrunc.new(n) -> s1</tt><br> 
It returns an object for a truncated Levin u-transform of n terms.
<p>
<a name="size"></a>
<tt>GSL::Sum::LevinTrunc#size</tt><br>
<tt>s1.size() -> anInteger</tt><br> 
This method returns the number of terms of the truncated Levin u-transform.

<p>
<a name="accel"></a>
<tt>GSL::Sum::LevinTrunc#accel</tt><br>
<tt>s1.accel(array1) ->  [sum1, abserr1]</tt><br>
double sum, abserr<br>

This method takes the terms of a series in array of
size array_size and computes the extrapolated limit of the series using
a Levin u-transform. Additional working space must be provided in w. The
extrapolated sum is stored in sum_accel. The actual term-by-term sum is
returned in w->sum_plain. The algorithm terminates when the difference
between two successive extrapolations reaches a minimum or is sufficiently
small. The difference between these two values is used as estimate of
the error and is stored in abserr_trunc. To improve the reliability of
the algorithm the extrapolated values are replaced by moving averages
when calculating the truncation error, smoothing out any fluctuations.

<p> 
<a name="step"></a>
<tt>GSL::Sum::Levin#step</tt><br>
<tt>s1.step(term, n, nmax)-> aDouble</tt><br>
double term; integer n, nmax
SKIPPED<br>
<p>
<a name="minmax"></a>
<tt>GSL::Sum::Levin#minmax</tt><br>
<tt>s1.minmax(array1, min, max) -> [sum1, abserr1]</tt><br>
SKIPPED<br>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require "GSL"; include GSL
include Math

N = 20
w= Sum::Levin.new(N)
zeta_2 = M_PI * M_PI / 6.0
n = 0
t = Array.new(N)
sum = 0

while (n &lt; N)
  np = n + 1.0
  t[n] = 1.0 / (np * np)
  sum += t[n]
  n += 1
end


puts "accel"
sum_accel, err = w.accel(t)
p sum_accel, err

puts "term-by-term sum"
p sum

puts "size"
p w.size

puts "terms_used"
p w.terms_used

puts "sum_plain"
p w.sum_plain

</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>Example</h3>
The following code calculates an estimate of \zeta(2) = \pi^2 / 6 using 
the series,<br>

\zeta(2) = 1 + 1/2^2 + 1/3^2 + 1/4^2 + ...
<br>
After N terms the error in the sum is O(1/N), making direct summation 
of the series converge slowly.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: sum.html,v 1.1 2003/09/20 12:21:08 pernici Exp $

require "GSL"
include GSL

STDERR.puts "Running tests for Series acceleration..."

N = 20
w= Sum::Levin.new N
zeta_2 = Math::M_PI * Math::M_PI / 6.0
n = 0
t = Array.new N
sum = 0

while (n &lt; N)
  np = n + 1.0
  t[n] = 1.0 / (np * np)
  sum += t[n]
  n += 1
end

sum_accel, err = w.accel(t)

printf "\nterm-by-term sum = %.16f using %d terms\n", sum, N
printf "term-by-term sum = %.16f using %d terms\n", w.sum_plain, w.terms_used
printf "exact value      = %.16f\n", zeta_2
printf "accelerated sum  = %.16f using %d terms\n", sum_accel, w.terms_used
printf "estimated error  = %.16f\n", err
printf "actual error     = %.16f\n", sum_accel - zeta_2

STDERR.puts "\ndone."
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
The output shows that the Levin u-transform is able to obtain an estimate of 
the sum to 1 part in 10^10 using the first eleven terms of the series.
The error estimate returned by the function is also accurate, giving 
the correct number of significant digits.

<p>
Note that a direct summation of this series would require 10^10 terms 
to achieve the same precision as the accelerated sum does in 13 terms.


<h3>References and Further Reading</h3>
The algorithms used by these functions are described in the following
papers,
<ul><li>
T. Fessler, W.F. Ford, D.A. Smith, HURRY: An acceleration algorithm for
scalar sequences and series ACM Transactions on Mathematical Software,
9(3):346--354, 1983. and Algorithm 602 9(3):355--357, 1983.
</ul>
The theory of the u-transform was presented by Levin,
<ul><li>
D. Levin, Development of Non-Linear Transformations for Improving
Convergence of Sequences, Intern. J. Computer Math. B3:371--388, 1973
</ul>
A review paper on the Levin Transform is available online,
<ul><li>
Herbert H. H. Homeier, Scalar Levin-Type Sequence Transformations,
http://xxx.lanl.gov/abs/math/0005209
</li>


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="dht.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="cheb.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Series Acceleration</td> 
</tr></tbody></table><hr></body>
</html>
