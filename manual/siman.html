<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Simulated Annealing</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href=".html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="monte.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Simulated Annealing</td> 
</tr></tbody></table><hr>
<h1>
Simulated Annealing</h1>
Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton's
method (which requires calculating Jacobian derivative matrices) cannot
be used. In particular, these techniques are frequently used to solve
combinatorial optimization problems, such as the traveling salesman
problem.
<p>
The goal is to find a point in the space at which a real valued energy
function (or cost function) is minimized. Simulated annealing is a
minimization technique which has given good results in avoiding local
minima; it is based on the idea of taking a random walk through the space
at successively lower temperatures, where the probability of taking a
step is given by a Boltzmann distribution.
<p>
The functions described in this chapter are declared in the header file
`gsl_siman.h'.

<h2>Simulated Annealing algorithm</h2>

The simulated annealing algorithm takes random walks through the problem
space, looking for points with low energies; in these random walks, the
probability of taking a step is determined by the Boltzmann distribution,
<br>
p = e^{-(E_{i+1} - E_i)/(kT)}
<br>
if E_{i+1} > E_i, and p = 1 when E_{i+1} <= E_i.
<br>
In other words, a step will occur if the new energy is lower. If the
new energy is higher, the transition can still occur, and its likelihood
is proportional to the temperature T and inversely proportional to the
energy difference E_{i+1} - E_i.
<br>
The temperature T is initially set to a high value, and a random walk
is carried out at that temperature. Then the temperature is lowered very
slightly according to a cooling schedule, for example: T -> T/mu_T where
\mu_T is slightly greater than 1.
<br>
The slight probability of taking a step that gives higher energy is what
allows simulated annealing to frequently get out of local minima.

<h3>Simulated Annealing functions</h3>

Function: void gsl_siman_solve (const gsl_rng * r, void *x0_p,
gsl_siman_Efunc_t Ef, gsl_siman_step_t take_step, gsl_siman_metric_t
distance, gsl_siman_print_t print_position, gsl_siman_copy_t copyfunc,
gsl_siman_copy_construct_t copy_constructor, gsl_siman_destroy_t
destructor, size_t element_size, gsl_siman_params_t params)
<br>
This function performs a simulated annealing search through a given
space. The space is specified by providing the functions Ef and
distance. The simulated annealing steps are generated using the
random number generator r and the function take_step.
<br>
The starting configuration of the system should be given by
x0_p. The routine offers two modes for updating configurations,
a fixed-size mode and a variable-size mode. In the fixed-size mode
the configuration is stored as a single block of memory of size
element_size. Copies of this configuration are created, copied and
destroyed internally using the standard library functions malloc,
memcpy and free. The function pointers copyfunc, copy_constructor
and destructor should be null pointers in fixed-size mode. In the
variable-size mode the functions copyfunc, copy_constructor and
destructor are used to create, copy and destroy configurations
internally. The variable element_size should be zero in the
variable-size mode.
<br>
The params structure (described below) controls the run
by providing the temperature schedule and other tunable
parameters to the algorithm.
<br>
On exit the best result achieved during the search
is placed in *x0_p. If the annealing process has been
successful this should be a good approximation to the
optimal point in the space.

If the function pointer print_position is not null, a debugging log
will be printed to stdout with the following columns:
<br>
number_of_iterations temperature x x-(*x0_p) Ef(x)
<br>
and the output of the function print_position itself. If
print_position is null then no information is printed.  The
simulated annealing routines require several user-specified
functions to define the configuration space and energy
function. The prototypes for these functions are given below.
<ul>
<li>Data Type: gsl_siman_Efunc_t <br>
This function type should return the energy
of a configuration xp.

double (*gsl_siman_Efunc_t) (void *xp)

<li>Data Type: gsl_siman_step_t<br>
This function type should modify the
configuration xp using a random step taken from the generator r, up to
a maximium distance of step_size.

void (*gsl_siman_step_t) (const gsl_rng *r, void *xp, double step_size)

<li>Data Type: gsl_siman_metric_t<br>
This function type should return the
distance between two configurations xp and yp.

double (*gsl_siman_metric_t) (void *xp, void *yp)

<li>Data Type: gsl_siman_print_t<br>
This function type should print the contents
of the configuration xp.

void (*gsl_siman_print_t) (void *xp)

<li>Data Type: gsl_siman_copy_t<br>
This function type should copy the
configuration dest into source.
void (*gsl_siman_copy_t) (void *source, void *dest)

<li>Data Type: gsl_siman_copy_construct_t<br>
This function type should create
a new copy of the configuration xp.

void * (*gsl_siman_copy_construct_t) (void *xp)

<li>Data Type: gsl_siman_destroy_t<br>
This function type should destroy the
configuration xp, freeing its memory.

void (*gsl_siman_destroy_t) (void *xp)

<li>Data Type: gsl_siman_params_t 
These are the parameters that control a run
of gsl_siman_solve. This structure contains all the information needed
to control the search, beyond the energy function, the step function
and the initial guess.
<ul>
<li>int n_tries The number of points to try for each step 
<li>int iters_fixed_T<br>
The number of iterations at each temperature 
<li>double step_size <br>
The maximum step size in the random walk 
<li>double k, t_initial, mu_t, t_min<br>
The parameters of the Boltzmann distribution and cooling schedule
</ul>
</ul>


<p>
<tt>GSL::Siman::new</tt><br>
<tt>Siman.new(n_tries, iters_fixed_T, step_size, k, t_initial, mu_t, t_min) -> s1</tt><br>
Creates a Siman object with values for the fields of gsl_siman_params_t;<br>
<tt>n_tries, iters_fixed_T, step_size, k, t_initial, mu_t, t_min</tt><br>
have default values, respectively,<br>
<tt>200, 10, 10, 1, 0.002, 1.005, 2.0e-6</tt><br>
A Siman object depends also on  Proc objects, which are assigned by
the following setting methods.
<p>

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: siman.html,v 1.1 2003/09/20 12:14:11 pernici Exp $

require "GSL"
include GSL

r = Random::RNG.new

energy = Proc.new {|x| Math::exp(-Math::pow_2(x[0]-1.0)) * Math::sin(8*x[0])}
metric = Proc.new {|x, y| (x[0] - y[0]).abs}
step = Proc.new {|x, u, ss|
  x[0] = 2 * u * ss - ss + x[0]
}
show = Proc.new {|x| printf("12%g\n", x[0])}

f = Siman.new

f.energy = energy 
f.metric = metric
f.step = step
f.print = show

conf = [15.5]

f.search r, conf
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href=".html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="monte.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Simulated Annealing</td> 
</tr></tbody></table><hr></body>
</html>
