<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Statistics</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
<body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="hist.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="rnd.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Statistics</td> 
</tr></tbody></table><hr><h1>
Statistics</h1>
<hr>
This chapter describes the statistical functions in the library. The basic
statistical functions include routines to compute the mean, variance
and standard deviation. More advanced functions allow you to calculate
absolute deviations, skewness, and kurtosis as well as the median and
arbitrary percentiles. The algorithms use recurrence relations to compute
average quantities in a stable way, without large intermediate values
that might overflow.
<p>
The functions are available in versions for datasets in the standard
floating-point and integer types. The versions for double precision
floating-point data have the prefix gsl_stats and are declared in the
header file `gsl_statistics_double.h'. The versions for integer data
have the prefix gsl_stats_int and are declared in the header files
`gsl_statistics_int.h'.  

<h2>Module Statistics</h2>

<h3>Mean, Standard Deviation and Variance</h3>
In this section the  convention used for the dataset in one-based:<br>
dataset x_{1},..,x_{N} .
 <p>
<a name="mean"></a>
<tt>Stats::mean</tt><br>
<tt>Stats::mean(data, stride) -> aDouble</tt><br>

This function returns the arithmetic mean of data, a dataset
of length n = N * stride with stride <tt>stride</tt>. 
The arithmetic mean, or sample mean,
is denoted by \Hat\mu and defined as,<br> 
\Hat\mu = (1/N) \sum x_i
where x_i are the elements of the dataset data. For samples drawn from
a gaussian distribution the variance of \Hat\mu is \sigma^2 / N.
<p>
<a name="mean1"></a>
<tt>Stats::mean1</tt><br>
<tt>Stats::mean1(data) -> aDouble</tt><br>
Same as Stats::mean(data,1)<br>

<p>
<a name="variance"></a>
<tt>Stats::variance</tt><br>
<tt>Stats::variance(data, stride) -> aDouble</tt><br>

This function returns the estimated, or sample, variance of
data, a dataset of length n with stride stride. The estimated variance
is denoted by \Hat\sigma^2 and is defined by,
<br>
\Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2
<br>
where x_i are the elements of the dataset data. Note that the
normalization factor of 1/(N-1) results from the derivation of
\Hat\sigma^2 as an unbiased estimator of the population variance
\sigma^2. For samples drawn from a gaussian distribution the variance
of \Hat\sigma^2 itself is 2 \sigma^4 / N.
<p>
<a name="variance1"></a>
<tt>Stats::variance1</tt><br>
<tt>Stats::variance1(data) -> aDouble</tt><br>
Same as Stats::variance(data, 1) .
<p>
<a name="variance1_m"></a>
<tt>Stats::variance1_m</tt><br>
<tt>Stats::variance1_m(data, stride, mean) -> aDouble</tt><br>

gsl_stats_variance computes the mean via a call to gsl_stats_mean. If
you have already computed the mean then you can pass it directly to
gsl_stats_variance_m.
<p>
<a name="sd"></a>
<tt>Stats::sd</tt><br>
<tt>Stats::sd(data, stride) -> aDouble</tt><br>

The standard deviation is defined as the
square root of the variance. These functions return the square root of
the corresponding variance functions above.
<p>
<a name="variance_with_fixed_mean"></a>
<tt>Stats::variance_with_fixed_mean</tt><br>
<tt>Stats::variance_with_fixed_mean(data, stride, mean) -> aDouble</tt><br>

This function computes
an unbiased estimate of the variance of data when the population mean
mean of the underlying distribution is known a priori. In this case
the estimator for the variance uses the factor 1/N and the sample mean
\Hat\mu is replaced by the known population mean \mu,
<br>
\Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2
<p>
<a name="sd_with_fixed_mean"></a>
<tt>Stats::sd_with_fixed_mean</tt><br>
<tt>Stats::sd_with_fixed_mean(data, stride, mean) -> aDouble</tt><br>

This function calculates the
standard deviation of data for a fixed population mean mean. The result
is the square root of the corresponding variance function.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]

puts "mean"
m1 = Stats::mean(c, 1)
sum = 0
c.each{|i| sum += i}
assert sum.to_f/c.size =~ [m1, 1.0e-14]

assert Stats::mean1(c) == m1

stride = 2
m2 = Stats::mean(c, stride)
sum = 0
c.each_with_index{|e,i| sum += e if i%stride == 0}
assert sum.to_f/c.size * stride =~  [m2, 1.0e-14]

puts "variance"
v1 = Stats::variance(c,1)
sum = 0; c.each{|i| sum += (i - m1)**2}; sum = sum/(c.size - 1)
assert sum == v1
assert Stats::variance1(c) == v1

assert Stats::variance_m(c,1, m1) == v1

puts "sd"
assert Stats::sd(c,1) == sqrt(v1)
v1f = Stats::variance_with_fixed_mean(c,1,m1)
assert v1f == v1*(c.size - 1)/c.size

assert Stats::sd_with_fixed_mean(c,1,m1) == sqrt(v1f)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<h3>Absolute deviation</h3>
<a name="absdev"></a>
<tt>Stats::absdev</tt><br>
<tt>Stats::absdev(data, stride) -> aDouble</tt><br>

This function computes the absolute deviation from the mean of
data, a dataset of length n with stride stride. The absolute deviation
from the mean is defined as,
<br>
absdev  = (1/N) \sum |x_i - \Hat\mu|
<br>
where x_i are the elements of the dataset data. The absolute deviation
from the mean provides a more robust measure of the width of a
distribution than the variance. This function computes the mean of data
via a call to gsl_stats_mean.
<p>
<a name="absdev_m"></a>
<tt>Stats::absdev_m</tt><br>
<tt>Stats::absdev_m(data, stride, mean) -> aDouble</tt><br>

This function computes the absolute deviation of
the dataset data relative to the given value of mean,
<br>
absdev  = (1/N) \sum |x_i - mean|
<br>
This function is useful if you have already computed the mean of data
(and want to avoid recomputing it), or wish to calculate the absolute
deviation relative to another value (such as zero, or the median).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]

puts "mean"
m1 = Stats::mean(c, 1)

puts "absdev"
v1 = Stats::absdev(c,1)
sum = 0; c.each{|i| sum += (i - m1).abs}; sum = sum/c.size
assert sum == v1

v1m = Stats::absdev_m(c,1, m1)
assert v1m == v1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Higher moments (skewness and kurtosis)</h3>
<a name="skew"></a>
<tt>Stats::skew</tt><br>
<tt>Stats::skew(data, stride) -> aDouble</tt><br>

This function computes the skewness of data, a dataset of
length n with stride stride. The skewness is defined as,
<br>
skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3
<br>
where x_i are the elements of the dataset data. The skewness measures
the asymmetry of the tails of a distribution.
<br>
The function computes the mean and estimated standard deviation of data
via calls to gsl_stats_mean and gsl_stats_sd.
<p>
<a name="skew_m_sd"></a>
<tt>Stats::skew_m_sd</tt><br>
<tt>Stats::skew_m_sd(data, stride, mean, sd) -> aDouble</tt><br>

This function computes the
skewness of the dataset data using the given values of the mean <tt>mean</tt>
and standard deviation <tt>sd</tt>,
<br>
skew = (1/N) \sum ((x_i - mean)/sd)^3
<p>
<a name="kurtosis"></a>
<tt>Stats::kurtosis</tt><br>
<tt>Stats::kurtosis(data, stride) -> aDouble</tt><br>

This function computes the kurtosis of data, a dataset of
length n with stride stride. The kurtosis is defined as,
<br>
kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3
<br>
The kurtosis measures how sharply peaked a distribution is, relative to
its width. The kurtosis is normalized to zero for a gaussian distribution.
<p>
<a name="kurtosis_m_sd"></a>
<tt>Stats::kurtosis_m_sd</tt><br>
<tt>Stats::kurtosis_m_sd(data, stride, mean, sd) -> aDouble</tt><br>

This function computes the kurtosis of the dataset data using 
the given values of the mean <tt>mean</tt> and standard deviation <tt>sd</tt>,
<br>
kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3
<br>
This function is useful if you have already computed the mean and standard
deviation of data and want to avoid recomputing them.

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]

m1 = Stats::mean(c, 1)
v1 = Stats::variance(c,1)
s1 = Stats::sd(c,1)

puts "skew"
sk1 = Stats::skew(c,1)
p sk1
sum = 0; c.each{|e| sum += ((e - m1)/s1)**3}
assert sum/c.size =~ sk1

assert Stats::skew_m_sd(c, 1, m1, s1) == sk1

puts "kurtosis"
k1 = Stats::kurtosis(c, 1)
p k1
sum = 0; c.each{|e| sum += ((e - m1)/s1)**4} ; sum = sum/c.size - 3
assert sum =~ k1
assert Stats::kurtosis_m_sd(c, 1, m1, s1) == k1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Autocorrelation</h3>
<a name="lag1_autocorrelation"></a>
<tt>Stats::lag1_autocorrelation</tt><br>
<tt>Stats::lag1_autocorrelation(data, stride) -> aDouble</tt><br>

This function computes the lag-1 autocorrelation of the dataset data.
<br>
a_1 = {\sum_{i = 2}^{N} (x_{i} - \Hat\mu) (x_{i-1} - \Hat\mu) \over
\sum_{i = 1}^{N} (x_{i} - \Hat\mu) (x_{i} - \Hat\mu)}
<p>
<a name="lag1_autocorrelation_m"></a>
<tt>Stats::lag1_autocorrelation_m</tt><br>
<tt>Stats::lag1_autocorrelation_m(data, stride, mean) -> aDouble</tt><br>

This function computes the lag-1 autocorrelation 
of the dataset data using the given value of the mean <tt>mean</tt>.

<h3>Covariance</h3>
<a name="covariance"></a>
<tt>Stats::covariance</tt><br>
<tt>Stats::covariance(data1, stride1, data2, stride2) -> aDouble</tt><br>

This function computes the covariance of the datasets data1 and data2
which must both be of the same length n.
<br>
covar = (1/(N - 1)) \sum_{i = 1}^{N} (x_i - \Hat x) (y_i - \Hat y)
<p>
<a name="covariance_m"></a>
<tt>Stats::covariance_m</tt><br>
<tt>Stats::covariance_m(data1, stride1, data2, stride2,mean1,mean2) -> aDouble</tt><br>

This function computes the covariance of the datasets
data1 and data2 using the given values of the means, mean1 and mean2.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]

m1 = Stats::mean(c, 1)
v1 = Stats::variance(c,1)
s1 = Stats::sd(c,1)

puts "lag1_autocorrelation"
a1 = Stats::lag1_autocorrelation(c,1)
p a1
sum2 = 0; c.each{|e| sum2 += (e - m1)*(e - m1)} 
sum = 0; 
(1..c.size-1).each{|i|  sum += (c[i] - m1)*(c[i-1] - m1)/sum2}
assert sum == a1

puts "covariance"
c2 = [17.3, 18.0, 16.6, 18.5, 12.3, 11.7]
m2 = Stats::mean(c2, 1)

cov1 = Stats::covariance(c,1,c2,1)
p cov1
sum = 0; (0..c.size-1).each{|i| sum += (c[i] - m1)*(c2[i] - m2)}
sum = sum/(c.size-1)
assert sum == cov1

assert Stats::covariance_m(c,1,c2,1, m1, m2) == cov1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Weighted Samples</h3>

The functions described in this section allow the computation of
statistics for weighted samples. The functions accept an array of samples,
x_i, with associated weights, w_i. Each sample x_i is considered as having
been drawn from a Gaussian distribution with variance \sigma_i^2. The
sample weight w_i is defined as the reciprocal of this variance, w_i =
1/\sigma_i^2. Setting a weight to zero corresponds to removing a sample
from a dataset.
<a name="wmean"></a>
<tt>Stats::wmean</tt><br>
<tt>Stats::wmean(wmean, wstride, data, stride) -> aDouble</tt><br>
This function returns the
weighted mean of the dataset data with stride <tt>stride</tt>, using
the set of weights w with stride <tt>wstride</tt>. The weighted mean
is defined as,
<br>
\Hat\mu = (\sum w_i x_i) / (\sum w_i)
<p>
<a name="wvariance"></a>
<tt>Stats::wvariance</tt><br>
<tt>Stats::wvariance(w, wstride, data, stride) -> aDouble</tt><br>

This function returns the
estimated variance of the dataset data with stride stride and length n,
using the set of weights w with stride wstride and length n. The estimated
variance of a weighted dataset is defined as,
<br>
\Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2))) \sum w_i (x_i - \Hat\mu)^2
<br>
Note that this expression reduces to an unweighted variance with
the familiar 1/(N-1) factor when there are N equal non-zero weights.
<p>
<a name="wvariance_m"></a>
<tt>Stats::wvariance_m</tt><br>
<tt>Stats::wvariance_m(w, wstride, data, stride, mean) -> aDouble</tt><br>

This function returns the estimated variance of the weighted dataset
data using the given weighted mean wmean.
<p>
<a name="wsd"></a>
<tt>Stats::wsd</tt><br>
<tt>Stats::wsd(w, wstride, data, stride) -> aDouble</tt><br>

The standard deviation is defined
as the square root of the variance. This function returns the square
root of the corresponding variance function gsl_stats_wvariance above.
<p>
<a name="wsd_m"></a>
<tt>Stats::wsd_m</tt><br>
<tt>Stats::wsd_m(w, wstride, data, stride, wmean) -> aDouble</tt><br>

This function returns the square root of the corresponding variance function
Stats::wvariance_m above.
<p>
<a name="wvariance_with_fixed_mean"></a>
<tt>Stats::wvariance_with_fixed_mean</tt><br>
<tt>Stats::wvariance_with_fixed_mean(w, wstride, data, stride, mean) -> aDouble</tt><br>

This function computes an unbiased estimate of the
variance of weighted dataset data when the population mean mean of the
underlying distribution is known a priori. In this case the estimator
for the variance replaces the sample mean \Hat\mu by the known population
mean \mu,
<br>
\Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)
<p>
<a name="wsd_with_fixed_mean"></a>
<tt>Stats::wsd_with_fixed_mean</tt><br>
<tt>Stats::wsd_with_fixed_mean(w, wstride, data, stride, mean) -> aDouble</tt><br>

The standard deviation is defined as the square root of the
variance. This function returns the square root of the corresponding
variance function above.  
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]
w = [1.05, 1.15, 1.10, 1.20, 1.30, 1.20]
m1 = Stats::mean(c, 1)

puts "wmean"
wm1 = Stats::wmean(w,1,c, 1)
wsum1 = 0; w.each{|e| wsum1 += e}
sum = 0; c.size.times{|i| sum += w[i] * c[i]}; sum /= wsum1
assert sum == wm1

stride = 2
wm2 = Stats::wmean(w, stride, c, stride)
wsum2 = 0; w.each_with_index{|e,i| wsum2 += w[i] if i%stride == 0}
sum = 0; c.each_with_index{|e,i| sum += w[i] * c[i] if i%stride == 0}
sum /= wsum2
assert sum =~ [wm2, 1.0e-14]

puts "wvariance"
v1 = Stats::wvariance(w,1,c,1)
wsum2 = 0; w.each{|e| wsum2 += e*e}
sum = 0; c.size.times{|i| 
  sum += wsum1.to_f/(wsum1**2 - wsum2) * w[i]*(c[i] - wm1)**2
  }
assert sum == v1
assert Stats::wvariance_m(w,1,c,1,wm1) == v1

puts "wsd"
assert Stats::wsd(w,1,c,1) == sqrt(v1)
assert Stats::wsd_m(w,1,c,1, wm1) == sqrt(v1)


v1f = Stats::wvariance_with_fixed_mean(w,1,c,1,m1)
sigma2 = 0; c.size.times{|i| sigma2 += w[i].to_f*(c[i] - m1)**2/wsum1}
assert sigma2 =~ v1f

assert Stats::wsd_with_fixed_mean(w,1,c,1,m1) == sqrt(v1f)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>
<a name="wabsdev"></a>
<tt>Stats::wabsdev</tt><br>
<tt>Stats::wabsdev(w, wstride, data, stride) -> aDouble</tt><br>

This function computes the weighted absolute deviation from the weighted
mean of data. The absolute deviation from the mean is defined as,
<br>
absdev = (\sum w_i |x_i - \Hat\mu|) / (\sum w_i)

<p>
<a name="wabsdev_m"></a>
<tt>Stats::wabsdev_m</tt><br>
<tt>Stats::wabsdev_m(w, wstride, data, stride, wmean) -> </tt><br>

This function computes the absolute deviation of 
the weighted dataset data about the given weighted mean <tt>wmean</tt>.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]
w = [1.05, 1.15, 1.10, 1.20, 1.30, 1.20]

wm1 = Stats::wmean(w,1,c, 1)
wsum1 = 0; w.each{|e| wsum1 += e}

puts "wabsdev"
v1 = Stats::wabsdev(w,1,c,1)
sum = 0; c.size.times{|i| sum += w[i]*(c[i] - wm1).abs}; sum = sum/wsum1
assert sum == v1

v1m = Stats::wabsdev_m(w,1,c,1, wm1)
assert v1m == v1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>
<a name="wskew"></a>
<tt>Stats::wskew</tt><br> 
<tt>Stats::wskew(w, wstride, data, stride) -> aDouble</tt><br>

This function computes the weighted skewness of the dataset data.
<br>
skew = (\sum w_i ((x_i - xbar)/\sigma)^3) / (\sum w_i)
<p>
<a name="wskew_m_sd"></a>
<tt>Stats::wskew_m_sd</tt><br> 
<tt>Stats::wskew_m_sd(w, wstride, data, stride, wmean, wsd) -> aDouble</tt><br>

This function computes the weighted skewness of the dataset data using
the given values of the weighted mean and weighted standard deviation,
wmean and wsd.  
<p>
<a name="wkurtosis"></a>
<tt>Stats::wkurtosis</tt><br>
<tt>Stats::wkurtosis(w,wstride, data, stride) -> aDouble</tt><br>

This function computes the weighted kurtosis of the dataset data.
<br>
kurtosis = ((\sum w_i ((x_i - xbar)/sigma)^4) / (\sum w_i)) - 3
<p>
<a name="wkurtosis_m_sd"></a>
<tt>Stats::wkurtosis_m_sd</tt><br>
<tt>Stats::wkurtosis_m_sd(w,wstride, data, stride, wmean, wsd) -> aDouble</tt><br>

This function computes the weighted kurtosis of the dataset
data using the given values of the weighted mean and weighted standard
deviation, wmean and wsd.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]
w = [1.05, 1.15, 1.10, 1.20, 1.30, 1.20]

wm1 = Stats::wmean(w,1,c, 1)
wsum1 = 0; w.each{|e| wsum1 += e}
ws1 = Stats::wsd(w,1,c,1)

puts "wskew"
sk1 = Stats::wskew(w,1,c,1)
p sk1
sum = 0; c.size.times{|i| sum += w[i]*((c[i] - wm1)/ws1)**3}; sum = sum/wsum1
assert sum =~ sk1
assert Stats::wskew_m_sd(w,1,c,1, wm1, ws1) == sk1

wk1 = Stats::wkurtosis(w,1,c,1)
sum = 0;  c.size.times{|i| sum += w[i]*((c[i] - wm1)/ws1)**4}
sum = sum/wsum1 - 3
assert sum == wk1

assert Stats::wkurtosis_m_sd(w,1,c,1, wm1, ws1) == wk1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Maximum and Minimum values</h3>
<a name="max"></a>
<tt>Stats::max</tt><br>
<tt>Stats::max(data, stride) -> aDouble</tt><br>

This function returns the maximum value in data, a dataset of
length n with stride <tt>stride</tt>. 
The maximum value is defined as the value
of the element x_i which satisfies x_i >= x_j for all j.
<br>
If you want instead to find the element with the largest absolute
magnitude you will need to apply fabs or abs to your data before calling
this function.
<p>
<a name="min"></a>
<tt>Stats::min</tt><br>
<tt>Stats::min(data, stride) -> aDouble</tt><br>

This function returns the minimum value in data, a dataset of
length n with stride <tt>stride</tt>. 
The minimum value is defined as the value
of the element x_i which satisfies x_i <= x_j for all j.
<br>
If you want instead to find the element with the smallest absolute
magnitude you will need to apply fabs or abs to your data before calling
this function.
<p>
<a name="minmax"></a>
<tt>Stats::minmax</tt><br>
<tt>Stats::minmax(data, stride) -> [min, max]</tt><br>

This function finds both the
minimum and maximum values min, max in data in a single pass.
<p>
<a name="max_index"></a>
<tt>Stats::max_index</tt><br>
<tt>Stats::max_index(data, stride) -> anInteger</tt><br>

This function returns the index of the maximum value
in data, a dataset of length n with stride <tt>stride</tt>. 
The maximum value is
defined as the value of the element x_i which satisfies x_i >= x_j for
all j. When there are several equal maximum elements then the first one
is chosen.  
<p>
<a name="min_index"></a>
<tt>Stats::min_index</tt><br>
<tt>Stats::min_index(data, stride) -> anInteger</tt><br>

This function returns the index of the minimum
value in data, a dataset of length n with stride stride. The minimum
value is defined as the value of the element x_i which satisfies x_i >=
x_j for all j. When there are several equal minimum elements then the
first one is chosen.
<p>
<a name="minmax_index"></a>
<tt>Stats::minmax_index</tt><br>
<tt>Stats::minmax_index(data, stride) -> [i_min, i_max]</tt><br>

This function returns the indexes min_index, max_index 
of the minimum and maximum values in data in a single pass.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math

c = [17.2, 18.1, 16.5, 18.3, 12.6, 11.8]
w = [1.05, 1.15, 1.10, 1.20, 1.30, 1.20]

wm1 = Stats::wmean(w,1,c, 1)
wsum1 = 0; w.each{|e| wsum1 += e}
ws1 = Stats::wsd(w,1,c,1)

max1 = Stats::max(c,1)
assert max1 == 18.3
assert  Stats::min(c,1) == 11.8

max2 = Stats::max(c,2)
assert max2 == 17.2

assert Stats::minmax(c,1) == [11.8, 18.3]
assert Stats::max_index(c,1) == 3 &amp;&amp; Stats::min_index(c,1) == 5
assert Stats::minmax_index(c,1) == [5,3]
p Stats::minmax_index(c,1)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>Median and Percentiles</h3>

The median and percentile functions described in this section operate
on sorted data. For convenience we use quantiles, measured on a scale
of 0 to 1, instead of percentiles (which use a scale of 0 to 100).
<p>
<a name="median_from_sorted_data"></a>
<tt>Stats::median_from_sorted_data</tt><br>
<tt>Stats::median_from_sorted_data(sorted_data, stride) -> aDouble</tt><br>

This function returns the median
value of sorted_data, a dataset of length n with stride <tt>stride</tt>. 
The elements of the array must be in ascending numerical order. There are
no checks to see whether the data are sorted, so the function gsl_sort
should always be used first.
<br>
When the dataset has an odd number of elements the median is the value
of element (n-1)/2. When the dataset has an even number of elements the
median is the mean of the two nearest middle values, elements (n-1)/2 and
n/2. Since the algorithm for computing the median involves interpolation
this function always returns a floating-point number, even for integer
data types.
<p>
<a name="median"></a>
<tt>Stats::median</tt><br>
<tt>Stats::median(data, stride) -> aDouble</tt><br>
This function returns the median; <tt>data</tt> is not necessarily sorted.
<p>
<a name="quantile_from_sorted_data"></a>
<tt>Stats::quantile_from_sorted_data</tt><br>
<tt>Stats::quantile_from_sorted_data(sorted_data, stride, f) -> aDouble</tt><br>
double <tt>f</tt>.<br>
This function returns a
quantile value of sorted_data, a double-precision array of length n with
stride <tt>stride</tt>. 
The elements of the array must be in ascending numerical
order. 
The quantile is determined by the <tt>f</tt>, a fraction between 0 and 1. 
For example, to compute the value of the 75th percentile <tt>f</tt> 
should have the value 0.75.  
There are no checks to see whether the data are sorted,
so the function gsl_sort should always be used first.
<br>
The quantile is found by interpolation, using the formula
<br>
quantile = (1 - \delta) x_i + \delta x_{i+1}
<br>
where i is floor((n - 1)f) and \delta is (n-1)f - i.
<br>
Thus the minimum value of the array (data[0*stride]) is given by f equal
to zero, the maximum value (data[(n-1)*stride]) is given by f equal to one
and the median value is given by f equal to 0.5. Since the algorithm for
computing quantiles involves interpolation this function always returns
a floating-point number, even for integer data types.
<p>
<a name="quantile"></a>
<tt>Stats::quantile</tt><br>
<tt>Stats::quantile() -> </tt><br>
This function returns a quantile; data is not necessarily sorted.

<h3>Example</h3>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;#!/usr/local/bin/ruby

# $Id: stats.html,v 1.1 2003/09/07 22:27:10 pernici Exp $

require "GSL"
include GSL

# Test for Statistics

STDERR.puts "Running statistics tests..."

puts "\nStats:"
#c = [42, 55, 75, 45, 54, 51, 55, 36, 58, 55, 67]
c = [17.2, 18.1, 16.5, 18.3, 12.6]
print "c = ", c.join(" "), "\n"

puts "---"
print "  mean     : ", GSL::Stats::mean(c, 1), "\n"
print "  variance : ", GSL::Stats::variance(c, 1), "\n"
print "  sd       : ", GSL::Stats::sd(c, 1), "\n"
print "  absdev   : ", GSL::Stats::absdev(c, 1), "\n"
print "  skew     : ", GSL::Stats::skew(c, 1), "\n"
print "  kurtosis : ", GSL::Stats::kurtosis(c, 1), "\n"

puts "---"
d = c.sort
print "  max           : ", GSL::Stats::max(c, 1), "\n"
print "  max_index     : ", GSL::Stats::max_index(c, 1), "\n"
print "  min           : ", GSL::Stats::min(c, 1), "\n"
print "  min_index     : ", GSL::Stats::min_index(c, 1), "\n"
a = Stats::minmax(c, 1)
print "  minmax        : ", a[0], " ", a[1], "\n"
a = Stats::minmax_index(c, 1)
print "  minmax_index  : ", a[0], " ", a[1], "\n"
print "  median        : ", GSL::Stats::median_from_sorted_data(d, 1), "\n"
print "  upper quantile: ", GSL::Stats::quantile_from_sorted_data(d, 1, 0.75), "\n"
print "  lower quantile: ", GSL::Stats::quantile_from_sorted_data(d, 1, 0.25), "\n"
#print "  median2  : ", GSL::Stats::median(c, 1), "\n"
#print "  quantile2: ", GSL::Stats::quantile(c, 1, 0.3), "\n"

puts "---"
x = [6, 9, 11, 13, 22, 26, 28, 33, 35]
y = [68, 67, 65, 53, 44, 40, 37, 34, 32]
w = [0.3, 0.5, 0.5, 0.6, 0.8, 0.6, 0.5, 0.5, 0.3]
print "x = ", x.join(" "), "\n"
print "y = ", y.join(" "), "\n"
print "w = ", w.join(" "), "\n"
m1 = GSL::Stats::mean(x, 1)
m2 = GSL::Stats::mean(y, 1)
print "  mean x    : ", m1,  "\n"
print "  mean y    : ", m2,  "\n"
wm = GSL::Stats::wmean(w, 1, y, 1)
print "  wmean y   : ", wm,  "\n"
begin
  print "  covariance: ", GSL::Stats::covariance(x, 1, y, 1), "\n"
rescue GSL::ArgumentError
  STDERR.print "Caught exception: #{$!}\n"
end
#print "  covariance_m: ", GSL::Stats::covariance_m(x, 1, y, 1, m1, m2), "\n"
print "  pvariance : ", GSL::Stats::pvariance(x, 1, y, 1), "\n"

puts "---"
x = [106.9, 106.3, 107.0, 106.0, 104.9]
y = [106.5, 106.7, 106.8, 106.1, 105.6]
print "x = ", x.join(" "), "\n"
print "y = ", y.join(" "), "\n"
m1 = GSL::Stats::mean(x, 1)
m2 = GSL::Stats::mean(y, 1)
print "  mean x    : ", m1,  "\n"
print "  mean y    : ", m2,  "\n"
print "  covariance: ", GSL::Stats::covariance(x, 1, y, 1), "\n"
print "  pvariance : ", GSL::Stats::pvariance(x, 1, y, 1), "\n"
print "  ttest     : ", GSL::Stats::ttest(x, 1, y, 1), "\n"

STDERR.puts "\ndone."
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<h3>References</h3>

<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="hist.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="rnd.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Statistics</td> 
</tr></tbody></table><hr></body>
</html>
