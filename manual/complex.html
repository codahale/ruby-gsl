<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>
Complex numbers</title>

  
<style type="text/css">
<!--
body {background-color: white; color: black;}
a {background-color: white; color: blue; text-decoration: underline;}
a:hover {text-decoration: none;}
td.head,td.headcenter {background-color: #99ccff; color: black;}
td.headcenter {width: 100%; text-align: center;}
img {border-style: none;}
-->
  </style>
                
<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #0000ff;}
-->
</style></head>
  <body>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="poly.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="math.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex numbers</td> 
</tr></tbody></table><hr>
<h1>
Complex numbers</h1>
<ul>
<li><a href="#p1">Complex numbers in GSL</a>
<li><a href="#p2">Class GSL::Complex</a>
<li><a href="#p3">Properties of complex numbers</a>
<li><a href="#p4">Complex arithmetic operators</a>
<li><a href="#p5">Elementary Complex Functions</a>
<li><a href="#p6">Complex Trigonometric Functions</a>
<li><a href="#p7">Inverse Complex Trigonometric Functions</a>
<li><a href="#p8">Complex Hyperbolic Functions</a>
<li><a href="#p9">Inverse Complex Hyperbolic Functions</a>
<li><a href="#p10">More Complex Trigonometric Functions</a>


</ul>
<hr>
The functions described in this chapter provide support for complex 
numbers. The algorithms take care to avoid unnecessary intermediate 
underflows and overflows, allowing the functions to be evaluated over 
as much of the complex plane as possible.
<p>
For multiple-valued functions the branch cuts have been chosen to follow 
the conventions of Abramowitz and Stegun in the Handbook of Mathematical 
Functions. The functions return principal values which are the same as 
those in GNU Calc, which in turn are the same as those in Common Lisp, 
The Language (Second Edition) (n.b. The second edition uses different 
definitions from the first edition) and the HP-28/48 series of calculators.
<p>
<h2>Complex numbers</h2>
<a name="p1"></a>
<h3>Complex numbers in GSL</h3>
In GSL, complex numbers are represented using the <tt>gsl_complex</tt> struct
<pre>
typedef struct
{
  double dat[2];
  } gsl_complex;
</pre>
  The real and imaginary part are stored in contiguous elements of a two 
  element array. This eliminates any padding between the real and imaginary 
  parts, dat[0] and dat[1], allowing the struct to be mapped correctly 
  onto packed complex arrays.
<a name="p2"></a>
<h3>Class GSL::Complex</h3>
The <tt>GSL::Complex</tt> class is a wrapper around <tt>gsl_complex</tt>
<h3>Class methods</h3>
<a href="#new">new</a> ,&nbsp
<a href="#new2">new2</a> ,&nbsp
<a href="#new3">new3</a> ,&nbsp
<p>
<a name="new"></a>
<tt>GSL::Complex.new</tt><br>
<tt>GSL::Complex.new(c1) -> c2</tt><br>
initialization from Ruby Complex object c1
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"
require "complex"
c = Complex(1.0, 2.0)
d = GSL::Complex.new2(1.0, 2.0)
c1 = GSL::Complex.new2(1.0, 2.0)
c2 =  GSL::Complex.new(c)
assert c1 == c2
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><a name="new2"></a>
<tt>GSL::Complex.new2</tt><br>
<tt>GSL::Complex.new2(x,y) -> c1</tt><br>
initialization from rectangular coordinates x and y
<p>
<a name="new3"></a>
<tt>GSL::Complex.new3</tt><br>
<tt>GSL::Complex.new3(r, theta)</tt><br>
initialization from polar coordinates r and theta
<p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

c1 = Complex.new2(1.0, 2.0)
c2 = Complex.new3(c1.abs, c1.arg)
assert c1.real =~ c2.real &amp;&amp; c1.imag =~ c2.imag
assert c1 =~ c2
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><h3>Methods</h3>
<a href="#"arcsec">"arcsec</a> ,&nbsp
<a href="#*">*</a> ,&nbsp
<a href="#+">+</a> ,&nbsp
<a href="#-">-</a> ,&nbsp
<a href="#/">/</a> ,&nbsp
<a href="#=~">=~</a> ,&nbsp
<a href="#_dump_data">_dump_data</a> ,&nbsp
<a href="#_load_data">_load_data</a> ,&nbsp
<a href="#abs">abs</a> ,&nbsp
<a href="#abs2">abs2</a> ,&nbsp
<a href="#add">add</a> ,&nbsp
<a href="#add_imag">add_imag</a> ,&nbsp
<a href="#add_real">add_real</a> ,&nbsp
<a href="#arccos_real">arccos_real</a> ,&nbsp
<a href="#arccosh">arccosh</a> ,&nbsp
<a href="#arccosh_real">arccosh_real</a> ,&nbsp
<a href="#arccot">arccot</a> ,&nbsp
<a href="#arccoth">arccoth</a> ,&nbsp
<a href="#arccsc">arccsc</a> ,&nbsp
<a href="#arccsc_real">arccsc_real</a> ,&nbsp
<a href="#arccsch">arccsch</a> ,&nbsp
<a href="#arcos">arcos</a> ,&nbsp
<a href="#arcsec_real">arcsec_real</a> ,&nbsp
<a href="#arcsech">arcsech</a> ,&nbsp
<a href="#arcsin">arcsin</a> ,&nbsp
<a href="#arcsin_real">arcsin_real</a> ,&nbsp
<a href="#arcsinh">arcsinh</a> ,&nbsp
<a href="#arctan">arctan</a> ,&nbsp
<a href="#arctanh">arctanh</a> ,&nbsp
<a href="#arctanh_real">arctanh_real</a> ,&nbsp
<a href="#arg">arg</a> ,&nbsp
<a href="#conjugate">conjugate</a> ,&nbsp
<a href="#cos">cos</a> ,&nbsp
<a href="#cos_e">cos_e</a> ,&nbsp
<a href="#cosh">cosh</a> ,&nbsp
<a href="#cot">cot</a> ,&nbsp
<a href="#coth">coth</a> ,&nbsp
<a href="#csc">csc</a> ,&nbsp
<a href="#csch">csch</a> ,&nbsp
<a href="#div">div</a> ,&nbsp
<a href="#div_imag">div_imag</a> ,&nbsp
<a href="#div_real">div_real</a> ,&nbsp
<a href="#fl_eq">fl_eq</a> ,&nbsp
<a href="#float_equal">float_equal</a> ,&nbsp
<a href="#exp">exp</a> ,&nbsp
<a href="#image">image</a> ,&nbsp
<a href="#image">inverse</a> ,&nbsp
<a href="#log">log</a> ,&nbsp
<a href="#log10">log10</a> ,&nbsp
<a href="#logabs">logabs</a> ,&nbsp
<a href="#logb">logb</a> ,&nbsp
<a href="#logsin_e">logsin_e</a> ,&nbsp
<a href="#mul">mul</a> ,&nbsp
<a href="#mul_imag">mul_imag</a> ,&nbsp
<a href="#mul_real">mul_real</a> ,&nbsp
<a href="#negative">negative</a> ,&nbsp
<a href="#pow">pow</a> ,&nbsp
<a href="#pow_real">pow_real</a> ,&nbsp
<a href="#real">real</a> ,&nbsp
<a href="#sec">sec</a> ,&nbsp
<a href="#sech">sech</a> ,&nbsp
<a href="#sin">sin</a> ,&nbsp
<a href="#sin_e">sin_e</a> ,&nbsp
<a href="#sinh">sinh</a> ,&nbsp
<a href="#sqrt">sqrt</a> ,&nbsp
<a href="#sqrt_real">sqrt_real</a> ,&nbsp
<a href="#sub">sub</a> ,&nbsp
<a href="#sub_real">sub_real</a> ,&nbsp 
<a href="#sub_imag">sub_imag</a> ,&nbsp
<a href="#tan">tan</a> ,&nbsp
<a href="#tanh">tanh</a> ,&nbsp
<a href="#to_a">to_a</a> ,&nbsp
<a href="#to_s">to_s</a> ,&nbsp
<p>
<a name="float_equal"></a>
<tt>GSL::Complex#float_equal</tt><br>
<tt>Complex.float_equal(c1,c2,eps)</tt><br>
returns true if abs(Re(c1) - Re(c2)) < eps and abs(Im(c1) - Im(c2)) < eps
<p>
<a name="fl_eq"></a>
<a name="=~"></a>
<tt>GSL::Complex#fl_eq</tt><br>
<tt>Complex#=~</tt>&nbsp; (Alias)<br>
<tt>c1 =~ c2</tt><br>
Complex c1, c2<br>
Same as Complex.float_equal(c1,c2,1.0e-15)<br>
<p>
<tt>c1 =~ [c2, eps]</tt><br>
Complex c1, c2; double eps<br>
Same as Complex.float_equal(c1,c2,eps)<br>
<p>
<a name="to_s"></a>
<tt>GSL::Complex::to_s</tt><br>
<tt>Complex.new2(1.0, 2.0).to_s #=> "(1.000000, 2.000000)"</tt><br>
<p>
<a name="to_a"></a>
<a name="_dump_data"></a>
<tt>GSL::Complex::to_a</tt><br> 
<tt>GSL::Complex::_dump_data</tt>&nbsp; ('alias')<br>
<tt>c1.to_a -> anArray</tt><br>
This method returns anArray = [Re(c1), Im(c1)]
<p>
<a name="_load_data"></a>
<tt>GSL::Complex#_load_data</tt><br>
<tt>c1._load_data(array1) -> c2</tt><br>
where array1 is an array representing [Re(c2), Im(c2)]
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

c1 = GSL::Complex.new2(1.0, 2.0)
assert c1.to_a == [1.0, 2.0] &amp;&amp; c1._dump_data == c1.to_a
ary = c1.to_a
c2 = GSL::Complex.new2(0,0)
c2._load_data(ary)
assert c2 == c1
c3 = GSL::Complex.new2(3.0,0)
assert c3 =~ 3 + 1.0e-16 &amp;&amp; c3 !~ 3 + 1.2e-15
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="p3"></a>
<h3>Properties of complex numbers</h3>
<a name="real"></a>
<tt>GSL::Complex#real</tt><br>
c1.real -> aDouble <br>
where aDouble is the real part of the complex number c1
<p>
<a name="image"></a>
<tt>GSL::Complex#imag</tt><br>
<tt>GSL::Complex#image &nbsp; (alias)</tt><br>
c1.imag -> aDouble <br>
where aDouble is the imaginary part of the complex number c1
<p>
<a name="arg"></a>
<tt>GSL::Complex#arg</tt><br>
c1.arg -> aDouble<br>
where aDouble is the angle in the polar representation of the complex number c1
<p>
<a name="abs"></a>
<tt>GSL::Complex#abs</tt><br>
c1.abs  -> aDouble<br>
where aDouble is the absolute value of the complex number c1
<p>
<a name="abs2"></a>
<tt>GSL::Complex#abs2</tt><br>
c1.abs  -> aDouble<br>
where aDouble is the absolute value squared of the complex number c1
<p>
<a name="logabs"></a>
<tt>GSL::Complex#logabs</tt><br>
c1.logabs  -> aDouble<br>
This function returns the natural logarithm of the magnitude of the complex 
number z, \log|z|. It allows an accurate evaluation of \log|z| when |z| 
is close to one. The direct evaluation of log(gsl_complex_abs(z)) would 
lead to a loss of precision in this case.
<p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c1 = Complex.new2(1.0, 2.0)
assert c1.real =~ 1.0 &amp;&amp; c1.imag =~ 2.0
assert c1.arg =~ atan(2) 
assert c1.abs =~ sqrt(5) &amp;&amp; c1.abs2 =~ 5 &amp;&amp; c1.logabs =~ log(sqrt(5))
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="p4"></a>
<h3>Complex arithmetic operators</h3>
<a name="mul"></a>
<tt>GSL::Complex#mul</tt><br>
<a name="*"></a>
<tt>GSL::Complex#* &nbsp; (alias)</tt><br>
c1 * c2 -> c3
<p>
<a name="add"></a>
<tt>GSL::Complex#add</tt><br>
<a name="+"></a>
<tt>GSL::Complex#+  &nbsp; (alias)</tt><br>
c1 + c2 -> c3
<p>
<a name="-"></a>
<tt>GSL::Complex#-</tt><br>
<a name="sub"></a>
<tt>GSL::Complex#sub  &nbsp; (alias)</tt><br>
<p>
c1 - c2 -> c3
<p>
<a name="div"></a>
<tt>GSL::Complex#div</tt><br>
<a name="/"></a>
<tt>GSL::Complex#/  &nbsp; (alias)</tt><br>
c1 / c2 -> c3
<p>
<a name="add_real"></a>
<tt>GSL::Complex#add_real</tt><br>
<tt>c1.add_real(aDouble) -> c2</tt><br>
This function returns the sum of the complex number c1 and the real number aDouble, c2 = c1 + aDouble
<p>
<a name="sub_real"></a>
<tt>GSL::Complex#sub_real</tt><br>
<tt>c1.sub_real(aDouble) -> c2</tt><br>
This function returns the difference of the complex number c1 and the real number aDouble, c2 = c1 - aDouble
<p>
<a name="mul_real"></a>
<tt>GSL::Complex#mul_real</tt><br>
<tt>c1.mul_real(aDouble) -> c2</tt><br>
This function returns the product of the complex number c1 and the real number
aDouble, c2 = c1 * aDouble
<p>
<a name="div_real"></a>
<tt>GSL::Complex#div_real</tt><br>
<tt>c1.div_real(aDouble) -> c2</tt><br>
This function returns the quotient of the complex number c1 and the real number
aDouble, c2 = c1 / aDouble
<p>
<a name="add_imag"></a>
<tt>GSL::Complex#add_imag</tt><br>
<tt>c1.add_imag(aDouble) -> c2</tt><br>
This function returns the sum of the complex number c1 and the imaginary 
number i * aDouble, c2 = c1 + i * aDouble.
<p>
<a name="sub_imag"></a>
<tt>GSL::Complex#sub_imag</tt><br>
<tt>c1.sub_imag(aDouble) -> c2</tt><br>
This function returns the difference of the complex number c1 and the imaginary 
number i * aDouble, c2 = c1 + i * aDouble.
<p>
<a name="mul_imag"></a>
<tt>GSL::Complex#mul_imag</tt><br>
<tt>c1.mul_imag(aDouble) -> c2</tt><br>
This function returns the product of the complex number c1 and the imaginary
number i * aDouble, c2 = c1 * (i * aDouble).
<p>
<a name="div_imag"></a>
<tt>GSL::Complex#div_imag</tt><br>
<tt>c1.div_imag(aDouble) -> c2</tt><br>
This function returns the quotient of the complex number c1 and the imaginary
number i * aDouble, c2 = c1 / (i * aDouble).
<p>
<a name="conjugate"></a>
<tt>GSL::Complex#conjugate</tt><br>
<tt>c1.conjugate -> c2</tt><br>
c2 is the complex conjugate of c1
<p>
<a name="inverse"></a>
<tt>GSL::Complex#inverse</tt><br>
<tt>c1.inverse -> c2</tt><br>
This function returns the inverse, or reciprocal, of the complex number 
c1; for c1 = x + i y, the inverse is<br>
1/z = (x - i y)/(x^2 + y^2).
<p>
<a name="negative"></a>
<tt>GSL::Complex#negative</tt><br>
<tt>GSL::Complex#-</tt> &nbsp; (unary)<br>
<tt>c1.negative -> c2</tt><br>
This function returns the negative of the complex number c1, -c1 .
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL; include Math
require 'gsl_util'

c1 = Complex.new2(1.0, 2.0)
c2 = Complex.new2(2.0, 1.0)
c3 = c1 + c2
assert c3 =~ Complex.new2(3.0, 3.0)
c4 = c3 - c2
assert c4 =~ c1
c5 = c3/c1
assert c5.arg =~ M_PI/4 - atan(2.0)
c6 = c5 * c1
assert c3 =~ c6
c7 = c1.add_real(4.0)
assert c7 =~ Complex.new2(5.0, 2.0)
c7 = c7.sub_real(4.0)
assert c7 =~ c1
c7 = c1.mul_real(3.0)
assert c7 =~ Complex.new2(3.0, 6.0)
c7 = c7.div_real(3.0)
assert c7 =~ c1
c7 = c7.add_imag(5.0)
assert c7 =~ Complex.new2(1.0, 7.0)
c7 = c7.sub_imag(5.0)
assert c7 =~ c1
c7 = c7.mul_imag(5.0)
assert c7 =~ Complex.new2(- 10.0, 5.0)
c7 = c7.div_imag(5.0)
assert c7 =~ c1
c7 = c7.conjugate
assert c7 =~ Complex.new2(1.0,-2.0)
c7 = c1.inverse
assert c7 =~ Complex.new2(1.0/5, -2.0/5)
c7 = c1.negative
assert c7 =~ Complex.new2(-1.0, -2.0) &amp;&amp; c7 =~ -c1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="p5"></a>
<h3>Elementary Complex Functions</h3>
<a name="sqrt"></a>
<tt>GSL::Complex::sqrt</tt><br>
<tt>Complex.sqrt(c1) -> c2</tt><br>
This function returns the square root of the complex number c1, c2 = \sqrt c1. 
The branch cut is the negative real axis. The result always lies in the 
right half of the complex plane.
<p>
<a name="sqrt_real"></a>
<tt>GSL::Complex::sqrt_real</tt><br>
<tt>Complex.sqrt_real(aReal) -> c1</tt><br>
This function returns the complex square root of the real number aReal, 
where aReal may be negative.
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
eps = 1.0e-15

c1 = Complex.new2(-1.0, eps/2)
assert Complex.sqrt(c1) =~ Complex.new2(0.0,1.0)
c2 = Complex.new2(-1.0, -eps/2)
assert Complex.sqrt(c2) =~ Complex.new2(0.0,-1.0)
assert Complex.sqrt_real(-1) =~ Complex.new2(0.0,1.0)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="pow"></a>
<tt>GSL::Complex::pow</tt><br>
<tt>Complex.pow(c1,c2) -> c3</tt><br>
The function returns the complex number z raised to the complex power a, z^a. 
This is computed as \exp(\log(z)*a) using complex logarithms and complex 
exponentials.

<p>
<a name="pow_real"></a>
<tt>GSL::Complex::pow_real</tt><br>
<tt>Complex.pow_real(c1,aDouble) -> c2</tt><br>
This function returns the complex number z raised to the real power x, z^x.
<p>
<a name="exp"></a>
<tt>GSL::Complex::exp</tt><br>
<tt>Complex.exp(c1) -> c2</tt><br>
This function returns the complex exponential of the complex number z, \exp(z).
<p>
<a name="log"></a>
<tt>GSL::Complex::log</tt><br>
<tt>Complex.log(c1) -> c2</tt><br>
This function returns the complex natural logarithm (base e) of the complex 
number z, \log(z). The branch cut is the negative real axis.

<p>
<a name="log10"></a>
<tt>GSL::Complex::log10</tt><br>
<tt>Complex.log10</tt><br>
This function returns the complex base-10 logarithm of the complex number z, 
\log_10 (z)
<p>
<a name="logb"></a>
<tt>GSL::Complex::logb</tt><br>
<tt>Complex.logb(c1, c2) -> c3</tt><br>
This function returns the complex base-b logarithm of the complex number z, 
\log_b(z). This quantity is computed as the ratio \log(z)/\log(b).

<p>
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

r = 1.0; theta = 0.4
c1 = Complex.new3(r,theta)
I = Complex.new2(0,1)
c2 = Complex.pow(c1, I)
assert c2.real =~ Math.exp(-theta)

x = 0.2
c3 =  Complex.pow_real(c1,x)
c4 = Complex.new3(r,theta*x)
assert c3 =~ c4

c5 = Complex.exp( Complex.new2(0,theta))
assert c1 =~ c5
assert Complex.log(c1) =~ I.mul_real(theta)

c6 = Complex.pow(Complex.new2(10,0),Complex.new2(0,theta))
assert Complex.log10(c6) =~ Complex.new2(0,theta)

b = Complex.new2(10,1)
c7 = Complex.pow(b,Complex.new2(0,theta))
assert Complex.logb(c7,b) =~ Complex.new2(0,theta)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<a name="p6"></a>
<h3>Complex Trigonometric Functions</h3>
<a name="sin"></a>
<tt>GSL::Complex::sin</tt><br>
<tt>Complex.sin(c1) -> c2</tt><br>
This function returns the complex sine of the complex number z, \sin(z) = (\exp(iz) - \exp(-iz))/(2i).
<p>
<a name="cos"></a>
<tt>GSL::Complex::cos</tt><br>
<tt>Complex.cos(c1) -> c2</tt><br>
This function returns the complex cosine of the complex number z, 
\cos(z) = (\exp(iz) + \exp(-iz))/2.
<p>
<a name="tan"></a>
<tt>GSL::Complex::tan</tt><br>
<tt>Complex.tan(c1) -> c2</tt><br>
This function returns the complex tangent of the complex number z, 
\tan(z) = \sin(z)/\cos(z).
<p>
<a name="sec"></a>
<tt>GSL::Complex::sec</tt><br>
<tt>Complex.sec(c1) -> c2</tt><br>
This function returns the complex secant of the complex number z, 
\sec(z) = 1/\cos(z).

<a name="csc"></a>
<tt>GSL::Complex::csc</tt><br>
<tt>Complex.csc(c1) -> c2</tt><br>
This function returns the complex cosecant of the complex number z, 
\csc(z) = 1/\sin(z).
<p>
<a name="cot"></a>
<tt>GSL::Complex::cot</tt><br>
<tt>Complex.cot(c1) -> c2</tt><br>
This function returns the complex cotangent of the complex number z, 
\cot(z) = 1/\tan(z).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

r = 1.0; theta = Math::M_PI/3
c1 = Complex.new2(theta,0)
I = Complex.new2(0,1)
assert Complex.sin(c1).real =~ Math.sin(theta) &amp;&amp; Complex.cos(c1).real =~ Math.cos(theta)
assert Complex.tan(c1).real =~ Math.tan(theta) &amp;&amp; Complex.cot(c1).real =~ 1/Math.tan(theta)
assert Complex.sec(c1).real =~ 1/Math.cos(theta) &amp;&amp; Complex.csc(c1).real =~ 1/Math.sin(theta)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="p7"></a>
<h3>Inverse Complex Trigonometric Functions</h3>
<a name="arcsin"></a>
<tt>GSL::Complex::arcsin</tt><br>
<tt>Complex::arcsin(c1) -> c2</tt><br>
This function returns the complex arcsine of the complex number z, 
\arcsin(z). The branch cuts are on the real axis, less than -1 and greater 
than 1.
<p>
<a name="arcsin_real"></a>
<tt>GSL::Complex.arcsin_real</tt><br>
<tt>Complex.arcsin_real(aDouble) -> c1</tt><br>
This function returns the complex arcsine of the real number z, \arcsin(z). 
For z between -1 and 1, the function returns a real value in the range 
(-\pi,\pi]. For z less than -1 the result has a real part of -\pi/2 and 
a positive imaginary part. For z greater than 1 the result has a real 
part of \pi/2 and a negative imaginary part.
<p>
<a name="arcos"></a>
<tt>GSL::Complex::arcos</tt><br>
<tt>Complex.arcos(c1) -> c2</tt><br>
This function returns the complex arccosine of the complex number z, 
\arccos(z). The branch cuts are on the real axis, less than -1 and greater 
than 1.
<p>
<a name="arccos_real"></a>
<tt>GSL::Complex::arccos_real</tt><br>
<tt>Complex.arccos_real(aDouble) -> c1</tt><br>
This function returns the complex arccosine of the real number z, \arccos(z). 
For z between -1 and 1, the function returns a real value in the range 
[0,\pi]. For z less than -1 the result has a real part of \pi/2 and a 
negative imaginary part. For z greater than 1 the result is purely 
imaginary and positive.
<p>
<a name="arctan"></a>
<tt>GSL::Complex::arctan</tt><br>
<tt>Complex.arctan(c1) -> c2</tt><br>
This function returns the complex arctangent of the complex number z, 
\arctan(z). The branch cuts are on the imaginary axis, below -i and above i.
<p>
<a name="arcsec"></a>
<tt>GSL::Complex::arcsec</tt><br>
<tt>Complex.arcsec(aDouble) -> c1</tt><br>
This function returns the complex arcsecant of the complex number z, 
\arcsec(z) = \arccos(1/z).
<p>
<a name="arcsec_real"></a>
<tt>GSL::Complex::arcsec_real</tt><br>
<tt>Complex.arcsec_real(aDouble) -> c1</tt><br>
This function returns the complex arcsecant of the real number z, 
\arcsec(z) = \arccos(1/z).
<p>
<a name="arccsc"></a>
<tt>GSL::Complex::arccsc</tt><br>
<tt>Complex.arccsc(c1) -> c2</tt><br>
This function returns the complex arccosecant of the complex number z, 
\arccsc(z) = \arcsin(1/z).
<p>
<a name="arccsc_real"></a>
<tt>GSL::Complex::arccsc_real</tt><br>
<tt>Complex.arccsc_real(aDouble) -> c1</tt><br>
This function returns the complex arccosecant of the real number z, 
\arccsc(z) = \arcsin(1/z).
<p>
<a name="arccot"></a>
<tt>GSL::Complex::arccot</tt><br>
<tt>Complex.arccot(c1) -> c2</tt><br>
This function returns the complex arccotangent of the complex number z, 
\arccot(z) = \arctan(1/z).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
eps = 1.0e-15

r = 1.0; theta = Math::M_PI/3
c1 = Complex.new2(theta,0)
I = Complex.new2(0,1)
assert Complex.sin(c1).real =~ Math.sin(theta)
c2 = Complex.sin(c1)
assert theta =~ Complex.arcsin(c2).real

c3 = Complex.new2(11.0, eps); c4 = Complex.new2(11.0, -eps);
c5 = Complex.arcsin(c3) - Complex.arcsin(c4)
assert c5 =~ [Complex.new2(0.00, 6.18), 0.01]
assert Complex.arcsin_real(0.5) =~ Complex.new2(Math::M_PI/6,0)
c5 = Complex.arccos(c3) - Complex.arccos(c4)
assert c5 =~ [Complex.new2(0.00, -6.18),0.01]
assert Complex.arccos_real(0.5) =~ Complex.new2(Math::M_PI/3, 0)
c6 = Complex.new2(eps,21.1); c7 = Complex.new2(-eps,21.1) 
c8 = Complex.arctan(c6) - Complex.arctan(c7)
assert c8 == Complex.new2(Math::M_PI,0)
c9 = Complex.arcsec(c3)
assert c9 == Complex.arccos(c3.inverse)
c10 = Complex.arcsec_real(0.5)
assert c10 == Complex.arccos_real(2.0)
c11 = Complex.arccsc(c3)
assert c11 == Complex.arcsin(c3.inverse)
c12 = Complex.arccsc_real(0.5)
assert c12 == Complex.arcsin_real(2.0)
c13 = Complex.arccot(c3)
assert c13 == Complex.arctan(c3.inverse)
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="p8"></a>
<h3>Complex Hyperbolic Functions</h3>
<a name="sinh"></a>
<tt>GSL::Complex::sinh</tt><br>
<tt>Complex.sinh(c1) -> c2</tt><br>
This function returns the complex hyperbolic sine of the complex number z, 
\sinh(z) = (\exp(z) - \exp(-z))/2.
<p>
<a name="cosh"></a>
<tt>GSL::Complex::cosh</tt><br>
<tt>Complex.cosh(c1) -> c2</tt><br>
This function returns the complex hyperbolic cosine of the complex number z, 
\cosh(z) = (\exp(z) + \exp(-z))/2.
<p>
<a name="tanh"></a>
<tt>GSL::Complex::tanh</tt><br>
<tt>Complex.tanh(c1) -> c2</tt><br>
This function returns the complex hyperbolic tangent of the complex number z, 
\tanh(z) = \sinh(z)/\cosh(z).
<p>
<a name="sech"></a>
<tt>GSL::Complex::sech</tt><br>
<tt>Complex.sech(c1) -> c2</tt><br>
This function returns the complex hyperbolic secant of the complex number z, 
\sech(z) = 1/\cosh(z).
<p>
<a name="csch"></a>
<tt>GSL::Complex::csch</tt><br>
<tt>Complex.csch(c1) -> c2</tt><br>
This function returns the complex hyperbolic cosecant of the complex number z, 
\csch(z) = 1/\sinh(z).
<p>
<a name="coth"></a>
<tt>GSL::Complex::coth</tt><br>
<tt>Complex.coth(c1) -> c2</tt><br>
This function returns the complex hyperbolic cotangent of the complex 
number z, \coth(z) = 1/\tanh(z).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'

c1 = Complex.new2(2,1)
assert Complex.sinh(c1) == (Complex.exp(c1) - Complex.exp(-c1)).div_real(2)
assert Complex.cosh(c1) == (Complex.exp(c1) + Complex.exp(-c1)).div_real(2)
assert Complex.tanh(c1) =~ Complex.sinh(c1)/Complex.cosh(c1)
assert Complex.sech(c1) == Complex.cosh(c1).inverse
assert Complex.csch(c1) == Complex.sinh(c1).inverse
assert Complex.coth(c1) == Complex.tanh(c1).inverse
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<a name="p9"></a>
<h3>Inverse Complex Hyperbolic Functions</h3>
<a name="arcsinh"></a>
<tt>GSL::Complex::arcsinh</tt><br>
<tt>Complex.arcsinh</tt><br>
This function returns the complex hyperbolic arcsine of the complex number z, 
\arcsinh(z). The branch cuts are on the imaginary axis, below -i and above i.
<p>
<a name="arccosh"></a>
<tt>GSL::Complex::arccosh</tt><br>
<tt>Complex.arccosh</tt><br>
This function returns the complex hyperbolic arccosine of the complex 
number z, \arccosh(z). The branch cut is on the real axis, less than 1.
<p>
<a name="arccosh_real"></a>
<tt>GSL::Complex::arccosh_real</tt><br>
<tt>Complex.arccosh_real</tt><br>
This function returns the complex hyperbolic arccosine of the real 
number z, \arccosh(z).
<p>
<a name="arctanh"></a>
<tt>GSL::Complex::arctanh</tt><br>
<tt>Complex.arctanh</tt><br>
This function returns the complex hyperbolic arctangent of the complex number z, \arctanh(z). The branch cuts are on the real axis, less than -1 and greater than 1.
<p>
<a name="arctanh_real"></a>
<tt>GSL::Complex::arctanh_real</tt><br>
<tt>Complex.arctanh_real</tt><br>
This function returns the complex hyperbolic arctangent of the real 
number z, \arctanh(z).
<p>
<a name="arcsech"></a>
<tt>GSL::Complex::arcsech</tt><br>
<tt>Complex.arcsech</tt><br>
This function returns the complex hyperbolic arcsecant of the complex 
number z, \arcsech(z) = \arccosh(1/z).
<p>
<a name="arccsch"></a>
<tt>GSL::Complex::arccsch</tt><br>
<tt>Complex.arccsch</tt><br>
This function returns the complex hyperbolic arccosecant of the complex 
number z, \arccsch(z) = \arcsin(1/z).
<p>
<a name="arccoth"></a>
<tt>GSL::Complex::arccoth</tt><br>
<tt>Complex.arccoth</tt><br>
This function returns the complex hyperbolic arccotangent of the complex 
number z, \arccoth(z) = \arctanh(1/z).
<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
require 'gsl_util'
c1 = Complex.new2(2,1)

assert Complex.sinh(Complex.arcsinh(c1)) == c1
assert Complex.cosh(Complex.arccosh(c1)) =~ c1
assert Complex.cosh(Complex.arccosh_real(4.1)) =~ Complex.new2(4.1,0)
assert Complex.tanh(Complex.arctanh(c1)) =~ c1
assert Complex.tanh(Complex.arctanh_real(4.1)) =~ Complex.new2(4.1,0)
assert Complex.sech(Complex.arcsech(c1)) == c1
assert Complex.csch(Complex.arccsch(c1)) == c1
assert Complex.coth(Complex.arccoth(c1)) =~ c1
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
<p>

<a name="p10"></a>
<h4>More Complex Trigonometric Functions</h4>
<a name="cos_e"></a>
<tt>GSL::Complex::cos_e</tt><br>
<tt>Complex.cos_e(c1)-> anArray</tt><br>
This function computes the complex cosine, \cos(c1) storing the real
and imaginary parts szr, szi in objects of type Result
in a two-dimensional array <tt>anArray</tt>
<p>
<a name="logsin_e"></a>
<tt>GSL::Complex::logsin_e(c1)-> anArray</tt><br>
This function computes the complex sine, \log(\sin(c1)) storing the real
and imaginary parts szr, szi in objects of type Result
in a two-dimensional array <tt>anArray</tt>
<p>
<a name="sin_e"></a>
<tt>GSL::Complex::sin_e</tt><br>
<tt>Complex::sin_e(c1)-> anArray</tt><br>
This function computes the complex sine, \sin(c1) storing the real
and imaginary parts szr, szi in objects of type Result
in a two-dimensional array <tt>anArray</tt>

<TABLE BORDER="0" BGCOLOR="#E0E0E0" WIDTH="100%" ><TR><TD><PRE>&#13;require 'assert'
require "GSL"; include GSL
include Math
require 'gsl_util'

r = 1.0; theta = M_PI/3
c1 = Complex.new3(r, theta)

puts "cos_e"
r = Complex.cos_e(c1)
assert r[0].val == Complex.cos(c1).real &amp;&amp; r[1].val == Complex.cos(c1).imag
p  r[0].err
p  r[1].err

puts "sin_e"
r = Complex.sin_e(c1)
assert r[0].val =~ Complex.sin(c1).real
assert r[1].val =~ Complex.sin(c1).imag
 
puts "logsin_e"
r = Complex.logsin_e(c1)
assert r[0].val =~ Complex::log(Complex::sin(c1)).real
assert r[1].val =~ Complex::log(Complex::sin(c1)).imag
</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE><p>
<h3>References and Further Reading</h3>
The general formulas and details of branch cuts can be found in the following books,
<ul>
<li>
Abramowitz and Stegun, Handbook of Mathematical Functions, "Circular Functions in Terms of Real and Imaginary Parts", Formulas 4.3.55--58, "Inverse Circular Functions in Terms of Real and Imaginary Parts", Formulas 4.4.37--39, "Hyperbolic Functions in Terms of Real and Imaginary Parts", Formulas 4.5.49--52, "Inverse Hyperbolic Functions -- relation to Inverse Circular Functions", Formulas 4.6.14--19.
</ul>
<p>
<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0"><tbody>
<tr>
<td width="20" class="head"><a href="poly.html"><img border="0" alt="next" src="next.png"></a></td>
<td width="20" class="head"><a href="index.html"><img border="0" alt="up" src="up.png"></a></td>
<td width="20" class="head"><a href="math.html"><img border="0" alt="previous" src="prev.png"></a></td>
<td width="100%" class="headcenter">Complex numbers</td> 
</tr></tbody></table><hr></body>
</html>
